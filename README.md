## Вопросы на собеседовании фронтенд разработчика React.js

Здесь собраны самые популярные вопросы, задаваемые на русскоязычных собеседованиях front-end разработчиков на React.js.  Тематика вопросов включает в себя как основы JavaScript и веб-технологий так и глубокое понимание работы React.js и смежных технологий (Redux, MobX и прочего).



**CSS**:

<details>
<summary>Зачем за ранее указывать размер картинок?</summary>
<div>
  <li> Потому что при загрузке страницы, по мере загрузки картинок, изображение начнет прыгать. </li>  
</div>  
</details>  
  

<details>
<summary>Какие бывают значения display? Расскажите как ведёт себя каждое свойство?</summary>
<div>

```CSS
  display: block | inline | inline-block | inline-table |
  inline-flex | flex | list-item | none |
  run-in | table | table-caption | table-cell | table-column-group 
  | table-column |
  table-footer-group | table-header-group | table-row | table-row-group
```

<H2>block</H2>

Элемент показывается как блочный. Применение этого значения для строчных элементов, например span, заставляет его вести подобно блокам — происходит перенос строк в начале и в конце содержимого.

<H2>inline</H2>

Элемент отображается как строчный. Использование блочных элементов, таких, как div и p, автоматически создаёт перенос и показывает их содержимое с новой строки. Значение inline отменяет эту особенность, поэтому содержимое блочных элементов начинается с того места, где окончился предыдущий элемент.

<H2>inline-block</H2>

Это значение генерирует блочный элемент, который обтекается другими элементами веб-страницы подобно строчному элементу. Фактически такой элемент по своему действию похож на встраиваемые элементы (вроде img). При этом его внутренняя часть форматируется как блочный элемент, а сам элемент — как строчный.

<H2>inline-table</H2>

Определяет, что элемент является таблицей, как при использовании table, но при этом таблица является строчным элементом и происходит её обтекание другими элементами, например, текстом.

<H2>inline-flex</H2>

Элемент ведёт себя как строчный и выкладывает содержимое согласно флекс-модели.

<H2>flex</H2>

Элемент ведёт себя как блочный и выкладывает содержимое согласно флекс-модели.

<H2>list-item</H2>

Элемент выводится как блочный и добавляется маркер списка. none Временно удаляет элемент из документа. Занимаемое им место не резервируется, и веб-страница формируется так, словно элемента и не было. Изменить значение и сделать вновь видимым элемент можно с помощью скриптов, обращаясь к свойствам через объектную модель. В этом случае происходит переформатирование данных на странице с учётом вновь добавленного элемента.
</div>  
</details>  

<details>
<summary>Какие бывают значения у свойства position? Расскажите как ведёт себя каждое свойство?</summary>
<div>
  
```CSS
  position: absolute | fixed | relative | static | sticky
```  
<H2>absolute</H2>

Абсолютное позиционирование. Указывает, что элемент абсолютно позиционирован, при этом другие элементы отображаются на веб-странице словно абсолютно позиционированного элемента и нет. Положение элемента задаётся свойствами left, top, right и bottom, также на положение влияет значение свойства position родительского элемента. Так, если у родителя значение position установлено как static или родителя нет, то отсчёт координат ведётся от края окна браузера. Если у родителя значение position задано как relative, то отсчёт координат ведётся от края родительского элемента.

<H2>fixed</H2>

Фиксированное позиционирование. По своему действию это значение близко к absolute, но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы.

<H2>relative</H2>

Относительное позиционирование. Положение элемента устанавливается относительно его исходного места. Добавление свойств left, top, right и bottom изменяет позицию элемента и сдвигает его в ту или иную сторону от первоначального расположения.

<H2>static</H2>

Статичное позиционирование. Элементы отображаются как обычно. Использование свойств left, top, right и bottom не приводит к каким-либо результатам.

<H2>sticky</H2>

Это сочетание относительного и фиксированного позиционирования. Элемент рассматривается как позиционированный относительно, пока он не пересекает определённый порог, после чего рассматривается как фиксированный. Обычно применяется для фиксации заголовка на одном месте, пока содержимое, к которому относится заголовок, прокручивается на странице.
</div>  
</details> 


<br/>  
  
**JavaScript**:

<details>
<summary>Какие типы данных существуют в JavaScript?</summary>
<div>
  <ul>
    <li>
      Число <b>«number»</b> - Единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений). Например, бесконечность Infinity получается при делении на ноль. Ошибка вычислений NaN будет результатом некорректной математической операции.
    </li>
    <li>
      Строка <b>«string»</b>
    </li>
    <li>
      Булевый (логический) тип <b>«boolean»</b>
    </li>
    <li>
      Специальное значение <b>«null»</b> - В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».
    </li>
    <li>
       Специальное значение <b>«undefined»</b> - Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.
    </li>
    <li>
      Объекты <b>«object»</b> - Первые 5 типов называют «примитивными». Особняком стоит шестой тип: «объекты». Он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок {...}
    </li>
  </ul>
  <p><i>Источник: <a href ="https://learn.javascript.ru/types-intro">learn.javascript.ru</a></i></p>
</div>
</details>

<details>
<summary>Что такое цикл событий (event loop) и как он работает?</summary>
<div>
  <p>Движок браузера выполняет JavaScript в одном потоке. Для потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.</p>
  <p>Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop.</p>
  <p>Это по сути бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая — движок браузера ждет, когда поступит событие. Если непустая — первое в ней событие извлекается и его обработчик начинает выполняться. И так до бесконечности.</p>
   <p>Main Thread - основной поток, где браузер выполняет JS.</p>
   <img src="https://habrastorage.org/r/w1560/webt/l0/z9/q2/l0z9q2s-zdltplomxlim269pu7k.png"/>
   <p>На основе этой схемы строится работа всего Event Loop.</p>
   <img src="https://habrastorage.org/r/w1560/webt/zh/lq/ff/zhlqffco6t_lo1sxkql-hoqmlmq.png"/>
   <p>После начала выполнения скрипта, в очередь Tasks ставится задача с выполнением этого скрипта.</p>
   <p>После того как завершается задача по выполнению скрипта (задача от Tasks), Event Loop идет к Microtasks (после задачи от Tasks Event Loop берет задачи от Microtasks). У него Event Loop берет задачи до тех пор, пока они не закончатся. Это значит, что если время их добавления равно времени их выполнения, то Event Loop будет бесконечно их разгребать.
Далее он идет к Render и выполняет задачи от него. Задачи от Render оптимизируются браузером и, если он посчитает, что в этом цикле не нужно ничего перерисовывать, то Event Loop просто пойдет дальше. Далее Event Loop снова берет задачи от Tasks и просит у него только одну, первую в очереди задачу, передает ее в CallStack и идет дальше по циклу.</p>
   <p>Если у кого-то из заказчиков не оказалось задач, то Event Loop просто идет к следующему. И, наоборот, если у заказчика задачи занимают много времени, то остальные заказчики будут ждать своей очереди. А если задачи от какого-то заказчика оказались бесконечными, то Call Stack переполняется, и браузер начинает ругаться.</p>
    <p>
    Фрагмент кода для примера работы с Event Loop:

    function foo() {
      setTimeout(foo, 0);
    }

    foo();
  </p>
  <p>Мы видим, что функция foo вызывает сама себя рекурсивно через setTimeout внутри, но при каждом вызове она создает задачу заказчика Tasks. Как мы помним, в цикле Event Loop при выполнении очереди задач от Tasks берет только 1 задачу в цикл. И далее происходит выполнение задач от Microtasks и Render. Поэтому этот фрагмент кода не заставит Event Loop страдать и вечно разгребать его задачи. Но будет подкидывать новую задачу для заказчика Tasks на каждом круге.</p>

  <p>Давайте попробуем выполнить этот скрипт в браузере Google Chrome. Для этого я создал простой HTML-документ и подключил в нем script.js с этим фрагментом кода. После открытия документа заходим в инструменты разработчика, и открываем вкладку Perfomance и жмем там кнопку 'start profiling and reload page':</p>

  <img src="https://habrastorage.org/r/w780/webt/g2/t2/qm/g2t2qmmkttfonylvgs0tqkyfbs0.png"/>

  <p>Видим, что задачи от Tasks выполняются по одной в цикл, примерно раз в 4ms.</p>

</div>
</details>

<details>
<summary>Что такое замыкание?</summary>
<div>
  <p>Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания.</p> 
  <p>Простыми словами, замыкание запоминает переменные из того места где оно было обьявлено и не важно где оно было запущено.</p>
  <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures">developer.mozilla.org</a></i></p>
</div>
</details>

<details>
<summary>Что такое прототип объекта в JavaScript?</summary>
<div>
  <p>В JavaScript объект может наследовать свойства другого объекта. Объект, от которого наследуются свойства, называется прототипом.</p>
  <p>Суть прототипного наследования в JavaScript: объекты могут наследовать свойства от других объектов - прототипов. Связующим звеном выступает специальное свойство __proto__</p>
  <p>Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__. Недостаток этого подхода – он не работает в IE10-.</p>
  <p>К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ. Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.</p>
  <p>При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.</p>
  <p>Значением Person.prototype по умолчанию является объект с единственным свойством constructor, содержащим ссылку на Person.</p>
  <p><i>Источник: <a href ="https://learn.javascript.ru/prototype">learn.javascript.ru</a></i></p>
</div>
</details>

<details>
<summary>Как работает ключевое слово this?</summary>
<div>
  <p>В глобальном контексте выполнения (за пределами каких-либо функций), this ссылается на глобальный объект вне зависимости от использования в строгом или нестрогом режиме.</p>
  <p>В пределах функции значение this зависит от того, каким образом вызвана функция (т.е. THIS это контекст вызова функции):</p>
  <ul>
  <li>Простой вызов -  значением this будет глобальный объект. В строгом режиме, значение this остается тем значением, которое было установлено в контексте исполнения. Если такое значение не определено, оно остается undefined. Для того что бы передать значение this от одного контекста другому необходимо использовать call или apply</li>
  <li>Стрелочные функции, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект. </li>
  <li>Метод обьекта, Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод.</li>
  <li>Не прямой вызов, this это первый аргумент когда мы вызываем связанную функцию myFync.bind(thisArg)</li>
  <li>Конструктор, new Foo(), this это созданный обьект при вызове конструктора. new Foo() делает вызов конструктора, где контекст это контекст созданного обьекта. Внутри Foo обьект проиницилизорован.</li>
    
    
  
  
    //Функция конструктор
    function Foo () {
      // this is fooInstance
      this.property = 'Default Value';
    }

    //Constructor invocation
    const fooInstance = new Foo();

    fooInstance.property; // => 'Default Value'

   <img src="https://dmitripavlutin.com/static/a0f6062c2d9848de7c0b569aff17195b/7c84e/5-1.webp"/>
  

  </ul>
  <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this">developer.mozilla.org</a></i></p>
</div>
</details>

<details>
<summary>Как работают методы apply(), call() и bind()?</summary>
<div>
  <p>Функции в JavaScript никак не привязаны к своему контексту this, с одной стороны, здорово – это позволяет быть максимально гибкими, одалживать методы и так далее.</p>
  <p>Но с другой стороны – в некоторых случаях контекст может быть потерян. Способы явно указать this  - методы bind, call и apply.</p>
  <ul>
    <li>
      <p>Синтаксис метода call: func.call(context, arg1, arg2, ...)</p>
      <p>При этом вызывается функция func, первый аргумент call становится её this, а остальные передаются «как есть». Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context).</p>
    </li>
    <li>
      <p>Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply. Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.</p>
      <p>
        func.call(context, arg1, arg2) идентичен вызову func.apply(context, [arg1, arg2]);
      </p>
    </li>
    <li>
      <p>Синтаксис встроенного bind: var wrapper = func.bind(context[, arg1, arg2...])</p>
      <p>Методы bind и call/apply близки по синтаксису, но есть важнейшее отличие. Методы call/apply вызывают функцию с заданным контекстом и аргументами. А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.</p>
    </li>
  </ul>
  <p>
    <i>Источник:
      <br/>
      <a href ="https://learn.javascript.ru/call-apply#metod-apply">javascript.ru - call и apply</a>
      <br/>
      <a href ="https://learn.javascript.ru/bind#bind">javascript.ru - bind</a>
    </i>
  </p>
</div>
</details>

<details>
<summary>Что такое Promise (Промис)?</summary>
<div>
  <br/>
  <p>Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).</p>
  <p>
    Синтаксис создания Promise:

    var promise = new Promise(function(resolve, reject) {
      // Эта функция будет вызвана автоматически

      // В ней можно делать любые асинхронные операции,
      // А когда они завершатся — нужно вызвать одно из:
      // resolve(результат) при успешном выполнении
      // reject(ошибка) при ошибке
    })
  </p>
  <p>
    Универсальный метод для навешивания обработчиков:
    
    promise.then(onFulfilled, onRejected)
    
  <ul>
    <li>onFulfilled – функция, которая будет вызвана с результатом при resolve.</li>
    <li>onRejected – функция, которая будет вызвана с ошибкой при reject.</li>
  </ul>
    Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) – это то же самое.
  </p>
  <p>
    Возьмём setTimeout в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»:
  
    // Создаётся объект promise
    let promise = new Promise((resolve, reject) => {

      setTimeout(() => {
        // переведёт промис в состояние fulfilled с результатом "result"
        resolve("result");
      }, 1000);

    });

    // promise.then навешивает обработчики на успешный результат или ошибку
    promise
      .then(
        result => {
          // первая функция-обработчик - запустится при вызове resolve
          alert("Fulfilled: " + result); // result - аргумент resolve
        },
        error => {
          // вторая функция - запустится при вызове reject
          alert("Rejected: " + error); // error - аргумент reject
        }
      );
   В результате запуска кода выше – через 1 секунду выведется «Fulfilled: result».
  </p>
  <p><i>Источник: <a href ="https://learn.javascript.ru/promise">javascript.ru</a></i></p>
</div>
</details>

<details>
  <summary>Что такое статический метод класса (static)?</summary>
  <div>
    <p>
      Ключевое слово static используется в классах для определения статичных методов. Статичные методы функции, принадлежащие объекту класса, но не доступные другим объектам того же класса.
      
      class Repo {
        static getName() {
          return "Repo name is modern-js-cheatsheet"
        }
      }

      // нам не нужно создавать объект класса Repo
      console.log(Repo.getName()) // "Repo name is modern-js-cheatsheet"

      let r = new Repo();
      console.log(r.getName()) // необработанная ошибка TypeError: r.getName не является функцией
   </p>
    <p>
      Cтатические методы вызываются через имя класса. Вызывать статические методы через имя объекта запрещено. Статические методы часто используются для создания вспомогательных функций приложения.
    </p>
    <p>
    </p>
    <p>
      <i>Источник: <a href="https://tproger.ru/translations/javascript-cheatsheet/#sttcmthds">tproger.ru</a>
      </i>
    </p>
  </div>
</details>

<details>
<summary>Что такое Set, Map, WeakSet и WeakMap?</summary>
<div>
  <br/>
  <p>В ES-2015 появились новые типы коллекций в JavaScript: Set, Map, WeakSet и WeakMap.</p>
  <p>Map – коллекция для хранения записей вида ключ:значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например:</p>
  <p>
    
    'use strict';

    let map = new Map();

    map.set('1', 'str1');   // ключ-строка
    map.set(1, 'num1');     // число
    map.set(true, 'bool1'); // булевое значение

    // в обычном объекте это было бы одно и то же,
    // map сохраняет тип ключа
    alert( map.get(1)   ); // 'num1'
    alert( map.get('1') ); // 'str1'

    alert( map.size ); // 3
  </p>
  <p>
    Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. Set для этого отлично подходит:
  </p>
  <p>
    
    'use strict';

    let set = new Set();

    let vasya = {name: "Вася"};
    let petya = {name: "Петя"};
    let dasha = {name: "Даша"};

    // посещения, некоторые пользователи заходят много раз
    set.add(vasya);
    set.add(petya);
    set.add(dasha);
    set.add(vasya);
    set.add(petya);

    // set сохраняет только уникальные значения
    alert( set.size ); // 3

    set.forEach( user => alert(user.name ) ); // Вася, Петя, Даша
  </p>
  <p>
    WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. 
    То же самое – WeakMap для Map. То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти. Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект. Например, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует. Если поместить такие данные в WeakMap, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент. Например:
  </p>
  <p>
    
    // текущие активные пользователи
    let activeUsers = [
      {name: "Вася"},
      {name: "Петя"},
      {name: "Маша"}
    ];

    // вспомогательная информация о них,
    // которая напрямую не входит в объект юзера,
    // и потому хранится отдельно
    let weakMap = new WeakMap();

    weakMap.set(activeUsers[0], 1);
    weakMap.set(activeUsers[1], 2);
    weakMap.set(activeUsers[2], 3);
    weakMap.set('Katya', 4); //Будет ошибка TypeError: "Katya" is not a non-null object

    alert( weakMap.get(activeUsers[0]) ); // 1

    activeUsers.splice(0, 1); // Вася более не активный пользователь

    // weakMap теперь содержит только 2 элемента

    activeUsers.splice(0, 1); // Петя более не активный пользователь

    // weakMap теперь содержит только 1 элемент
  </p>
  <p><i>Источник: <a href ="https://learn.javascript.ru/set-map">javascript.ru</a></i></p>
</div>
</details>

<br/>

**React**:

<details>
<summary>Что такое React?</summary>
<div>
  <p>
   React это *открытая (с открытым исходным кодом) JavaScript-библиотека для фронтенда*, предназначенная для создания пользовательских интерфейсов, особенно, если речь идет о создании одностраничного приложения. Она отвечает за слой представления (view layout) в веб и мобильных приложениях. React был создан [Jordan Walke](https://github.com/jordwalke), разработчиком программного обеспечения из Facebook. React был представлен на Facebook News Feed в 2011 году, а для Instagram - в 2012 году.
   </p>
   <p>
    <a>Основными особенностями React является следующее:</a> <br>
    1. Использование *VirtualDOM* (виртуальной объектной модели документа) вместо *RealDOM* (настоящий или реальный DOM), поскольку манипуляции с *RealDOM* являются дорогостоящими с точки зрения производительности<br>
    2. Поддержка *рендеринга на стороне сервера* (Server Side Rendering, SSR)<br>
    3. Следование принципу *однонаправленного* потока или связывания данных<br>
    4. Использование *переиспользуемых/компонуемых* компонентов пользовательского интерфейса (User Interface, UI) для формирования слоя представления<br>
   </p>
</div>
</details>

<details>
<summary>В чем заключаются преимущества React перед Vue?</summary>
<div>
<p>React имеет следующие преимущества перед Vue:</p>

<p>1. Предоставляет большую гибкость при разработке больших приложений</p>
<p>2. Его легче тестировать</p>
<p>3. Подходит для разработки мобильных приложений</p>
<p>4. Доступно больше информации и готовых решений</p>

</div>
</details>


<details>
<summary>В чем разница между React и Angular?</summary>
<div>
Отличия между React и Angular в табличной форме:

| React | Angular |
| ----- | ------- |
| React - это библиотека, которая имеет только слой представления | Angular - это фреймворк, в котором реализован весь функционал MVC |
| React выполняет рендеринг на стороне сервера | Angular раньше осуществлял рендеринг на стороне клиента, но, начиная с Angular 2, он также делегировал эти полномочия серверу |
| React использует JSX, который выглядит как HTML в JS, что может сбивать с толку | Angular следует "шаблонному" подходу к HTML, что делает код более коротким и понятным |
| React Native, позволяющий разрабатывать мобильные приложения быстрее и стабильнее | Ionic, соответственно, менее стабильный и более медленный |
| В React поток данных является однонаправленным, что существенно облегчает отладку | В Angular поток данных двунаправленный, данные связывают дочерний и родительский компоненты, что часто затрудняет отладку |


</div>
</details>
<details>
<summary>Что такое JSX?</summary>
<div>
  *JSX* (JavaScript и XML) - это XML-подобный синтаксис, расширяющий возможности ECMAScript. По сути, он является синтаксическим сахаром для функции `React.createElement()`, совмещая выразительность JavaScript с HTML-подобным синтаксисом разметки.

   <p> В приведенном ниже примере, текст внутри тега `h1` в методе `render()` возвращается в виде JavaScript-функции: </p>

    
    class App extends React.Component {
      render() {
        return (
          <div>
            <h1>{'Добро пожаловать в мир React!'}</h1>
          </div>
        )
      }
    }
    
</div>
</details>

<details>
<summary>Что такое props в React?</summary>
<div>
  <p>
  *Props* - это входные данные для компонента. Это простые значения (примитивы) или объект, содержащий несколько значений, которые передаются компонентам при их создании с помощью синтаксиса, похожего на атрибуты HTML-тегов.

  <p>Основное назначение пропов в React заключается в предоставлении компоненту следующего функционала:</p>

  <p>1. Передача данных компоненту</p>
  <p>2. Вызов изменения состояния</p>
  <p>3. Использование через `this.props.reactProp` внутри метода `render()` компонента</p>
    Создадим элемент со свойством `reactProp`:
  <p>

      <Element reactProp={'1'} />
  </p>
    Этот `reactProp` добавляется в качестве свойства ко встроенному объекту *props*, который присутствет во всех компонентах, созданных с помощью React.
  <p>

     props.reactProp
  </p>  
  </p>
</div>
</details>


<details>
<summary>Как работает виртуальный DOM?</summary>
<div>
  <p>1. При любом изменении внутренних данных пользовательский интерфейс меняется в представлении виртуального DOM.</p>
  <p>2. Затем вычисляется разница между предыдущим и новым представлениями.</p>
  <p>3. После этого обновляются только те части реального DOM, которые подверглись изменениям.</p>
  <img src="https://api.bcode.dev/v1/content/storage/post/100004/a36995c00227434eb59af3dfd8f246c5.png"/>
</div>
</details>

<details>
<summary>В чем разница между теневым (Shadow) и виртуальным DOM?</summary>
<div>
  <p>*Shadow DOM* - это браузерная технология, спроектированная для ограничения области видимости переменных и CSS в *веб-компонентах*. *Virtual DOM* - это концепция, реализуемая некоторыми библиотеками JavaScript поверх браузерных API.</p>
</div>
</details>

<details>
<summary>Что такое фрагмент (Fragment)?</summary>
<div>
  <p>
  Это распространенный паттерн в React, который используется в компонентах, возвращающих несколько элементов. *Fragments* позволяют группировать дочерние элементы без создания лишних DOM-узлов:</p>
  <p>

    render() {
      return (
        <React.Fragment>
          <ChildA />
          <ChildB />
          <ChildC />
        </React.Fragment>
      )
    }
  </p>

  <p>Также существует *сокращенный синтаксис*, но он не поддерживается в некоторых инструментах:</p>
  <p>

    render() {
      return (
        <>
          <ChildA />
          <ChildB />
          <ChildC />
        </>
      )
    }
  </p>

  <p>1. Фрагменты немного быстрее и используют меньше памяти. Реальная польза от этого ощущается в очень больших и глубоких деревьях элементов</p>
  <p>2. Некоторые механизмы CSS, например, *Flexbox* и *Grid* используют связь родитель-ребенок (предок-потомок, если угодно), поэтому добавление дополнительных `div` может сломать макет страницы.</p>
  <p>3. Удобнее пользоваться инспектором DOM</p>
  </p>
</div>
</details>



<details>
<summary>Что такое `React.memo()`?</summary>
<div>
<p>Классовым компонентам можно запретить повторный рендеринг, если их пропы остались прежними, с помощью *PureComponent* или `shouldComponentUpdate()`. Теперь и у функциональных компонентов имеется такая возможность благодаря функции-обертке `React.memo()`:</p>

  ```jsx
  const MyComponent = React.memo(function MyComponent(props) {
  /* повторный рендеринг выполняется только при изменении пропов */
  });
  ```

<p>Похожий функционал предоставляет хук `useMemo()`.</p>
</div>
</details>


<details>
<summary>Какие преимущества предоставляет использование React?</summary>
<div>
  <p>Вот список основных преимуществ:

    1. Повышение производительности приложения благодаря *виртуальному DOM*
    2. *JSX* облегчает написание и чтение кода
    3. Возможность рендеринга как на стороне клиента, так и на стороне сервера
    4. Возможность относительно простой интеграции с фреймворками (Angular, Backbone), поскольку React - это всего лишь библиотека
    5. Возможность быстрого юнит и интеграционного тестирования с помощью таких инструментов, как Jest
  </p>

</div>
</details>

<details>
<summary>Какие ограничения имеются в React?</summary>
<div>
  <p>Кроме преимуществ, в React существуют некоторые ограничения:

    1. React - это всего лишь библиотека, отвечающая за слой представления, а не полноценный фреймворк
    2. Его трудно изучать новичкам в веб-разработке
    3. Интеграция с традиционными MVC-фреймворками требует дополнительной настройки
    4. Код является более сложным из-за встроенных шаблонов и JSX
    5. Большое количество мелких компонентов приводит к сложности в проектировании и построении архитектуры приложения
  </p>
</div>
</details>


<details>
<summary>Как реализовать рендеринг на стороне сервера или SSR?</summary>
<div>
  <p>React поддерживает рендеринг на стороне Node-сервера из коробки. Для этого используется специальная версия DOM-рендерера, которая реализует такой же паттерн, что и клиентская версия:</p>

   
    import ReactDOMServer from 'react-dom/server'
    import App from './App'

    ReactDOMServer.renderToString(<App />)
    

  <p>Этот метод возвращает обычный HTML в виде строки, которая затем может быть помещена в тело (body) ответа сервера. На стороне клиента React определяет предварительно отрендеренный контент и просто вставляет его в существующее дерево компонентов.
  </p>
</div>
</details>


<details>
<summary>Почему в React нельзя обновлять пропы?</summary>
<div>
  <p>Философия React гласит, что пропы должны быть *иммутабельными* (неизменяемыми или неизменными) и *однонаправленными* (передаваемыми в одном направлении, сверху вниз). Это означает, что родительский компонент может передавать пропы дочерним, а последние не могут их модифицировать.</p>
</div>
</details>


<details>
<summary>Назовите ключевые принципы Redux?</summary>
<div>
<p>Redux следует трем фундаментальным принципам:</[]>

     1. **Единственный источник истины:** состояние всего приложения хранится в древовидном объекта - в одном хранилище. Единственное состояние-дерево облегчает наблюдение за изменениями и отладку или инспектирование приложения
     2. **Состояние доступно только для чтения:** единственный способ изменить состояние заключается в запуске операции - объекте, описывающем произошедшее. Это позволяет гарантировать, что ни представления, ни сетевые коллбеки не буду иметь возможности изменять состояние напрямую
     3. **Изменения производятся с помощью "чистых" функций:** для определения того, как изменяется состояние в зависимости от операции, создаются редукторы (reducers). Редукторы - это "чистые" функции, принимающие предыдущее состояние в качестве аргумента и возвращающие новое
</p>
</div>
</details>


<details>
<summary>Обязательно ли хранить все состояние в Redux? Можно ли использовать внутреннее состояние компонентов?</summary>
<div>
  <p>
  </p>
</div>
</details>











<details>
<summary>Какие методы жизненного цикла компонента существуют в React?</summary>
<div>
  <ul>
     <li>
       <b>render()</b> — единственный обязательный метод в классовом компоненте.
       <br>
       При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов: Элемент React, Массивы и фрагменты, Порталы, Строки и числа, Booleans или null
     </li>
    <br/>
    <li>
      <b>constructor()</b> - Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. Это может привести к багам.
      <br>
      Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру.
      <br>
      Конструктор — единственное место, где можно напрямую изменять this.state. В остальных методах необходимо использовать this.setState().
      <br>
      <b>useState</b> - заменяет конструктор. Служит для управление локальным state у компонента.
    </li>
    <br/>
    <li>
      <b>componentDidMount()</b> - вызывается сразу после монтирования (то есть, вставки компонента в DOM). В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
      <br/>
      Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().
      <br/>
      <b>useEffect(callBack, [])</b> - Инициализируется немедленно после первого рендера, инициализирует state которому могут понадобиться DOM ноды, Network запросы и другие side effects.
    </li>
    <br/>
    <li>
      <b>componentDidUpdate(prevProps, prevState, snapshot)</b> - вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.
      <br>
      <p>

        const mounted = useRef()
        useEffect(() => {
          if(!mounted.current) {
            mounted.current = true
          } else {
            console.log('componentDidUpdate !)
          }

        })

   </p>
    <b>useEffect(callBack)</b> - вызывается и при первом рендере и после обновления. Для эмуляции componentDidUpdate нужна проверка на первый рендер и useRef.
    </li>
    <br/>
    <li>
      <b>componentWillUnmount()</b> - вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().
    </li>
    <br/>
      <b>useEffect(callBack)</b> - return функция. Возвращает функцию которая будет запущена после unmount'a компоненты. Подходит для отмены таймеров, сетевых запросов и подписок.
    <li>
      <b>shouldComponentUpdate(nextProps, nextState)</b> - вызывается перед рендером, когда получает новые пропсы или состояние. Значение по умолчанию равно true. Этот метод нужен только для повышения производительности.. Но не опирайтесь на его возможность «предотвратить» рендер, это может привести к багам. Вместо этого используйте PureComponent, который позволяет не описывать поведение shouldComponentUpdate() вручную. PureComponent поверхностно сравнивает пропсы и состояние и позволяет не пропустить необходимое обновление.
      <b>memo</b> - управляет обновлением компонента
    </li>
    <br/>
    <li>
      <b>static getDerivedStateFromProps(props, state)</b> - вызывается непосредственно перед вызовом метода render, как при начальном монтировании, так и при последующих обновлениях. Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.
      <br/>
      Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах. 
    </li>
    <br/>
    <li>
      <b>getSnapshotBeforeUpdate(prevProps, prevState)</b> - вызывается прямо перед этапом «фиксирования» (например, перед добавлением в DOM). Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как параметр componentDidUpdate().
    </li>
    <br/>
    <li>
      <b>static getDerivedStateFromError(error)</b> - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает ошибку в качестве параметра и возвращает значение для обновления состояния. getDerivedStateFromError() вызывается во время этапа «рендера». Поэтому здесь запрещены любые побочные эффекты, но их можно использовать в componentDidCatch().
    </li>
    <br/>
    <li>
      <b>componentDidCatch(error, info)</b> - Этот метод жизненного цикла вызывается после возникновения ошибки у компонента-потомка. Он получает два параметра: error — перехваченная ошибка, info — объект с ключом componentStack, содержащий информацию о компоненте, в котором произошла ошибка. Метод можно использовать для логирования ошибок.
    </li>
    <li>
      <b>useRef</b> - предоставляет доступ к DOM елементам созданным при рендере, помогает useEffect симитировать работу componentDidUpdate.
       <p>useRef() - это хук принимающий в качестве аргумента какое то значение и возвращающий референс. Референс это специальный обьект у которого есть свойство current.</p>
       reference.current - предоставляет доступ к значению, reference.current = newValue обновляет значение.<br/>
       1. Значение референса остается не изменным между ререндерами. <br/>
       2. Обновление референса не вызывает ререндер. <br/>
    </li>
    <li>
      <b>memo</b> - управление ререндером компонента. Заменяет shouldComponentUpdate.
      <p>Когда компонент обернут в React.memo. React отрисосвывает компонент и запоминает результат. Перед следющим рендером, если props и state не изменились, реакт использует сохраненный компонент и пропускает рендер.</p>
    </li>
  </ul>
  <img src='https://cdn-images-1.medium.com/max/1600/1*cPwvUhZrnB1dtZnjBEfXfA.png' />
  <img src='https://res.cloudinary.com/practicaldev/image/fetch/s--S1NFg-EJ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://miro.medium.com/max/800/1%2AJ1OWWbEDit18yTrM0sthgA.png'/>
  <img src ='https://res.cloudinary.com/practicaldev/image/fetch/s--HiDZKzEO--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://miro.medium.com/max/1000/1%2A2ANppcgcNvccNSsS8fHbnQ.png'/>
  <p><i>Источник: <a href ="https://ru.reactjs.org/docs/react-component.html#render">ru.reactjs.org</a></i></p>
</div>
</details>

<details>
<summary>Что такое Context в React и для чего он используется?</summary>
<div>
  <br />
  <p>Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык).</p>
  <p>Контекст позволяет избежать передачи пропсов в промежуточные компоненты: 
    
    // Контекст позволяет передавать значение глубоко
    // в дерево компонентов без явной передачи пропсов
    // на каждом уровне. Создадим контекст для текущей
    // UI-темы (со значением "light" по умолчанию).
    const ThemeContext = React.createContext('light');

    class App extends React.Component {
      render() {
        // Компонент Provider используется для передачи текущей
        // UI-темы вниз по дереву. Любой компонент может использовать
        // этот контекст и не важно, как глубоко он находится.
        // В этом примере мы передаём "dark" в качестве значения контекста.
        return (
          <ThemeContext.Provider value="dark">
            <Toolbar />
          </ThemeContext.Provider>
        );
      }
    }

    // Компонент, который находится в середине,
    // теперь не должен явно передавать UI-тему вниз.
    function Toolbar(props) {
      return (
        <div>
          <ThemedButton />
        </div>
      );
    }

    class ThemedButton extends React.Component {
      // Определяем contextType, чтобы получить значение контекста.
      // React найдёт (выше по дереву) ближайший Provider-компонент,
      // предоставляющий этот контекст, и использует его значение.
      // В этом примере значение UI-темы будет "dark".
      static contextType = ThemeContext;
      render() {
        return <Button theme={this.context} />;
      }
    }
  </p>
  <p>Обычно контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных уровнях вложенности. По возможности не используйте его, так как это усложняет переиспользование компонентов.</p>
  <ul>
    <b>API:</b>
    <li>
      <b>React.createContext</b> - оздание объекта Context. Когда React рендерит компонент, который подписан на этот объект, React получит текущее значение контекста из ближайшего подходящего Provider выше в дереве компонентов.
    </li>
    <li>
      <b>Context.Provider</b> - Каждый объект Контекста используется вместе с Provider компонентом, который позволяет дочерним компонентам, использующим этот контекст, подписаться на его изменения.
    </li>
    <li>
      <b>Class.contextType</b> - В свойство класса contextType может быть назначен объект контекста, созданный с помощью React.createContext(). Это позволяет вам использовать ближайшее и актуальное значение указанного контекста при помощи this.context. В этом случае вы получаете доступ к контексту, как во всех методах жизненного цикла, так и в рендер методе.
    </li>
    <li>
      <b>Context.Consumer</b> - Consumer — это React-компонент, который подписывается на изменения контекста. В свою очередь, это позволяет вам подписаться на контекст в функциональном компоненте. Consumer принимает функцию в качестве дочернего компонента. Эта функция принимает текущее значение контекста и возвращает React-компонент. Передаваемый аргумент value будет равен ближайшему (вверх по дереву) значению этого контекста, а именно пропу value Provider компонента. Если такого Provider компонента не существует, аргумент value будет равен значению defaultValue, которое было передано в createContext().
    </li>
  </ul>
  <p><i>Источник: <a href ="https://ru.reactjs.org/docs/context.html">ru.reactjs.org</a></i></p>
</div>
</details>

<details>
<summary>Что такое Виртуальная DOM?</summary>
<div>
  <br />
  <p>
    Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.
  </p>
  <p>
    Поскольку «виртуальный DOM» — это скорее паттерн, чем конкретная технология, этим термином иногда обозначают разные понятия. В мире React «виртуальный DOM» обычно ассоциируется с React-элементами , поскольку они являются объектами, представляющими пользовательский интерфейс. Тем не менее, React также использует внутренние объекты, называемые «волокнами» (fibers), чтобы хранить дополнительную информацию о дереве компонентов. Их также можно считать частью реализации «виртуального DOM» в React.
  </p>
  <p><i>Источник: <a href ="https://ru.reactjs.org/docs/faq-internals.html">ru.reactjs.org</a></i></p>
</div>
</details>

<details>
<summary>Для чего нужен атрибут key при рендере списков?</summary>
<div>
  <br />
  <p>
    Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.
  </p>
  <p>
    Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи. Когда у вас нет заданных ID для списка, то в крайнем случае можно использовать индекс элемента как ключ.
    Так же можно использовать UUID. Главное что бы ключи были уникальные и не смещались.
  </p>
  <p><i>Источник: <a href ="https://ru.reactjs.org/docs/lists-and-keys.html">ru.reactjs.org</a></i></p>
</div>
</details>

<details>
<summary>Как работает проп children?</summary>
<div>
  <br />
  <p>
    Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод:
    
    function FancyBorder(props) {
      return (
        <div className={'FancyBorder FancyBorder-' + props.color}>
          {props.children}
        </div>
      );
    }
  </p>
  <p>
    Это позволит передать компоненту произвольные дочерние элементы, вложив их в JSX:
  
    function WelcomeDialog() {
      return (
        <FancyBorder color="blue">
          <h1 className="Dialog-title">
            Добро пожаловать
          </h1>
          <p className="Dialog-message">
            Спасибо, что посетили наш космический корабль!
          </p>
        </FancyBorder>
      );
    }
  </p>
  <p>
    Всё, что находится внутри JSX-тега <FancyBorder>, передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри div, все переданные элементы отображаются в конечном выводе.
  </p>
  <p><i>Источник: <a href ="https://ru.reactjs.org/docs/composition-vs-inheritance.html#containment">ru.reactjs.org</a></i></p>
</div>
</details>


<details>
<summary>В чем разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?</summary>
<div>
  <br />
  <p> В HTML элементы формы, такие как input, textarea и select, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState().
  </p>
  <p>
    В управляемом компоненте с каждой мутацией состояния связана функция-обработчик. Благодаря этому валидация или изменение введённого значения становится простой задачей. Например, если мы хотим, чтобы имя обязательно было набрано заглавными буквами, можно написать такой handleChange:
    
    handleChange(event) {
      this.setState({value: event.target.value.toUpperCase()});
    }
  </p>
  <p>
    Вместо того, чтобы писать обработчик события для каждого обновления состояния, вы можете использовать неуправляемый компонент и читать значения из DOM через реф.
  
    class NameForm extends React.Component {
      constructor(props) {
        super(props);
        this.handleSubmit = this.handleSubmit.bind(this);
        this.input = React.createRef();
      }

      handleSubmit(event) {
        alert('Отправленное имя: ' + this.input.current.value);
        event.preventDefault();
      }

      render() {
        return (
          <form onSubmit={this.handleSubmit}>
            <label>
              Имя:
              <input type="text" ref={this.input} />
            </label>
            <input type="submit" value="Отправить" />
          </form>
        );
      }
    }
  </p>
  <p>
    Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. Поэтому в обычных ситуациях мы рекомендуем использовать управляемые компоненты.
  </p>
  <p>Настройка контролируемого input включает в себя 3 шага: </p>
    1. Создать стейт для хранения значения input: 
    <p>

      [val, setVal] = useState('') 
   </p>
    2. Определить event handler для обновления state когда пользователь вводит данные в input 
    <p> 

      onChange = event => setVal(event.target.value)
   </p>    
    3. Присоединить eventHandler и установить значение аттрибута value на input field: 
    <p>

      <input onChange={onChange} value={val} />.
   </p>
    Debouncing значения input'a в state требует создания нового разделенного состояния с использованием hook'a useDebouncedValue(value, wait):
    <p>  
    
     debouncedQuery = useDebouncedValue(value, wait). 
   </p>
</div>
</details>

<details>
<summary>Что такое PureComponent?</summary>
<div>
  <br />
  <p>
    React.PureComponent похож на React.Component. Отличие заключается в том, что React.Component не реализует shouldComponentUpdate(), а React.PureComponent реализует его поверхностным сравнением пропсов и состояния.
  </p>
  <p>
    Если метод render() вашего React-компонента всегда рендерит одинаковый результат при одних и тех же пропсах и состояниях, для повышения производительности в некоторых случаях вы можете использовать React.PureComponent.
  </p>
  <p>
    Метод shouldComponentUpdate() базового класса React.PureComponent делает только поверхностное сравнение объектов. Если они содержат сложные структуры данных, это может привести к неправильной работе для более глубоких различий (то есть, различий, не выраженных на поверхности структуры). Наследуйте класс PureComponent только тогда, когда вы ожидаете использовать простые пропсы и состояние
  </p>
  <p><i>Источник: <a href ="https://ru.reactjs.org/docs/react-api.html#reactpurecomponent">ru.reactjs.org</a></i></p>
</div>
</details>


<details>
<summary>Что такое Компонент высшего порядка (Higher-Order Component, HOC)?</summary>
<div>
  <br />
  <p>
    Говоря просто, компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент. HOC часто встречаются в сторонних библиотеках, например connect в Redux и createFragmentContainer в Relay.

    const EnhancedComponent = higherOrderComponent(WrappedComponent);
  </p>
  <p>
    Давайте реализуем функцию withSubscription — она будет создавать компоненты и подписывать их на обновления DataSource (наподобие CommentList и BlogPost). Функция будет принимать оборачиваемый компонент и через пропсы передавать ему новые данные:
  
    const CommentListWithSubscription = withSubscription(
      CommentList,
      (DataSource) => DataSource.getComments()
    );

    const BlogPostWithSubscription = withSubscription(
      BlogPost,
      (DataSource, props) => DataSource.getBlogPost(props.id)
    );
  </p>
  <p>
    Первый параметр — это оборачиваемый компонент. Второй — функция, которая извлекает нужные нам данные, она получает DataSource и текущие пропсы.
  </p>
  <p>
    Заметьте, что HOC ничего не меняет и не наследует поведение оборачиваемого компонента, вместо этого HOC оборачивает оригинальный компонент в контейнер посредством композиции. HOC является чистой функцией без побочных эффектов. Вот и всё! Оборачиваемый компонент получает все пропсы, переданные контейнеру, а также проп data. Для HOC не важно, как будут использоваться данные, а оборачиваемому компоненту не важно, откуда они берутся.
  </p>
  <p>1. Обеспечения возможности переиспользования кода, логики, а также для абстрагирования шаблонов</p>
  <p>2. Отложенного рендеринга</p>
  <p>3. Абстрагирования и манипулирования состоянием</p>
  <p>4. Манипулирования пропами</p>
</div>
</details>

<details>
<summary>Что такое хуки в React?</summary>
<div>
  <br />
  <p>
    Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов. Хуки — это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненного цикла React из функциональных компонентов. Хуки не работают внутри классов — они дают вам возможность использовать React без классов. 
  </p>
  <p>
    Хук состояния - useState. ASYNC.
    
      // Toggle a boolean
      const [toggled, setToggled] = useState(false);
      setToggled(toggled => !toggled);

      // Increase a counter
      const [count, setCount] = useState(0);
      setCount(count => count + 1);

      // Add an item to array
      const [items, setItems] = useState([]);
      setItems(items => [...items, 'New Item']);
          

   <p>1. Вызов useState превращает компонент в stateful functional component.</p> 
   <p>2. Первый аргумент хука, initial state</p>
   <p>3. Хук возвращает массив. Первый итем массива это текущее значение state.</p>
   <p>4. Второй итем массива это функция для обновления state</p>
   useState можно использовать в callback функциях eventhandler или в callback других хуков.
   После вызова функции обновления state, компонент делает re-render. Для того что бы новый state стал актуальным.
   <br>
   <p>Ленивая инициализация state:</p>
   Когда инициализация state требует тяжелую вычислительную операцию, надо использовать ленивую инициализацию state. Передавай в качестве агрумента useState, функциюс этой операцией. Создание функции происходит быстро. Даже если она требует дорогих вычислений. Много мощности займет только вызов функции. А функция будет вызвана реактов только когда понадобиться инициалищирующее значение т.е. при первом render.
   <br>
   <p>Некорректно вызывать useState при помощи:</p>
   <p>1. Условий (if, else)</p>
   <p>2. Вложенных функций </p>
  
   <p>Когда вычисление нового стейта используется при помощи предидущего стейта, можно использовать callback: </p>
   <p>

      const [state, setState] = useState(initialState);

      // заменяет старый стейт на новый и запускает ререндер
      setState(prevState => nextState);

      // после ререндера старый стейт заменяется новым
   </p>   
  </p>
  <p>
    Хук эффекта - useEffect
    
    import React, { useState, useEffect } from 'react';

    function Example() {
      const [count, setCount] = useState(0);

      // По принципу componentDidMount и componentDidUpdate:
      useEffect(() => {
        // Обновляем заголовок документа, используя API браузера
        document.title = `Вы нажали ${count} раз`;
      });

      return (
        <div>
          <p>Вы нажали {count} раз</p>
          <button onClick={() => setCount(count + 1)}>
            Нажми на меня
          </button>
        </div>
      );
    }
   
   Когда вы вызываете useEffect, React получает указание запустить вашу функцию с «эффектом» после того, как он отправил изменения в DOM. Поскольку эффекты объявляются внутри компонента, у них есть доступ к его пропсам и состоянию. По умолчанию, React запускает эффекты после каждого рендера, включая первый рендер.
  </p>
  <p><i>Источник: <a href ="https://ru.reactjs.org/docs/hooks-overview.html">ru.reactjs.org</a></i></p>
</div>
</details>

<details>
<summary>Что такое порталы в React?</summary>
<div>
  <br />
  <p>
    Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.

    ReactDOM.createPortal(child, container)
  </p>
  <p>
    Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент.
  </p>
  <p>
    Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.
  </p>
  <p><i>Источник: <a href ="https://ru.reactjs.org/docs/portals.html">ru.reactjs.org</a></i></p>
</div>
</details>

<details>
<summary>Что такое React Reconciliation (Cверка) и как он работает?</summary>
<div>
  <br />
  <p>
    Reconciliation (Cверка) - это процесс, посредством которого React обновляет DOM. Когда состояние компонента изменяется, React должен рассчитать необходимость обновления DOM. Это делается путем создания виртуального DOM и сравнения его с текущим DOM. В этом контексте виртуальный DOM будет содержать новое состояние компонента.
  </p>
  <p>
    При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов. 
  </p>
  <p>
    Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. 
  </p>
  <p>
    При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты.
  </p>
  <p>
    По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие. Эта неэффективность может стать проблемой. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева.
  </p>
  <p><i>Источник: 
    <a href ="https://css-tricks.com/how-react-reconciliation-works/">css-tricks.com</a>,
    <a href ="https://ru.reactjs.org/docs/reconciliation.html">ru.reactjs.org</a>
  </i></p>
</div>
</details>

<details>
<summary>Можно создавать анимации в React?</summary>
<div>
  <br />
  <p>
    React может использоваться для создания крутых анимаций! В качестве примера посмотрите библиотеки React Transition Group и React Motion.
  </p>
  <p><i>Источник: <a href ="https://ru.reactjs.org/docs/faq-styling.html#can-i-do-animations-in-react">ru.reactjs.org</a></i></p>
</div>
</details>

<details>
<summary>Что такое SOLID?</summary>
<div>
</div>
</details>

<details>
<summary>Что такое DRY?</summary>
<div>
  <p> Don’t Repeat Yourself </p>
  <p> Главный из паттернов для поддержания этого принципа High-Order Component. </p>
</div>
</details>



<details>
<summary>Сколько будет re-renders  при 4 useState?</summary>
<div>
</div>
</details>
<br/>

**Flux-архитектура, Redux и MobX**:

<details>
  <summary>Что такое Flux - архитектура? Какие сущности она имеет?</summary>
  <div>
    <p>
      Flux-архитектура — архитектурный подход или набор шаблонов программирования для построения пользовательского интерфейса веб-приложений, сочетающийся с реактивным программированием и построенный на однонаправленных потоках данных.
    </p>
    <p>
      Основной отличительной особенностью Flux является односторонняя направленность передачи данных между компонентами Flux-архитектуры. Архитектура накладывает ограничения на поток данных, в частности, исключая возможность обновления состояния компонентов самими собой. Такой подход делает поток данных предсказуемым и позволяет легче проследить причины возможных ошибок в программном обеспечении.
    </p>
    <p>
      В минимальном варианте Flux-архитектура может содержать три слоя, взаимодействующие по порядку:
    </p>
    <ul>
      <li>
        <b>Действия</b> (англ. actions) — выражение событий (часто для действий используются просто имена — строки, содержащие некоторый «глагол»). Диспетчеры передают действия нижележащим компонентам (хранилищам) по одному. Новое действие не передаётся пока предыдущее полностью не обработано компонентами. Действия из-за работы источника действия, например, пользователя, поступают асинхронно, но их диспетчеризация явлется синхронным процессом. Кроме имени (англ. name), действия могут иметь полезную нагрузку (англ. payload), содержащую относящиеся к действию данные.
      </li>
      <li>
        <b>Диспетчер/Диспатчер</b> (англ. dispatcher) предназначен для передачи действий хранилищам. В упрощённом варианте диспетчер может вообще не выделяться, как единственный на всё приложение. В диспетчере хранилища регистрируют свои функции обратного вызова (callback) и зависимости между хранилищами.
      </li>
      <li>
        <b>Хранилище</b> (англ. store) является местом, где сосредоточено состояние (англ. state) приложения. Остальные компоненты, согласно Flux, не имеют значимого (с точки зрения архитектуры) состояния. Изменение состояния хранилища происходит строго на основе данных действия и старого состояния хранилища при помощи чистых функций.
      </li>
      <li>
        <b>Представление</b> (англ. view) — компонент, обычно отвечающий за выдачу информации пользователю. Во Flux-архитектуре, которая может технически не касаться внутреннего устройства представлений вообще, это — конечная точка потоков данных. Для информационной архитектуры важно только, что данные попадают в систему (то есть, обратно в хранилища) только через действия.
      </li>
    </ul>
    <p><i>Источник: <a href ="https://ru.wikipedia.org/wiki/Flux-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0">wikipedia.org</a></i></p>
  </div>
</details>

<details>
<summary>Назовите ключевые принципы Redux</summary>
<div>
  <p>Redux следует трем фундаментальным принципам:</p>

  <p>1. Единственный источник истины:** состояние всего приложения хранится в древовидном объекта - в одном хранилище. Единственное состояние-дерево облегчает наблюдение за изменениями и отладку или инспектирование приложения</p>
  <p>2. Состояние доступно только для чтения:** единственный способ изменить состояние заключается в запуске операции - объекте, описывающем произошедшее. Это позволяет гарантировать, что ни представления, ни сетевые коллбеки не буду иметь возможности изменять состояние напрямую</p>
  <p>3. Изменения производятся с помощью "чистых" функций:** для определения того, как изменяется состояние в зависимости от операции, создаются редукторы (reducers). Редукторы - это "чистые" функции, принимающие предыдущее состояние в качестве аргумента и возвращающие новое</p>
</div>
</details>

<details>
<summary>Проведите сравнение Redux и Flux</summary>
<div>
  <p>Отличия между Redux и Flux можно свести к следующему:</p>

  <p>1. **Недопустимость мутаций:** во Flux состояние может быть изменяемым, а Redux требует, чтобы состояние было иммутабельным, и многие библиотеки для Redux исходят из предположения, что вы никогда не будете менять состояние напрямую. Вы можете обеспечить иммутабельность состояния с помощью таких пакетов, как `redux-immutable-state-invariant`, `Immutable.js` или условившись с другими членами команды о написании иммутабельного кода</p>
  <p>2. **Осторожность в выборе библиотек:** Flux не пытается решать такие проблемы, как повторное выполнение/отмена выполнения, стабильность (постоянство) кода или проблемы, связанные с обработкой форм, явно, а Redux имеет возможность к расширению с помощью промежуточного программного обеспечения (middleware) и предохранителей хранилища, что породило богатую экосистему</p>
  <p>3. **Отсутствие интеграции с Flow:** Flux позволяет осуществлять очень выразительную статическую проверку типов, а Redux пока не поддерживает такой возможности</p>
</div>
</details>

<details>
<summary>В чем разница между `mapStateToProps()` и `mapDispatchToProps()`?</summary>
<div>
<p> `mapStateToProps()` - это утилита, помогающая компонентам получать обновленное состояние (которое было обновлено другим компонентом):</p>

<p>

    const mapStateToProps = (state) => {
      return {
        todos: getVisibleTodos(state.todos, state.visibilityFilter)
      }
    }
</p>

<p>`mapDispatchToProps()` - утилита, помогающая компонентам вызывать операции (которые могут привести к обновлению состояния приложения):</p>

<p>

    const mapDispatchToProps = (dispatch) => {
      return {
        onTodoClick: (id) => {
          dispatch(toggleTodo(id))
        }
      }
    }
</p>

<p>Для `mapDispatchToProps()` рекомендуется всегда использовать короткую форму записи объекта.</p>

<p>Redux оборачивает ее в другую функцию, которая выглядит как `(…args) => dispatch(onTodoClick(…args))`, и передает эту обертку в качестве пропа в компонент:</p>

<p>

    const mapDispatchToProps = ({
      onTodoClick
    })
</p>
</div>
</details>

<details>
<summary>Обязательно ли хранить состояние всех компонентов в хранилище Redux?</summary>
<div>
<p>Данные приложения следует хранить в хранилище Redux, а состояние компонентов пользовательского интерфейса в соответствующих компонентах. У создателя Redux Дэна Абрамова по этому поводу есть статья под названием "Следует ли вам использовать Redux?"</p>
</div>
</details>


<details>
<summary>Как рекомендуется получать доступ к хранилищу Redux?</summary>
<div>
<p>Лучшим способом получить хранилище в компоненте является использование функции `connect()`, которая создает новый компонент, оборачивающий существующий. Этот паттерн называется *компоненты высшего порядка*, он является предпочтительным способом расширения функциональности компонента в React. Это позволяет передавать в компонент состояние и "создателей операций" (action creators), в том числе, при обновлении хранилища.</p>

<p>Создадим компонент `FilterLink` с помощью `connect()`:</p>

<p>

     import { connect } from 'react-redux'
     import { setVisibilityFilter } from '../actions'
     import Link from '../components/Link'

     const mapStateToProps = (state, ownProps) => ({
       active: ownProps.filter === state.visibilityFilter
     })

     const mapDispatchToProps = (dispatch, ownProps) => ({
       onClick: () => dispatch(setVisibilityFilter(ownProps.filter))
     })

     const FilterLink = connect(
       mapStateToProps,
       mapDispatchToProps
     )(Link)

     export default FilterLink
</p>

<p>Поскольку такой вариант имеет несколько оптимизаций производительности и, как правило, меньше подвержен "багам", разработчики Redux почти всегда рекомендуют использовать `connect()` вместо прямого доступа к хранилищу (с помощью API контекста).</p>

     class MyComponent {
       someMethod() {
         doSomethingWith(this.context.store)
       }
     }
</p>
</div>
</details>

<details>
<summary>Для чего в Redux нужны константы??</summary>
<div>
<p>Константы позволяют легко обнаруживать все случаи их применения в проекте при использовании IDE. Они также позволяют избегать глупых ошибок, связанных с типами - немедленно выбрасывается исключение `ReferenceError`.</p>

<p>Обычно, мы сохраняем константы в отдельном файле  (`constants.js` или `actionTypes.js`)</p>

```javascript
export const ADD_TODO = 'ADD_TODO'
export const DELETE_TODO = 'DELETE_TODO'
export const EDIT_TODO = 'EDIT_TODO'
export const COMPLETE_TODO = 'COMPLETE_TODO'
export const COMPLETE_ALL = 'COMPLETE_ALL'
export const CLEAR_COMPLETED = 'CLEAR_COMPLETED'
```

<p>В Redux мы используем их в двух местах:</p>

1. **Во время создания операции:**

      `actions.js`:

      ```javascript
      import { ADD_TODO } from './actionTypes';

      export function addTodo(text) {
        return { type: ADD_TODO, text }
      }
      ```

2. **В редукторах:**

      `reducer.js`:

      ```javascript
      import { ADD_TODO } from './actionTypes'

      export default (state = [], action) => {
        switch (action.type) {
          case ADD_TODO:
            return [
              ...state,
              {
                text: action.text,
                completed: false
              }
            ];
          default:
            return state
        }
      }
      ```
       
</div>
</details>

<details>
<summary>Какие способы существуют для написания `mapDispatchToProps()`?</summary>
<div>
<p>Существует несколько способов привязать "создателей операций" к методу `dispatch()` в `mapDispatchToProps()`.
</p>

<p>Ниже представлены возможные варианты:</p>

```javascript
const mapDispatchToProps = (dispatch) => ({
action: () => dispatch(action())
})
```

```javascript
const mapDispatchToProps = (dispatch) => ({
action: bindActionCreators(action, dispatch)
})
```

```javascript
const mapDispatchToProps = { action }
```
<p>Третий вариант является сокращением первого.</p>        
</div>
</details>

<details>
<summary>Для чего используется параметр `ownProps` в методах `mapStateToProps()` и `mapDispatchToProps()`?</summary>
<div>
<p> При определении параметра `ownProps` React Redux передает пропы в компонент в функциях "подключения". Поэтому, если вы используете подключенный компонент:</p>

```jsx harmony
import ConnectedComponent from './containers/ConnectedComponent';

<ConnectedComponent user='Иван' />
```

`ownProps` внутри функций `mapStateToProps()` и `mapDispatchToProps()` будет объектом:

```javascript
{ user: 'Иван' }
```

<p>Вы можете использовать этот объект для определения значения, возвращаемого указанными функциями.</p>
</div>
</details>


<details>
<summary>Как структурировать директории верхнего уровня в Redux?</summary>
<div>
<p>Большинство приложений имеют несколько "топовых" директорий:</p>

<p>1. **components**: используется для "тупых" компонентов, не знающих о Redux</p>
<p>2. **containers**: используется для "умных" компонентов, подключенных к Redux</p>
<p>3. **actions**: используется для всех создателей операций - названия файлов указывают на соответствующие части приложения</p>
<p>4. **reducers**: используется для всех редукторов - названия коррелируют с ключами состояния</p>
<p>5. **store**: используется для инициализации хранилища</p>

<p>Такая структура прекрасно подходит для небольших и средних приложений.</p>
</div>
</details>

<details>
<summary>Что такое селекторы (selectors) Redux и зачем их использовать?</summary>
<div>
<p>*Selectors* - это функции, принимающие состояние Redux в качестве аргумента и возвращающие некоторые данные для передачи компоненту.</p>

<p>Например, так можно извлечь данные пользователя из состояния:</p>

  ```javascript
  const getUserData = state => state.user.data
  ```

<p>Селекторы имеют два главных преимущества:</p>

<p>1. Селектор может вычислять производные данные, позволяя Redux записывать в хранилище минимально возможное состояние</p>
<p>2. Селектор не выполняет повторных вычислений до тех пор, пока не изменится один из его аргументов</p>

</div>
</details>


<details>
<summary>Что такое операция (action) в Redux?</summary>
<div>
<p>*Actions* - это обычные JavaScript-объекты, содержащие данные приложения, которые отправляются в хранилище. Операции должны иметь свойство `type`, указывающее какой тип операции необходимо выполнить. Операции также могут содержать полезную нагрузку (payload) - данные для обновления состояния.</p>

<p>Вот как может выглядеть операция по добавлению новой задачи в список:</p>

  ```
  // здесь используется константа
  {
    type: ADD_TODO,
    text: 'Добавление задачи в список'
  }
  ```
</div>
</details>

<details>
<summary>Обязательно ли хранить все состояние в Redux? Можно ли использовать внутреннее состояние компонентов?</summary>
<div>
<p>Вы сами принимаете решение, что использовать. В этом заключается работа разработчика - определить, какое состояние требуется  приложению и где должна храниться каждая часть этого состояния. Одни разработчики предпочитают хранить все состояние в Redux, что обеспечивает полную сериализацию и управляемость приложения. Другие предпочитают хранить некритичное состояние UI, такое как "открыт ли выпадающий список" внутри компонента.</p>

<p>Ниже представлены основные правила определения того, какие типы данных следует хранить в Redux:</p>

     1. Нуждаются ли другие части приложения в этих данных?
     2. Требуется ли создавать производные данные на основе оригинальных?
     3. Используются ли эти данные несколькими компонентами?
     4. Существует ли вероятность того, что потребуется восстанавливать прошлое состояние?
     5. Собираетесь ли вы кэшировать данные (для использования версии из кэша вместо повторного запроса)?
</div>
</details>

<details>
<summary>Назовите правила использования хуков?</summary>
<div>
<p>При использовании хуков необходимо соблюдать два правила:</p>

<p>1. Хуки не должны вызываться внутри циклов, условий или вложенных функций. Это позволяет обеспечить одинаковый порядок вызова хуков при повторном рендеринге и сохранять состояние хуков между несколькими вызовами `useState()` и `useEffect()`</p>
<p>2. Хуки можно вызывать только внутри функциональных компонентов React и других хуков, вы не должны вызывать их внутри обычных функций</p>

</div>
</details>


<details>
<summary>Как обеспечить соблюдение правил использования хуков?</summary>
<div>
<p>Команда React разработала специальный ESLint-плагин, который следит за соблюдением правил использования хуков. Вы можете добавить этот плагин в существующий проект, выполнив команду **eslint-plugin-react-hooks**:</p>

  ```javascript
  yarn add eslint-plugin-react-hooks@next
  // или
  npm i eslint-plugin-react-hooks@next
  ```

<p>И добавив в настройки ESLint следующее:</p>

  ```javascript
  // настройки линтера
  {
    "plugins": [
      // ...
      "react-hooks"
    ],
    "rules": {
      // ...
      "react-hooks/rules-of-hooks": "error"
    }
  }
  ```

<p>**Обратите внимание:** данный плагин применяется по умолчанию при использовании Create React App для создания проекта.</p>

</div>
</details>


<details>
<summary>В чем разница между настоящим и виртуальным DOM?</summary>
<div>
Ниже представлены основные отличие между реальным и виртуальным DOM:

| Реальный DOM | Виртуальный DOM |
| ----- | ------- |
| Обновления медленные | Обновления быстрые |
| Манипуляции с DOM очень дорогостоящие | Манипуляции с DOM не очень дорогие |
| Вы можете обновлять HTML напрямую | Вы не можете обновлять HTML напрямую |
| Активная работа с DOM часто приводит к утечкам памяти | Утечки памяти практически полностью исключены |
| При обновлении элемента создается новая DOM | При изменении элемента обновляется только JSX |
</div>
</details>


<details>
<summary>Что такое SOLID?</summary>
<div>
</div>
</details>


<details>
<summary>Что такое SOLID?</summary>
<div>
</div>
</details>


<br/>

**Веб - технологии**:

<details>
  <summary>Что такое HTTP?</summary>
  <div>
    <p>
      Протокол передачи гипертекста (Hypertext Transfer Protocol - HTTP) - это прикладной протокол для передачи гипертекстовых документов, таких как HTML. Он создан для связи между веб-браузерами и веб-серверами, хотя в принципе HTTP может использоваться и для других целей. Протокол следует классической клиент-серверной модели, когда клиент открывает соединение для создания запроса, а затем ждет ответа. HTTP - это протокол без сохранения состояния, то есть сервер не сохраняет никаких данных (состояние) между двумя парами "запрос-ответ". Несмотря на то, что HTTP основан на TCP/IP, он также может использовать любой другой протокол транспортного уровня с гарантированной доставкой.
    </p>
    <p>
      Ниже перечислены общие функции, управляемые с HTTP:
    </p>
    <ul>
      <li>
        <b>Кэш.</b> Сервер может инструктировать прокси и клиенты: что и как долго кэшировать. Клиент может инструктировать прокси промежуточных кэшей игнорировать хранимые документы.
      </li>
      <li>
        <b>Ослабление ограничений источника.</b> Для предотвращения шпионских и других, нарушающих приватность, вторжений, веб-браузер обчеспечивает строгое разделеление между веб-сайтами. Только страницы из того же источника могут получить доступ к информации на веб-странице. Хотя такие ограничение нагружают сервер, заголовки HTTP могут ослабить строгое разделение на стороне сервера, позволяя документу стать частью информации с различных доменов (по причинам безопасности).
      </li>
      <li>
        <b>Аутентификация.</b> Некоторые страницы доступны только специальным пользователям. Базовая аутентификация может предоставляться через HTTP, либо через использование заголовка WWW-Authenticate и подобных ему, либо с помощью настройки спецсессии, используя куки.
      </li>
      <li>
        <b>Прокси и тунелирование.</b> Серверы и/или клиенты часто располагаются в интранете, и скрывают свои истинные IP-адреса от других. HTTP запросы идут через прокси для пересечения этого сетевого барьера. Не все прокси -- HTTP прокси. SOCKS-протокол, например, оперирует на более низком уровне. Другие, как, например, ftp, могут быть обработаны этими прокси.
      </li>
      <li>
        <b>Сессии.</b> Использование HTTP кук позволяет связать запрос с состоянием на сервере. Это создает сессию,  хотя ядро HTTP -- протокол без состояния.  Это полезно не только для корзин в интернет-магазинах, но также для любых сайтов, позволяющих пользователю настроить выход.
      </li>
    </ul>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/Overview">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>Из чего состоит HTTP-запрос?</summary>
  <div>
    <img src='https://mdn.mozillademos.org/files/13687/HTTP_Request.png' />
    <p>
      Запросы содержат следующие элементы:
    </p>
    <ul>
      <li>
        HTTP-метод, обычно глагол подобно GET, POST или существительное, как OPTIONS или HEAD, определяющее операцию, которую клиент хочет выполнить. Обычно, клиент хочет получить ресурс (используя GET) или передать значения HTML-формы (используя POST), хотя другие операция могут быть необходимы в других случаях.
      </li>
      <li>
        Путь к ресурсу: URL ресурсы лишены элементов, которые очевидны из контекста, например без protocol (http://), domain (здесь developer.mozilla.org), или TCP port (здесь 80).
      </li>
      <li>
        Версию HTTP-протокола.
      </li>
      <li>
        Заголовки  (опционально), предоставляюшие дополнительную информацию для сервера.
      </li>
      <li>
        Или тело, для некоторых методов, таких как POST, которое содержит отправленный ресурс.
      </li>
    </ul>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/Overview">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>Какие методы может иметь HTTP-запрос?</summary>
  <div>
    <p>
      HTTP определяет множество методов запроса, которые указывают, какое желаемое действие выполнится для данного ресурса. Несмотря на то, что их названия могут быть существительными, эти методы запроса иногда называются HTTP глаголами. Каждый реализует свою семантику, но каждая группа команд разделяет общие свойства: так, методы могут быть безопасными, идемпотентными или кэшируемыми.
    </p>
    <ul>
      <li>
        <b>GET</b> запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.
      </li>
      <li>
        <b>HEAD</b> запрашивает ресурс так же, как и метод GET, но без тела ответа.
      </li>
      <li>
        <b>POST</b> используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.
      </li>
      <li>
        <b>PUT</b> заменяет все текущие представления ресурса данными запроса.
      </li>
      <li>
        <b>DELETE</b> удаляет указанный ресурс.
      </li>
      <li>
        <b>CONNECT</b> устанавливает "туннель" к серверу, определённому по ресурсу.
      </li>
      <li>
        <b>OPTIONS</b> используется для описания параметров соединения с ресурсом.
      </li>
      <li>
        <b>TRACE</b> выполняет вызов возвращаемого тестового сообщения с ресурса.
      </li>
      <li>
        <b>PATCH</b> используется для частичного изменения ресурса.
      </li>
    </ul>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>Что такое Cross-Origin Resource Sharing (CORS)?</summary>
  <div>
    <p>
      Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.
    </p>
    <p>
      В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки.
    </p>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/CORS">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>Что такое HTTP cookie и для чего их используют?</summary>
  <div>
    <p>
      HTTP cookie (web cookie, cookie браузера) - это небольшой фрагмент данных, отправляемый сервером на браузер пользователя, который тот может сохранить и отсылать обратно с новым запросом к данному серверу. Это, в частности, позволяет узнать, с одного ли браузера пришли оба запроса (например, для аутентификации пользователя). Они запоминают информацию о состоянии для протокола HTTP, который сам по себе этого делать не умеет.
    </p>
    <p>
      Cookie используются, главным образом, для:
    </p>
    <ul>
      <li>
        Управления сеансом (логины, корзины для виртуальных покупок)
      </li>
      <li>
        Персонализации (пользовательские предпочтения)
      </li>
      <li>
        Мониторинга (отслеживания поведения пользователя)
      </li>
    </ul>
    <p>
      Получив HTTP-запрос, вместе с откликом сервер может отправить заголовок  Set-Cookie с ответом. Cookie обычно запоминаются браузером и посылаются в значении заголовка HTTP  Cookie с каждым новым запросом к одному и тому же серверу. Можно задать срок действия cookie, а также срок его жизни, после которого cookie не будет отправляться. Также можно указать  ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту  оно отсылается.
    </p>
    <p>
      Куки можно создавать через JavaScript при помощи свойства Document.cookie. Если флаг HttpOnly не установлен, то и доступ к существующим cookies можно получить через JavaScript.
    </p>

      document.cookie = "yummy_cookie=choco"; 
      document.cookie = "tasty_cookie=strawberry";
   <p><i>Источник: <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%9A%D1%83%D0%BA%D0%B8">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>Какие существуют основные принципы ООП?</summary>
  <div>
    <br/>
    <p>
      Базовые принципы ООП:
    </p>
    <ul>
      <li>
        Абстракция — отделение концепции от ее экземпляра;
      </li>
      <li>
        Полиморфизм — реализация задач одной и той же идеи разными способами;
      </li>
      <li>
        Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
      </li>
      <li>
        Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.
      </li>
    </ul>
    <p>
     <i>
       Источник: <a href="https://tproger.ru/translations/oop-principles-cheatsheet/">tproger.ru</a>
     </i>
    </p>
  </div>
</details>

<details>
  <summary>Что такое SOLID (объектно-ориентированное программирование)?</summary>
  <div>
    <br/>
    <p>
      SOLID (сокр. от англ. single responsibility, open-closed, Liskov substitution, interface segregation и dependency inversion) в программировании — мнемонический акроним, введённый Майклом Фэзерсом (Michael Feathers) для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов объектно-ориентированного программирования и проектирования. Принципы SOLID — это руководства, которые также могут применяться во время работы над существующим программным обеспечением для его улучшения - например для удаления «дурно пахнущего кода».
    </p>
    <p>
      Избавиться от "признаков плохого проекта" помогают следующие пять принципов SOLID:
    </p>
    <ul>
      <li>
        <b>S</b> - Принцип единственной ответственности (The Single Responsibility Principle) каждый класс выполняет лишь одну задачу.
      </li>
      <li>
        <b>O</b> - Принцип открытости/закрытости (The Open Closed Principle) «программные сущности должны быть открыты для расширения, но закрыты для модификации.»
      </li>
      <li>
        <b>L</b> - Принцип подстановки Барбары Лисков (The Liskov Substitution Principle) «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.» См. также контрактное программирование. Наследующий класс должен дополнять, а не изменять базовый.
      </li>
      <li>
        <b>I</b> - Принцип разделения интерфейса (The Interface Segregation Principle) «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
      </li>
      <li>
        <b>D</b> - Принцип инверсии зависимостей (The Dependency Inversion Principle) «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»
      </li>
    </ul>
    <p>
     <i>
       Источник: <a href="https://ru.wikipedia.org/wiki/SOLID_%28%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%29">wikipedia.org</a>
     </i>
    </p>
  </div>
</details>
  
<details>
  <summary>Что такое Babel и для чего он используется?</summary>
  <div>
    <br/>
    <p>
      Babel.JS – это транспайлер, переписывающий код на ES-2015 в код на предыдущем стандарте ES5.
    </p>
    <p>
      Обычно Babel.JS работает на сервере в составе системы сборки JS-кода (например webpack или brunch) и автоматически переписывает весь код в ES5.
    </p>
    <p>
      Настройка такой конвертации тривиальна, единственно – нужно поднять саму систему сборки, а добавить к ней Babel легко, плагины есть к любой из них.
    </p>
    <p>
      Конфигурация Babel прописывается в файле babel.config.js, либо в .babelrc для настроек одного пакета, а также в package.json или .babelrc.js
    </p>
    <p>
    Пример конфига в babel.config.js:
      
      module.exports = function (api) {
        api.cache(true);

        const presets = [ ... ];
        const plugins = [ ... ];

        return {
          presets,
          plugins
        };
      }
   </p>
    <p>
     <i>
       Источник: 
        <a href="https://learn.javascript.ru/es-modern-usage#babel-js">learn.javascript.ru</a>, 
        <a href="https://babeljs.io/docs/en/next/configuration">babeljs.io</a>
     </i>
    </p>
  </div>
</details>

<details>
  <summary>Для чего используется WebSocket? В чем принцип его работы?</summary>
  <div>
    <br/>
    <p>
      Протокол WebSocket («веб-сокет»), описанный в спецификации RFC 6455, обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.
    </p>
    <p>
      Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:
      <code>
        let socket = new WebSocket("ws://javascript.info");
      </code>
    </p>
    <p>
      Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
    </p>
    <ul>
      <li>
        <b>open</b> – соединение установлено,
      </li>
      <li>
        <b>message</b> – получены данные,
      </li>
      <li>
        <b>error</b> – ошибка,
      </li>
      <li>
        <b>close</b> – соединение закрыто.
      </li>
    </ul>
    <p>
      Вот пример:
    </p>
    <p>
      
      let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");
      
      socket.onopen = function(e) {
        alert("[open] Соединение установлено");
        alert("Отправляем данные на сервер");
        socket.send("Меня зовут Джон");
      };
      
      socket.onmessage = function(event) {
        alert(`[message] Данные получены с сервера: ${event.data}`);
      };
      
      socket.onclose = function(event) {
        if (event.wasClean) {
          alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
        } else {
          // например, сервер убил процесс или сеть недоступна
          // обычно в этом случае event.code 1006
          alert('[close] Соединение прервано');
        }
      };
      
      socket.onerror = function(error) {
        alert(`[error] ${error.message}`);
      };
   </p>
    <p>
      Вызов socket.send(body) принимает body в виде строки или любом бинарном формате включая Blob, ArrayBuffer и другие. Дополнительных настроек не требуется, просто отправляем в любом формате. При получении данных, текст всегда поступает в виде строки. А для бинарных данных мы можем выбрать один из двух форматов: Blob или ArrayBuffer.
    </p>
    <p>
     <i>
       Источник: <a href="https://learn.javascript.ru/websocket">javascript.ru</a>
     </i>
    </p>
  </div>
</details>

<details>
  <summary>Что такое Веб-компоненты и какие технологии в них используются?</summary>
  <div>
    <br/>
    <p>
      Веб-компоненты — технология, которая позволяет создавать многократно используемые компоненты в веб-документах и веб-приложениях. Веб-компоненты поддерживаются веб-браузерами напрямую и не требуют дополнительных библиотек для работы.
    </p>
    <p>
      Веб-компоненты включают четыре технологии, каждая из которых может использоваться отдельно от других:
    </p>
    <ul>
      <li>
        Custom Elements — API для создания собственных HTML элементов.
      </li>
      <li>
        HTML Templates — тег <template> позволяет реализовывать изолированные DOM-элементы.
      </li>
      <li>
        Shadow DOM — изолирует DOM и стили в разных элементах.
      </li>
      <li>
        HTML Imports — импорт HTML документов.
      </li>
    </ul>
    <p>
     <i>
       Источник: 
        <a href="https://ru.wikipedia.org/wiki/%D0%92%D0%B5%D0%B1-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B">wikipedia.org</a>
     </i>
    </p>
  </div>
</details>
