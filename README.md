## Вопросы на собеседовании фронтенд разработчика React.js

Здесь собраны самые популярные вопросы, задаваемые на русскоязычных собеседованиях front-end разработчиков на React.js.  Тематика вопросов включает в себя как основы JavaScript и веб-технологий так и глубокое понимание работы React.js и смежных технологий (Redux, MobX и прочего).Красным цветом обозначены узлы, которые были обновлены. Эти узлы представляют элементы UI, состояние которых изменилось. После этого вычисляется разница между предыдущей и текущей версиями виртуального DOM-дерева. Затем все родительское поддерево подвергается повторному рендерингу для представления обновленного UI. Наконец, это обновленное дерево используется для обновления RDOM.



**CSS**:

<details>
<summary>1. Зачем за ранее указывать размер картинок?</summary>
<div>
  <li> Потому что при загрузке страницы, по мере загрузки картинок, изображение начнет прыгать. </li>  
</div>  
</details>  
  
<details>
<summary>2. Что такое блочная модель, и как, с помощью CSS, менять расположение блоков на странице в браузере?</summary>
<div>
  <li>Блочная модель — модель, при которой каждый элемент представляет собой прямоугольный блок и имеет ширину, высоту, поля, границы и отступы. Менять расположение элементов можно с помощью позиционирования (position), отступов (margin) и трансформирования (transform).</li>  
  <img src="https://vaden-pro.ru/sites/default/files/box-model1.jpg"/>
* </div>  
</details> 

<details>
<summary>3. Что вы можете рассказать о медиа-запросах?</summary>
<div>
  <li> Медиавыражения используются в тех случаях , когда нужно применить разные CSS-стили, для разных устройств по типу отображения (например: для принтера, монитора или смартфона), а также для устройств с определенными характеристиками: ширина (width), высота (height), соотношение ширины к высоте области просмотра (aspect-ratio), ориентация (orientation), разрешение (resolution), количество бит на каждый из цветовых компонентов устройства (color) и другие. </li>  
</div>  
</details>  
  
<details>
<summary>4. Что такое препроцессор и зачем он нужен?</summary>
<div>
  <p>CSS препроцессор (от англ. CSS preprocessor) — это надстройка над CSS, которая добавляет ранее недоступные возможности для CSS, с помощью новых синтаксических конструкций.</p>

  <p>Основная задача препроцессора — это предоставление удобных синтаксических конструкций для разработчика, чтобы упростить, и тем самым, ускорить разработку и поддержу стилей в проектах.</p>

  <p>CSS препроцессоры преобразуют код, написанный с использованием препроцессорного языка, в чистый и валидный CSS-код.</p>
</div>  
</details>  

<details>
<summary>5. Что такое Mixins, переменные и вложенность в препроцессорах?</summary>
<h2>Mixins</h2>
<div>
  Миксины – это шаблоны с готовым CSS-кодом, легко подставляемые к любому из элементов сайта или приложения. Достаточно вписать их название в блок оформления селектора. Миксины отчасти похожи на функции, так как умеют принимать аргументы при использовании. 
</div>  

    @flex ($justify, $align) {
      display: flex;
      justify-content: $justify;
      align-items: $align;
      flex-flow: column;
    }

    div {
      .flex(center, stretch);
    }
<div>
<h2>Переменные</h2>

<p>Да, они есть и в «чистом» CSS, но реализованы менее удобно. </p>

    @colorForButton: #76AB04
    button {
      background: @colorForButton;
    }

<h2>Вложенность</h2>

<p>Благодаря препроцессорам не нужно каждую строку прописывать отдельно. В них действуют элементарные правила вложенности, как и в структуре HTML. </p>

    div {
      dispaly: flex;
      anotherDiv {
        margin: 20px 0px;
      }
      @media (max-width: 720px) {
        position: absolute;
      }
    }

</div>
</details>



<details>
<summary>6. Расскажите про блочные и строчные элементы?</summary>
<div>
<h2>Блочные</h2>
<p> Такой элемент представляет собой прямоугольник, который по умолчанию занимает всю доступную ширину страницы (если иное значение не указано в CSS), а длина элемента зависит от его содержимого. Такой элемент всегда начинается с новой строки, то есть, располагается под предыдущим элементом. Блочный элемент может содержать в себе другие блочные и строчные элементы.

Примеры блочных элементов: ```<div>, <p>, <ul>, <ol>, <h1> ```и т. д.</p>

<h2>Строчные</h2>
<p>В отличие от блочного, строчный элемент не переносится на новую строку, а располагается на той же строке, что и предыдущий элемент. Такие элементы, как правило, находятся внутри блочных элементов и их ширина зависит лишь от содержимого и настроек CSS. Еще одно отличие строчного элемента от блочного заключается к том, что в нем может находиться только контент и другие строчные элементы. Блочные элементы в строчные вкладывать нельзя.

Примеры строчных элементов: ```<a>, <span>, <strong>, <em>, <img>``` и т. д.</p>

<img src="https://idg.net.ua/blog/wp-content/uploads/block-and-inline.png"/>
</div>
</details>



<details>
<summary>7. Какие бывают значения display? Расскажите как ведёт себя каждое свойство?</summary>
<div>

```CSS
  display: block | inline | inline-block | inline-table |
  inline-flex | flex | list-item | none |
  run-in | table | table-caption | table-cell | table-column-group 
  | table-column |
  table-footer-group | table-header-group | table-row | table-row-group
```

<H2>block</H2>

Элемент показывается как блочный. Применение этого значения для строчных элементов, например span, заставляет его вести подобно блокам — происходит перенос строк в начале и в конце содержимого.

<H2>inline</H2>

Элемент отображается как строчный. Использование блочных элементов, таких, как div и p, автоматически создаёт перенос и показывает их содержимое с новой строки. Значение inline отменяет эту особенность, поэтому содержимое блочных элементов начинается с того места, где окончился предыдущий элемент.

<H2>inline-block</H2>

Это значение генерирует блочный элемент, который обтекается другими элементами веб-страницы подобно строчному элементу. Фактически такой элемент по своему действию похож на встраиваемые элементы (вроде img). При этом его внутренняя часть форматируется как блочный элемент, а сам элемент — как строчный.

<H2>inline-table</H2>

Определяет, что элемент является таблицей, как при использовании table, но при этом таблица является строчным элементом и происходит её обтекание другими элементами, например, текстом.

<H2>inline-flex</H2>

Элемент ведёт себя как строчный и выкладывает содержимое согласно флекс-модели.

<H2>flex</H2>

Элемент ведёт себя как блочный и выкладывает содержимое согласно флекс-модели.

<H2>list-item</H2>

Приведёт к тому, что элемент будет вести себя как элемент списка.
</div>  
</details>  

<details>
<summary>8. Какие бывают значения у свойства position? Расскажите как ведёт себя каждое свойство?</summary>
<div>
  
```CSS
  position: absolute | fixed | relative | static | sticky
```  

<img src="https://chenhuijing.com/assets/images/posts/css-positioning.jpg" />

<h1>Нормальный поток</h1>
<H2>relative</H2>

Относительное позиционирование. Cмещает элемент относительно того места, где он должен находится в нормальном потоке. (top - смещение сверху на указанные единицы , right смещает относительно правой стороны "статичного" положения и тд и тп). Элемент остается в потоке.

<H2>static</H2>

Статичное позиционирование. Элементы отображаются как обычно. Использование свойств left, top, right и bottom не приводит к каким-либо результатам. Элемент остается в потоке.

<h1>Поток с абсолютным позиционированием</h1>

<H2>absolute</H2>

Абсолютное позиционирование. Элемент удаляется из потока и позиционируется относительно ближайшего позиционированного предка (т.е. любого не статичного).Другие элементы отображаются на веб-странице словно абсолютно позиционированного элемента и нет. 

Блочные элементы при АП начинают напоминать строчные. Они перестают занимать всю ширину, потому что больше не находятся в потоке.  Занимают ширину только своего контента и отступов (внутренних  и внешних). 

Если указать left и right одновременно = 0. То блок растянется на всю рабочую ширину браузера. Так как должен находиться и в левой и в правой крайней точке.

<H2>fixed</H2>

Фиксированное позиционирование. По своему действию это значение близко к absolute, но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы. Отличительной чертой фиксированного позиционирования является то, что элемент позиционируется относительно ТОЛЬКО (не дрегого позиционированного элемента) видимой области браузера.


<H2>sticky</H2>

Это сочетание относительного и фиксированного позиционирования. Элемент рассматривается как позиционированный относительно , пока он не пересекает определённый порог, после чего рассматривается как фиксированный.

Состоит из двух основных частей: «липкого» элемента и «липкого» контейнера.
«Липкий» элемент — это элемент, которому мы задали position: sticky. Элемент будет становиться плавающим, как только область видимости достигнет определённой позиции, например top: 0px.

Пример:
.some-component {
  position: sticky;
  top: 0px;
}

«Липкий» контейнер — это HTML-элемент, который оборачивает «липкий» элемент. Это максимальная область, в которой может перемещаться наш элемент.

<h2>Тонкости:</h2>

  Не залипает если является единственным ребенком своего родителя.
  Без хотя бы top:0px; не залипает.
</div>  
</details> 


<details>
<summary>9. Расскажите про float?</summary>
<div>
<p>Плавающий элемент (float : right; или float: left;)
вынимается из потока и “прижимается” (“притягивается”, “плывёт”) к левой или правой стороне содержащего блока. Поток всё также идет от самого верха родительского элемента-контейнера, но ширина потока уменьшается на ширину плавающего элемента.
После “плавающего” элемента поток опять займёт всю доступную ширину.</p>
<br />
  
<p>Если в блоке-контейнере нет элементов кроме плавающих (как в первом примере из предыдущего урока) его высота равна нулю, контейнер ведет себя как пустой, потому что плавающие элементы удалены из потока. </p>
<br />

</div>  
</details>  
  
<details>
<summary>10. Какие существуют методы очистки floats и какие из них подходят для какого контекста ?</summary>
<div>
<img src="https://miro.medium.com/max/1400/1*ZCnZj_89gK7qs_FnQ9qzlQ.png" />

<br /> 
  
  left, right, both
  
<h2>Есть несколько основных способов, как реализуется clear:</h2>

<p>Использование правила clear: both для элемента, который необходимо «очистить».</p>

<p>Создание пустого блочного элемента. У него впоследствии указывается правило clear: both.</p>


<p>Свойство overflow со значением hidden. Само по себе свойство overflow управляет отображением содержимого блока (добавляет полосы прокрутки, обрезает не поместившийся контент), в добавок, значения auto, scroll или hidden отменяют свойство float. В данном случае текс уменьшится на ширину флоата по всей длинне.</p>

</div>  
</details> 

<details>
<summary>11. Расскажите о различия padding и margin?</summary>

<img src="https://webcodius.ru/wp-content/uploads/2014/11/otstup.png" />
<div>
<H2>margin</H2>

  Это расстояние между границей текущего элемента веб-страницы и границами соседних элементов, либо родительского элемента. Размер расстояния регулируется свойством margin. Такой отступ находится вне элемента.

<H2>padding</H2>

  Это расстояние от воображаемой границы элемента до его содержимого. Величина расстояния задается с помощью параметра padding. Такой отступ принадлежит самому элементу и находится внутри него.
</div>  
</details>  
  


<details>
<summary>12. Как ведут себя margin у двух элементов по соседству?</summary>
<div>
У блочных элементов расположенных рядом друг с другом по вертикали наблюдается эффект схлопывания, когда отступы не суммируются, а объединяются между собой. Само схлопывание действует на два и более блока (один может быть вложен внутрь другого) с отступами сверху или снизу, при этом примыкающие отступы комбинируются в один. Для отступов слева и справа схлопывание никогда не применяется.

<p>Схлопывание не срабатывает:</p>

<p>для элементов, у которых на стороне схлопывания задано свойство padding.</p>
<p>для элементов, у которых на стороне схлопывания задана граница; на элементах с абсолютным позиционированием, т. е. таких, у которых position установлено как absolute;</p>
<p>на плавающих элементах (для них свойство float задано как left или right);</p>
<p>для строчных элементов;</p>
<p>для html.</p>

</div>  
</details>  
  


<details>
<summary>13. Какие вы знаете псевдоэлементы? Где их используют??</summary>
<div>
<br/>
<p>Псевдоэлемент — это дополнение к селектору, с помощью которого можно стилизовать элемент, не определённый в структуре HTML документа. Добавляется он к селектору c помощью символов ::, т.е. так селектор::псевдоэлемент
</p>
<h1>Самые «ходовые»:</h1>

<h2>:after</h2>
<h2>:before</h2>

  Предназначены для создания псевдоэлемента внутри элемента перед/после его контента. По умолчанию данный псевдоэлемент имеет display: inline. Если псевдоэлементу before нужно установить другое отображение, то его нужно указать явно (например: display: block).

  Содержимое данного псевдоэлемента задаётся с помощью CSS свойства content. При этом если псевдоэлемент будет без содержимого, то данное свойство всё равно необходимо указывать и использовать в качестве его значения пустую строку content: "". Без указания content псевдоэлемент отображаться не будет.

  Псевдоэлемент before не наследует стили. Поэтому если необходимо чтобы у него были стили как у родительского элемента, то ему необходимо их явно прописывать.
  <br/>

<h2>:placeholder</h2>

  Псевдоэлемент, с помощью которого задаётся стилевое оформление подсказывающего текста, созданного атрибутом

<h2>:selection</h2>

  Применяет стиль к выделенному пользователем тексту. В правилах стилей допускается использовать следующие свойства: color, background и background-color.

</div>  
</details>  
  


<details>
<summary>14. Что такое БЭМ?</summary>

  .block__element_mod
<div>
  БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая «Copy-Paste».
</div>  
<p>
  Блок — это независимый интерфейсный компонент. Блок может быть простым или составным (содержать другие блоки). При создании блока нужно обеспечивать возможность его использования в любом месте web-страницы, а также повторения в том же самом месте страницы (родительском элементе). Блок должен включать в себя всю реализацию, необходимую для представления части интерфейса, которую он выражает.
</p>
<p>
  Элемент — это составная часть блока. Элементы контекстно-зависимы: они имеют смысл только в рамках своего блока. Элемент — не обязательная составляющая блока, небольшие блоки обходятся без элементов.
</p>
<p>
  Модификатор — это свойство блока или элемента, задающее изменения в их внешнем виде или поведении. Модификатор может быть булевым (например, button_big) или парой ключ-значение (например, menu_type_bullet, menu_type_numbers). У блока или элемента может быть несколько модификаторов одновременно.
</p>

<h2>Правила формирования имен</h2>
block-name__elem-name_mod-name_mod-val

Имена записываются латиницей в нижнем регистре.

Для разделения слов в именах используется дефис (-).

Имя блока задает пространство имен для его элементов и модификаторов.

Имя элемента отделяется от имени блока двумя подчеркиваниями (__).

Имя модификатора отделяется от имени блока или элемента одним подчеркиванием (_).

Значение модификатора отделяется от имени модификатора одним подчеркиванием (_).

Значение булевых модификаторов в имени не указывается.


</p>
</details>  
  
<br/> 
  
**JavaScript**:

<details>
<summary>1. Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования?</summary>
<div>

  <h2>Парадигма программирования.</h2>
  <p>Парадигма программирования это подход к конструированию программного обеспечения, основанный на нескольких определяющих принципах. Функциональное программирование это одна из таких парадигм, которая состоит из чистых функций (Pure Function), и позволяет избежать разделяемого состояния (Shared State), изменчивых данных (Mutable Data) и побочных эффектов (Side effect). Функциональное программирование является больше декларативным, чем императивным. Cостояние приложения в функциональном программировании, в отличие от объектно-ориентированного программирования, протекает через чистые функции.

  Код в функциональном программировании имеет тенденцию быть более кратким, более предсказуемым и более простым для     тестирования, чем императивный код, но он может быть сложным для обучения.</p>

  <h2>Чистые функции (Pure functions)</h2>
  <p>Первое фундаментальное понятие это чистые функции. Чистые функции задействованы в надежном параллелизме (concurrency), React/Redux приложениях и функциональном программировании. Рассмотрим, что делает функцию «чистой»:

  <ul>
    <li>чистая функция всегда возвращает одинаковое значение при одинаковых входах;</li>
    <li>чистая функция не имеет побочных эффектов.</li>
  </ul>
  
  
  Чистые функции полностью независимы от внешнего состояния и, следовательно, невосприимчивы ко многим ошибкам, связанным с разделяемым и изменчивым состоянием. Благодаря этому, чистые функции чрезвычайно легко перемещать. С ними легко делать рефакторинг и реорганизацию кода, что адаптирует программы к будущим изменениям.
  </p>



  <h2>Композиция (Function composition)</h2>
  <p>Композиция функций — это способ объединения чистых функций для создания более сложных. Подобно обычной композиции функций в математике, результат одной функции передается в качестве аргумента следующей, а результат последней является результатом целого.</p>
  
  <h2>Каррированная функция (Curried functions)</h2>
  <p>Каррированные функции — это функции, которые принимают несколько параметров, только по одному за раз (имеют целую армию из одного параметра). Их можно создать в JavaScript с помощью функций высокого порядка.</p>


  <h2>Предотвращение разделяемого состояния(Preventing Shared State)</h2>
  <p>Разделяемое состояние это любая переменная, объект или пространство памяти, которые существуют в общей области (shared scope), или свойство объекта, передаваемое между областями. Проблема с разделяемым состоянием состоит в том, что нужно знать всю историю каждой общей переменной, которую функция использует или затрагивает, чтобы понять результат вызова функции. Вторая проблема, связанная с общим состоянием, заключается в том, что изменение порядка вызова функций может вызвать ряд сбоев.

  Функциональное программирование избегает разделяемое состояние, используя структуры неизменных данных и чистые вычисления для получения новых данных из уже существующих.
  </p>

  <h2>Неизменность(Immutable)</h2>
  <p>Неизменный объект (immutable object) это объект, который нельзя изменить после его создания. Если вы хотите изменить неизменяемый объект, лучше всего создать новый объект с новым значением. Неизменность это ключевое понятие функционального программирования. Без него теряется история состояний, и ошибки могут проникнуть в вашем программное обеспечение.</p>

  <h2>Побочные эффекты(Side-effects)</h2>
  <p>Побочный эффект (Side Effect) это любое изменение состояния приложения, которое наблюдается за пределами вызываемой функции, кроме ее возвращаемого значения. Примеры побочных эффектов:

  <ul>
    <li>изменение любой внешней переменной или свойства объекта;</li>
    <li>вход в консоль;</li>
    <li>запись в файл.</li>
  </ul>

  Функциональное программирование позволяет избежать побочных эффектов, что облегчает расширение, рефакторинг, отладку, тестирование и обслуживание программы.</p>


  <p>Функциональное программирование предпочитает чистые функции вместо разделяемого состояния и побочных эффектов, неизменность вместо изменяемых данных и композицию функций вместо обязательного управления потоком. Функциональное программирование часто легче понять, потому что оно не меняет состояние и зависит только от предусмотренного ввода.</p>

  Объект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования.

</div>
</details>

<details>
<summary>2. Hoisting?</summary>
<div>
  Hoisting - не существует на самом деле. Это выдуманная концепция. Это метафора для описания того, что на самом деле происходит, когда компилятор находит объявления переменных и связывает их с областью действия, к которой они принадлежат, чтобы их можно было использовать в этой области.

  Это механизм перемещения объявления переменных и функций в верхнюю часть области видимости функции (или глобальной области видимости, если она находится вне какой-либо функции).
</div>  
  <p>Hoisting влияет на жизненный цикл переменной, который состоит из следующих 3 шагов:</p>

  <ul>
    <li>Declaration - создать новую переменную. Например. переменная. myValue</li>
    <li>Initialization - инициализировать переменную значением. myValue = 150</li>
    <li>Usage - получить доступ и использовать значение переменной. alert(myValue)</li>
  </ul>

    // Declare
    var strNumber; 
    // Initialize
    strNumber = '16';
    // Use
    parseInt(strNumber); // => 16

  <p>JavaScript не следует строго этой последовательности и предлагает большую гибкость. Например, перед объявлением можно использовать функции: use -> declare.</p>

  <p>Это происходит потому, что объявление функции в JavaScript поднимается наверх области видимости.

Hoisting действует по-разному:

<ul>
  <li>объявления переменных: использование ключевых слов var, let или const</li>
  <li>объявления функций: использование синтаксиса function name () {...}</li>
  <li>объявления класса: использование ключевого слова класса</li>
</ul>
</p>

<p>Разница между объявлениями var / function и объявлениями let / const / class заключается в инициализации. Первые инициализируются с неопределенным значением undefined. Однако, вторые, лексически объявленные переменные, остаются не инициализированными. Это означает, что ReferenceError выбрасывается при попытке доступа к ним. Они будут инициализированы только после того, как операторы let / const / class будут определены. Всё что до, называется временной мертвой зоной.</p>

<p>Временная мертвая зона - это не синтаксическое местоположение, а время между созданием переменной(DECLARE) и инициализацией. Ссылка на переменную в коде над объявлением не является ошибкой, если этот код не выполняется (например, тело функции или просто мертвый код), но ошибка будет выдана, если мы запросим доступ к переменной до её инициализации.</p>

<p>
  <b>Var:</b>
  <br/>
  Переменные, объявленные с помощью var, поднимаются в верхнюю часть области действия  функции. Если к переменной обращаются до объявления, она оценивается как undefined.
  Когда переменная поднимается, объявление перемещается вверх, но начальное присвоение значения остается на месте:

    // Declare num variable
    var num;
    console.log(num); // => undefined
    // Declare and initialize str variable
    var str = 'Hello World!';
    console.log(str); // => 'Hello World!'

  С объявлениями var невозможно отличить объявленную переменную от инициализированной переменной, потому что объявления var автоматически инициализируются в начале области видимости, поэтому они доступны для использования во всей области видимости. Вы не можете наблюдать uninitialized объявление var.
</p> 
<p>Синтаксис var позволяет не только объявлять, но и    сразу  присваивать начальное значение: var str = 'начальное значение'. Когда переменная поднимается, объявление перемещается вверх, но начальное присвоение значения остается на месте:</p>

    function sum(a, b) {
      console.log(myString); // => undefined
      var myString = 'Hello World';
      console.log(myString); // => 'Hello World'
      return a + b;
    }
    sum(16, 10); // => 26

<p>
<b>Let/Const:</b>
<br/>

    function isTruthy(value) {
      var myVariable = 'Value 1';
      if (value) {
        /**
        * temporal dead zone for myVariable
        */
        // Throws ReferenceError: myVariable is not defined
        console.log(myVariable);
        let myVariable = 'Value 2';
        // end of temporary dead zone for myVariable
        console.log(myVariable); // => 'Value 2'
        return true;
      }
      return false;
    }
    isTruthy(1); // => true

  Возникает интересный вопрос: действительно ли myVariable поднята до начала блока, или может быть просто не определена во временной мертвой зоне (до объявления)? Исключение ReferenceError выдается также, когда переменная вообще не определена.

  Если вы посмотрите на начало функционального блока, var myVariable = 'Value 1' объявляет переменную для всей области действия функции. В блоке if (value) {...}, если бы переменные let не покрывали переменные внешней области видимости, то во временной мертвой зоне myVariable имело бы значение 'Value 1', чего не происходит. Таким образом, блочные переменные грубо подняты.

  В точном описании, когда движок встречает блок с оператором let, сначала переменная объявляется в верхней части блока. В объявленном состоянии переменная по-прежнему не может использоваться, но она покрывает переменную из внешней области видимости с тем же именем. Позже, когда передается строка let myVar, переменная находится в инициализированном состоянии и может использоваться.

  расширение let во всем блоке защищает переменные от модификации внешними областями видимости даже до объявления. Генерация ошибок ссылок при доступе к переменным let во временной мертвой зоне обеспечивает лучшую практику кодирования: сначала объявить, а затем использовать.
</p>


<p>
<b>Функция:</b>
<br/>
  Подъем в объявлении функции позволяет использовать функцию в любом месте включающей области видимости, даже до объявления. Другими словами, функция может быть вызвана из любого места текущей или внутренней области видимости (без неопределенных значений, временных мертвых зон или ошибок ссылок).

  Обратите внимание на разницу между объявлением функции function name() {...} и выражением функции var name = function() {...}. Оба используются для создания функций, однако имеют разные механизмы подъема. Следующий пример демонстрирует различие:
</p>

    // Call the hoisted function
    addition(4, 7); // => 11
    // The variable is hoisted, but is undefined
    substraction(10, 7); // TypeError: substraction is not a function
    // Function declaration
    function addition(num1, num2) {
      return num1 + num2;
    }
    // Function expression
    var substraction = function (num1, num2) {
      return num1 - num2;
    };

<p>
<b>Класс:</b>
<br/>
Переменные класса регистрируются в начале области блока. Но если вы попытаетесь получить доступ к классу до определения, JavaScript выдаст ReferenceError: имя не определено. Таким образом, правильный подход заключается в том, чтобы сначала объявить класс, а затем использовать его для создания экземпляров объектов.

Hoisting в объявлениях классов похож на переменные, объявленные с помощью оператора let.
</p>

</details> 


<details>
<summary>3. Что такое область видимости (Scope)?</summary>
  Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).

  Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде.

    // глобальное пространство имен
    var g = 'global'

    function globalFunc() {
        function innerFunc() {
            console.log(g) // имеет доступ к переменной g, поскольку она является глобальной
        }
        innerFunc()
    }

  Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.

    function myFavouriteFunc(a) {
        if (true) {
            var b = 'Hello ' + a
        }
        return b
    }
    myFavouriteFunc('World')

    console.log(a) // Uncaught ReferenceError: a is not defined
    console.log(b) // не выполнится

  Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него. Блок кода не создает область для переменных var, в отличие от тела функции. 

    function testBlock() {
        if (true) {
            let z = 5
        }
        return z
    }

    testBlock() // Uncaught ReferenceError: z is not defined

  Модульная область видимости - ES2015 также создает область видимости для переменных, функций, классов.

    // "circle" module scope
    const pi = 3.14159;
    console.log(pi); // 3.14159
    // Usage of pi

  Переменная pi объявлена ​​в рамках модуля Circle. Также переменная pi не экспортируется из модуля.

  Затем импортируется модуль circle:

    import './circle';
    console.log(pi); // throws ReferenceError


  Лексическая область видимости -состоит из внешних областей видимости, определенных статически.

    function outerFunc() {
      // the outer scope
      let outerVar = 'I am from outside!';
      function innerFunc() {
        // the inner scope
        console.log(outerVar); // 'I am from outside!'
      }
      return innerFunc;
    }
    const inner = outerFunc();
    inner();

  Посмотрите на последнюю строку фрагмента inner(): вызов innerFunc() происходит за пределами области externalFunc(). Тем не менее, как JavaScript понимает, что значение externalVar внутри innerFunc() соответствует переменной externalVar функции externalFunc()?

  Ответ: благодаря лексической области.

  Лексическая область видимости означает, что доступность переменных определяется статически положением переменных во вложенных областях действия функции: внутренняя область действия функции может получить доступ к переменным из области действия внешней функции.

  В примере лексическая область видимости innerFunc() состоит из области видимости externalFunc().

  Кроме того, innerFunc() является замыканием, поскольку захватывает переменную externalVar из лексической области видимости.


  Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain).

    // цепочка областей видимости
    // внутренняя область видимости -> внешняя область видимости -> глобальная область видимости

    // глобальная область видимости
    var variable1 = 'Comrades'
    var variable2 = 'Sayonara'

    function outer() {
        // внешняя область видимости
        var variable1 = 'World'

        function inner() {
            // внутренняя область видимости
            var variable2 = 'Hello'
            console.log(variable2 + ' ' + variable1)
        }
        inner()
    }
    outer()
    // в консоль выводится 'Hello World',
    // потому что variable2 = 'Hello' и variable1 = 'World' являются ближайшими
    // к внутренней области видимости переменными
  <img src="https://habrastorage.org/r/w1560/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png" />
</details> 



<details>
<summary>4. var VS let VS const?</summary>
<div>
  Сперва сравним var и let. Главное отличие let в том, что область видимости переменной ограничивается блоком, а не функцией. Другими словами, переменная, созданная с помощью оператора let, доступна внутри блока, в котором она была создана и в любом вложенном блоке. Говоря «блок», я имею ввиду всё что вложено между фигурными скобками {}, как например в цикле for или условии if.

  Var выходит за пределы блоков if, for и подобных. Это происходит потому, что на заре развития JavaScript блоки кода не имели лексического окружения. Поэтому можно сказать, что var – это пережиток прошлого.  Но var не может выйти за пределы блока функции.

  <h2>«var» допускает повторное объявление</h2>

  Если в блоке кода дважды объявить одну и ту же переменную let, будет ошибка:

    let user;
    let user; // SyntaxError: 'user' has already been declared
    Используя var, можно переобъявлять переменную сколько угодно раз. Повторные var игнорируются:

    var user = "Pete";

    var user; // ничего не делает, переменная объявлена раньше
    // ...нет ошибки

    alert(user); // Pete
    Если дополнительно присвоить значение, то переменная примет новое значение:

    var user = "Pete";

    var user = "John";

    alert(user); // John

  <h2>«var» обрабатываются в начале запуска функции</h2>

  Объявления переменных var обрабатываются в начале выполнения функции (или запуска скрипта, если переменная является глобальной).

  Другими словами, переменные var считаются объявленными с самого начала исполнения функции вне зависимости от того, в каком месте функции реально находятся их объявления (при условии, что они не находятся во вложенной функции).


    function sayHi() {
      phrase = "Привет";

      alert(phrase);

      var phrase;
    }
    sayHi();

  Поскольку все объявления переменных var обрабатываются в начале функции, мы можем ссылаться на них в любом месте. Однако, переменные имеют значение undefined до строки с присвоением значения.

  <h2>Итого</h2>

  Существует 2 основных отличия var от let/const:

  Переменные var не имеют блочной области видимости, они ограничены, как минимум, телом функции.
  Объявления (инициализация) переменных var производится в начале исполнения функции (или скрипта для глобальных переменных).

  Эти особенности, как правило, не очень хорошо влияют на код. Блочная область видимости – это удобно. Поэтому много лет назад let и const были введены в стандарт и сейчас являются основным способом объявления переменных.
</div>
</details>

<details>
<summary>5. Какие типы данных существуют в JavaScript?</summary>
<div>
  <h2>Примитивные типы:</h2>
  <p>Все типы данных в JavaScript, кроме объектов, являются иммутабельными (значения не могут быть модифицированы, а только перезаписаны новым полным значением). Например, в отличии от C, где строку можно посимвольно корректировать, в JavaScript строки пересоздаются только полностью. Значения таких типов называются «примитивными значениями».</p>
  <ul>
    <li>
      <b>«number» - </b> - Единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений). Например, бесконечность Infinity получается при делении на ноль. Ошибка вычислений NaN будет результатом некорректной математической операции. 
      Значения ограничены диапазоном ±(253-1).
    </li>
    <li>
      <b>«bigint» - </b>  это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины.
    </li>
    <li>
      <b>«string»</b> - Строка может содержать ноль или больше символов, нет отдельного символьного типа.
    </li>
    <li>
      <b>«boolean» - </b>Булевый (логический) тип <b>«boolean»</b>
    </li>
    <li>
       <b>«undefined» - </b> Специальное значение  Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.
    </li>
    <li><b>«symbol» - </b> для уникальных идентификаторов. Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа. Варианты использования: 1) «Скрытые» свойства объектов (Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны),  2) Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее. </li>
  </ul>
  <h2>Отдельные типы:</h2>
  <ul>
    <li>
      <b>«object» - </b> Первые 6 типов называют «примитивными». Особняком стоит шестой тип: «объекты». Он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок {...}
    </li>
    <li>
      <b>«null» - </b> Специальное значение В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».  Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в Цепочке Прототипов;
    </li>
  </ul>
  <p>Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной Имеет две формы: typeof x или typeof(x). Возвращает строку с именем типа. Например, "string". Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.</p>
</div>
</details>

<details>
<summary>6. Расскажите про преобразование типов в JavaScript?</summary>

Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.

Строковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает очевидным образом.

Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).

Преобразование подчиняется правилам:

| Значение |	Становится… |
| ---------|--------------|
|undefined	| NaN|
|null |	0|
|true / false |	1 / 0|
|string |	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.

Логическое – Происходит в логических операциях. Может быть вызвано с помощью Boolean(value).|

Подчиняется правилам:

|Значение |	Становится…|
|---------|-----------|
|0, null, undefined, NaN, "" |	false|
|любое другое значение	|true|

Большую часть из этих правил легко понять и запомнить. Особые случаи, в которых часто допускаются ошибки:

undefined при численном преобразовании становится NaN, не 0.

"0" и строки из одних пробелов типа " " при логическом преобразовании всегда true.
</details>

<details>
<summary>7. В чем разница между явным и неявным преобразованием или приведением к типу (Implicit and Explicit Coercion)?</summary>
  
  Неявное преобразование — это способ приведения значения к другому типу без нашего ведома (участия).

  Предположим, у нас есть следующее:

    console.log(1 + '6')
    console.log(false + true)
    console.log(6 * '2')

  Результатом первого console.log будет 16. В других языках это привело бы к ошибке, но в JS 1 конвертируется в строку и конкатенируется (присоединяется) c 6. Мы ничего не делали, преобразование произошло автоматически.

  Результатом второго console.log будет 1. False было преобразовано в 0, true — в 1. 0 + 1 = 1.

  Результатом третьего console.log будет 12. Строка 2 была преобразована в число перед умножением на 6.

  Явное преобразование предполагает наше участие в приведении значения к другому типу:

    console.log(1 + parseInt('6'))

  В этом примере мы используем parseInt для приведения строки 6 к числу, затем складываем два числа и получаем 7.
</details>


<details>
<summary>8. Какие значения в JS являются ложными?</summary>
  
  const falsyValues = ['', 0, null, undefined, NaN, false]

  Ложными являются значения, результатом преобразования которых в логическое значение является false.
  Как проверить, является ли значение ложным?

  Следует использовать функцию Boolean или оператор "!!"    (двойное отрицание).
</details>


<details>
<summary>9. В чем разница между undefined и is not defined?</summary>
undefined - это значение, присваемое объявленной, но не проинициализированной переменной.
Мы получаем undefined, обращаясь к существующей переменной. А в случае обращения к несуществующей (необъявленной) переменной, мы получим ошибку is not defined.
</details>

<details>
<summary>10. Что такое this?</summary>
<p>This это контекст вызова функции. В JavaScript 4 типа вызова функции:

<ul>
  <li>function invocation: alert('Hello World!') (Optional: with strict mode)</li>
  <li>method invocation: console.log('Hello World!')</li>
  <li>constructor invocation: new RegExp('\\d')</li>
  <li>indirect invocation: alert.call(undefined, 'Hello World!')/ .apply</li>
</ul>
<p>Отдельно от них можно отметить: </p>
<ul>
   <li>bound function invocation: multiply.bind(2)</li>
  <li>arrow function invocation: () => {}</li>
</ul>

<h2>function invocation:</h2>

<p>This это глобальная область в function invocation. Глобальный обьект определяется средой исполнения. В браузере глобальный обьект это window.</p>
<img src="https://dmitripavlutin.com/static/7035b35b8d8dce31376d9839065e58f7/19891/2-1.png" />

    function sum(a, b) {
      console.log(this === window); // => true
      this.myNumber = 20; // add 'myNumber' property to global object
      return a + b;
    }
    // sum() is invoked as a function
    // this in sum() is a global object (window)
    sum(15, 16);     // => 31
    window.myNumber; // => 20

<h3>function invocation strict mode:</h3>
<p>This = undefined при вызове функции в строгом режиме</p>

<h3>function invocation распространенные ошибки:</h3>
<p>Обычная ловушка с вызовом функции состоит в том, что вы думаете, что this то же самое во внутренней функции, что и во внешней функции.

Контекст внутренней функции (кроме стрелочной функции) зависит только от ее собственного типа вызова, но не от контекста внешней функции.</p>
Ошибка:

    const numbers = {
      numberA: 5,
      numberB: 10,
      sum: function() {
        console.log(this === numbers); // => true
        function calculate() {
          // this is window or undefined in strict mode
          console.log(this === numbers); // => false
          return this.numberA + this.numberB;
        }
        return calculate();
      }
    };
    numbers.sum(); // => NaN or throws TypeError in strict mode

Корректно:

    const numbers = {
      numberA: 5,
      numberB: 10,
      sum: function() {
        console.log(this === numbers); // => true
        const calculate = () => {
          console.log(this === numbers); // => true
          return this.numberA + this.numberB;
        }
        return calculate();
      }
    };
    numbers.sum(); // => 15



<h2>method invocation:</h2>
<p>This это объект, которому принадлежит метод в вызове метода</p>
<img src="https://dmitripavlutin.com/static/baf7c3a9ba2fa5c631ea32b940d95f95/1c68e/4-1.png" />

<p>В синтаксисе класса ECMAScript 2015 контекст вызова метода также является самим экземпляром</p>

    class Planet {
      constructor(name) {
        this.name = name;
      }
      getName() {
        console.log(this === earth); // => true
        return this.name;
      }
    }
    const earth = new Planet('Earth');
    // method invocation. the context is earth
    earth.getName(); // => 'Earth'

<h3>method invocation распространенные ошибки:</h3>
<p>Разделение метода и обьекта: Метод можно извлечь из объекта в отдельную переменную const alone = myObj.myMethod. Когда метод вызывается только один alone() , отделенный от исходного объекта, вы можете подумать, что this объект myObject, для которого был определен метод.</p>
<p>Правильно сказать, если метод вызывается без объекта, то происходит вызов функции, где this глобальный объект window или undefined в строгом режиме</p>

    function Pet(type, legs) {
      this.type = type;
      this.legs = legs;
      this.logInfo = function() {
        console.log(this === myCat); // => false
        console.log(`The ${this.type} has ${this.legs} legs`);
      }
    }
    const myCat = new Pet('Cat', 4);
    // logs "The undefined has undefined legs"
    // or throws a TypeError in strict mode
    setTimeout(myCat.logInfo, 1000);

<p>Метод отделяется от своего объекта при передаче в качестве параметра: setTimeout(my Cat.logInfo). Следующие случаи эквивалентны:  </p>

    setTimout(myCat.logInfo);
    // is equivalent to:
    const extractedLogInfo = myCat.logInfo;
    setTimout(extractedLogInfo);

<p>Когда разделенный logInfo вызывается как функция, this глобальный объект или неопределенный в строгом режиме (но не объект myCat). Таким образом, информация об объекте записывается неправильно.

👍 Функция связывается с объектом с помощью метода .bind() Если отдельный метод связан с объектом myCat, проблема контекста решается:</p>

    // Create a bound function
    const boundLogInfo = myCat.logInfo.bind(myCat);
    // logs "The Cat has 4 legs"
    setTimeout(boundLogInfo, 1000);

<h2>Constructor invocation:</h2>    
<p>This это вновь созданный объект в вызове конструктора</p>
<img src="https://dmitripavlutin.com/static/a0f6062c2d9848de7c0b569aff17195b/27257/5-1.png" />
<p>Контекст вызова конструктора — это вновь созданный объект. Конструктор инициализирует объект данными, поступающими из аргументов конструктора, устанавливает начальные значения свойств, прикрепляет обработчики событий и т. д.</p>

<h3>constructor invocation распространенные ошибки:</h3>
<p>Забыть про слово new. Использование вызова функции для создания объектов является потенциальной проблемой, поскольку некоторые конструкторы могут опускать логику для инициализации объекта, когда отсутствует ключевое слово new.</p>

    function Vehicle(type, wheelsCount) {
      this.type = type;
      this.wheelsCount = wheelsCount;
      return this;
    }
    // Function invocation
    const car = Vehicle('Car', 4);
    car.type; // => 'Car'
    car.wheelsCount // => 4
    car === window // => true

<p>Вы можете подумать, что это хорошо работает для создания и инициализации новых объектов.

Однако this это объект window в вызове функции, поэтому Vehicle('Car', 4) задает свойства объекта window. Это ошибка. Новый объект не создается.</p>

<h2>Indirect invocation:</h2>  
<p>Indirect вызов выполняется, когда функция вызывается с использованием методов myFun.call() или myFun.apply().</p>
<p>This это первый аргумент .call() или .apply() в косвенном вызове</p>

<p>Функции в JavaScript являются объектами первого класса, что означает, что функция является объектом. Тип функционального объекта — Function.

Из списка методов, которые есть у функционального объекта, .call() и .apply() используются для вызова функции с настраиваемым контекстом.</p>

<h2>Bound function:<h2>

<p>Bound function это функция  чей контекст и/или аргументы  привязаны к определенным значениям. Связанная функция создается с помощью метода .bind(). Исходная и связанная функции имеют один и тот же код и область действия, но разные контексты и аргументы при выполнении.</p>
<img src="https://dmitripavlutin.com/static/96be8894060c323082745bb09e3ba854/b4774/7-1.webp" />

    function multiply(number) {
      'use strict';
      return this * number;
    }
    // create a bound function with context
    const double = multiply.bind(2);
    // invoke the bound function
    double(3); // => 6
    double(10); // => 20

<p>This это первый аргумент функции .bind()</p>
<p>.bind() создает постоянную контекстную ссылку и всегда будет ее сохранять. Связанная функция не может изменить свой связанный контекст при использовании .call() или .apply() с другим контекстом, или даже bind() не имеет никакого эффекта.</p>

<h2>Arrow function:</h2>

<p>Стрелочная функция предназначена для объявления функции в более короткой форме и лексической привязки контекста.</p>
<img src="https://dmitripavlutin.com/static/898df438becd3f7c1ad1193806d8dbc6/7abe2/8-1.png" />
<p>This это билжайший контекст в том месте где определена стрелочная функция.</p>
<p>Стрелочная функция не создает свой собственный контекст выполнения, а берет его из внешней функции, в которой она определена. Другими словами, стрелочная функция разрешает это лексически.</p>

    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      log() {
        console.log(this === myPoint); // => true
        setTimeout(() => {
          console.log(this === myPoint);      // => true
          console.log(this.x + ':' + this.y); // => '95:165'
        }, 1000);
      }
    }
    const myPoint = new Point(95, 165);
    myPoint.log();

<p>Стрелочная функция связана с лексикой this раз и навсегда. This нельзя изменить даже при использовании методов модификации контекста.</p>

<b>Стрелочная функция распространенные ошибки:</b>
<p>Возможно, вы захотите использовать стрелочные функции для объявления методов объекта. Достаточно справедливо: их объявление довольно короткое по сравнению с функциональным выражением: (param) => {...} вместо function(param) {..}.
</p>

    function Period (hours, minutes) { 
      this.hours = hours;
      this.minutes = minutes;
    }
    Period.prototype.format = () => {
      console.log(this === window); // => true
      return this.hours + ' hours and ' + this.minutes + ' minutes';
    };
    const walkPeriod = new Period(2, 30);
    walkPeriod.format(); // => 'undefined hours and undefined minutes'

<p>Поскольку format является стрелочной функцией и определяется в глобальном контексте (самая верхняя область видимости), он имеет this как объект window.

Даже если  format выполняется как метод объекта walkPeriod.format(), window сохраняется как контекст вызова. Это происходит потому, что стрелочная функция имеет статический контекст, который не меняется при различных типах вызовов.</p>

<p>Function expression решает проблему, потому что обычная функция меняет свой контекст в зависимости от вызова

<b>Итог:</b>
<p>Поскольку наибольшее влияние на this оказывает вызов функции, впредь не спрашивайте себя:</p>

<a>Откуда берется this?</a>

<p>но спросите себя:</p>

<a>Как *`функция вызывается*?</a>

<p>Для стрелочной функции задайте вопрос?</p>

<a>Чем является this внутри внешней функции, в которой определена стрелочная функция?</a>


</details>

<details>
<summary>11. Опишите разницу между == и === в JS ?</summary>

Оба оператора сравнения проверяют тождественность. Различие заключается в том, что двойное равно при сравнении значений неявно приводит (преобразует) типы значений к единому, так строка “1” и цифра 1 при таком сравнении будут равны. Тройное равно не выполняет никаких неявных трансформаций, а значит исходные типы будут иметь значения. Таким образом строка не будет равна числу и не важно что в обоих операндах фигурирует единица.

Строки сравниваются посимвольно в лексикографическом порядке.
Значения разных типов при сравнении приводятся к числу. 

Исключением является сравнение с помощью операторов строгого равенства/неравенства.

Значения null и undefined равны == друг другу и не равны любому другому значению. (при === они не равны)

Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined. Хорошей идеей будет сделать отдельную проверку на null/undefined.

alert( null >= 0 ); // (3) true
console.log(1550 >= null) // true
console.log(1550 >= undefined)  // false
console.log(2 <= null) // false
console.log(null <= 2) //true
</details>

<details>
<summary>12. Что такое цикл событий (event loop) и как он работает?</summary>
<div>
  <p>Event loop - это бесконечный цикл в котором движок JavaScript ожидает задачи и исполняет их. </p>

  <h2>JavaScript main thread:</h2>

  <p>Код, написанный на Javascript, выполняется синхронно – одна команда в один момент времени. Код работает в браузере, в котором множество процессов работают параллельно и для взаимодействия с этими процессами придумали следующее:</p>
  <ul>
    <li>Для каждой html страницы в браузере Javascript выполняется в своем отдельном потоке (Main Thread).</li>
    <li>Содержимое тега <script>…</script> или содержимое файла переданного в свойстве тега <script src=”file.js”>…</script> начнёт исполняться в процессе загрузки документа в браузер. Причём подгрузиться он может раньше, чем HTML-элементы</li>
    <li>Для того чтобы взаимодействовать с Web формой в HTML можно назначить функцию обработки на какое-либо событие:
        В HTML: onclick = ‘myFunc()’
        В Javascript: element.addEventListener("click", myFunc(), false);
    </li>
    <li>Для взаимодействия с другими процессами браузера существует набор интерфейсов Web API. При вызове функций этих интерфейсов нужно обязательно в качестве параметра передать функцию обратного вызова (callback function), которой будет передано управление после того, как Web API функция отработает. Эти интерфейсы не ограниченны одним потоком и могут работать параллельно. Кстати, setTimeout() так же является частью Web API.</li>
  </ul>
  <p>Далее при наступлении события или по окончанию работы функции Web API, функции обработки события и функции обратного вызова попадают в очередь - Event Queue. Откуда их извлекает и передаёт на исполнение Event Loop.</p>

  <img src="https://miro.medium.com/max/1400/1*PiFyb7IV8vTDCGEeUOWLVQ.jpeg" />
    <p>Main Thread - основной поток, где браузер выполняет JS.</p>
   <img src="https://habrastorage.org/r/w1560/webt/l0/z9/q2/l0z9q2s-zdltplomxlim269pu7k.png"/>
      <p>На основе этой схемы строится работа всего Event Loop.</p>
   <img src="https://habrastorage.org/r/w1560/webt/zh/lq/ff/zhlqffco6t_lo1sxkql-hoqmlmq.png"/>

  <p><b>Call Stack (На исполнение): </b>это место, где выполняется ваш код (ваши функции загружаются и выполняются, движок V8 в Chrome и NodeJS). Это обычеый LIFO stack(last-in-first-out). Когда он пуст, тоесть выполнил все текущие задачи Tick, он становится готовым принять следующий Tick из цикла событий </p>

  <p><b>Browsers APIs: </b>связь между вашим кодом и внутренними компонентами браузера для планирования задач, взаимодействия с DOM и многого другого (setTimeout, AJAX, createElement, querySelector, append, click, etc.) В случае обратных вызовов они добавят ваш код обратного вызова в Event queue событий, вместо этого, в случае then (метод промиса), ваш then-код будет добавлен в Job queue.</p>

  <p><b>Event queue (Task queue, Callback Queue, Macrotask queue): </b> каждый раз, когда вы добавляете обратный вызов (например, через setTimeout или API AJAX), он добавляется в эту очередь</p>
  <p><b>Job queue (Microtask queue): </b>его очередь зарезервирована для promise then (Promise.prototype.then() и Promise.prototype.catch(), а так же код который выполнится внутри async функций после выполнения таски с ключевым словом await), это очередь с приоритетом, ее смысл примерно такой: «выполнить этот код позже (= асинхронно), но как можно скорее!» (= до следующего тика Event Loop)», и поэтому браузеры ввели эту новую очередь для выполнения спецификаций промисов. Микротаски выполняются сразу после завершения Таски, c которой они связанны. Таким образом это не совсем отдельная очередь. Просто это некий довесок к таске, который должен выполнится сразу после неё. Сюда так же входит код, который выполниться сразу после await, в функции с ключевым словом async.</p>
  <p><b>Next Tick: </b> это то, что будет выполняться дальше, в основном это состоит из ОДНОГО обратного вызова из Event queue, ПОЛНОЙ Job queue (этот момент важен, текущий тик завершится только после того, как очередь заданий будет пуста, поэтому вы можете непреднамеренно заблокировать его выполнение). до следующего тика, если вы постоянно добавляете новые задания в эту очередь), может выполняться повторный рендеринг (выполните необходимые шаги в очереди рендеринга для обновления экрана)</p>

  <p><b>Render Queue: </b> которая отслеживает все изменения DOM модели. На данный момент раз в 16.6 мс. (при 60FPS) происходит перерисовка Web страницы и обновляются все связанные с ней элементы DOM.  Задачи от Render оптимизируются браузером и, если он посчитает, что в этом цикле не нужно ничего перерисовывать, то Event Loop просто пойдет дальше. </p>

  <p>Event Loop работает с очередями в следующем приоритете:</p>
  <ul>
    <li>Render Queue</li>
    <li>Task Queue (или Callback Queue, Macrotask Queue, Event Queue)</li>
    <li>После каждой выполненной Таски выполняются связанные с ней Микротаски</li>
  </ul>

  <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/9f6/6bd/1c9/9f66bd1c9b406e0026f7f0f74e4afe45.png" />


  <p><b>Next Tick:</b> Когда ваш код выполняется, он может вызывать API-интерфейсы браузера для взаимодействия с DOM или планирования какой-либо асинхронной задачи. Эти асинхронные задачи добавляются в Event queue или в приоритетную Job queue (при использовании промисов). Как только стек вызовов завершает обработку текущего тика (пуст), цикл событий передает ему новый тик (который состоит из ОДНОГО обратного вызова, ПОЛНОЙ очереди заданий и ВОЗМОЖНОСТИ вызова, полностью или только некоторые части, очередь рендеринга).</p>

  <h3>Что происходит в eventloop по шагам:</h3>
  <ul>
    <li>1. Выбирается самая старая  таска (task A) в Event queue</li>
    <li>2. Если task A = null (т е очередь из тасок пуста), переходим на шаг 6</li>
    <li>3. set "текущая запущенная таска"  для task A</li>
    <li>4. run task A (значит запуск ее callback функции)</li>
    <li>5. set "текущая запущенная таска"  = null , удалить task A</li>
    <li>6. Выполнение очереди job queue</li>
    <ul>
      <li>a. Выбирается самая старая  таска (task x) в Job queue</li>
      <li>b. Если task x = null (т е очередь из тасок пуста), переходим на шаг g</li>
      <li>c. set "текущая запущенная таска"  для task x</li>
      <li>d. run task x </li>
      <li>e. set "текущая запущенная таска"  = null , удалить task x</li>
      <li>f. select "следующая самая старая таска" в очереди job queue, переход на шан b</li>
      <li>g. окончание работы с job queue</li>
    </ul>
  </ul>

  <h3>Примеры тасок:</h3>
  <p>macrotasks: setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering
microtasks: process.nextTick, Promises, queueMicrotask, MutationObserver</p>
  <h3>Задача на event loop:</h3>
  <p>Код задачи: </p>

      console.log(1)

      setTimeout( () => {
        console.log(2)
      })

      const promise1 = new Promise( resolve => {
        console.log(3)
        resolve(4)
      })
      
      const promise2 = new Promise( resolve => {
        console.log(5)
        resolve(6)
      })

      promise1.then(console.log)
      promise2.then(console.log)

      console.log(7)

  <p>Решение:  Алгоритм решения. Делим код на "Основной поток кода", "Очередь микрозадач" и "Очередь макрозадач".  </p>

  | Main |	Micro | Macro |
  |--------|-------|------|
  | 1    |   4     |   2  |
  | 3    |   6     |      |
  | 5    |         |      |
  | 7    |         |      |

  <p>Сначала исполняется основной код. Потом очередь Micro, потом очередь Macro.</p>

</div>
</details>


<details>
<summary>13. Что такое web workers, service workers и worklets? В чем разница?</summary>
<div>
  <p>Веб-воркеры, сервис-воркеры и ворклеты все это скрипты которые выполняются в отдельном потоке. </p> 

  <h2>Веб-воркеры:</h2>
  <p>Веб-воркеры являются воркерами общего типа. В отличие от сервис-воркеров и ворклетов как мы увидим ниже, они не имеют конкретных вариантов использования, кроме возможности выполнения в отдельном потоке. Как результат веб-воркеры можно использовать для выгрузки почти любой тяжелой работы из основного потока.</p>

  <p>Данные отправляются между потоком воркера и основным потоком через систему сообщений - обе стороны отправляют свои сообщения с помощью метода postMessage () и отвечают на сообщения через обработчик события onmessage (сообщение содержится в атрибуте данных события  Message. Данные копируются, а не используются совместно.</p>

  <img src="https://miro.medium.com/max/1132/1*196hpA64Umf1vZMjBMGCBg.jpeg" />

      /* main.js */
      const myWorker = new Worker('worker.js');
      // Send message to worker
      myWorker.postMessage('Hello!');
      // Receive message from worker
      myWorker.onmessage = function(e) {
        console.log(e.data);
      }

      /* worker.js */
      // Receive message from main file
      self.onmessage = function(e) {
        console.log(e.data);
      // Send message to main file
        self.postMessage(workerResult);
}

  <h3>useCases:</h3>    
  <p>Хороший пример веб-приложение обработки изображений, Squoosh, который использует веб-воркеры для обработки задач по преобразованию изображений, оставляя основной поток для взаимодействия пользователя с приложением.</p>



  <h2>Сервис-воркеры:</h2>
  <p>Сервис-воркеры — это тип воркеров, которые служат определенной цели, быть прокси между браузером и сетью и/или кэшем. Это прокси между браузером и сетью. Перехватывая запросы, сделанные документом, сервис-воркеры могут перенаправлять запросы, позволяя работать автономно.</p>
  <img src="https://miro.medium.com/max/1400/1*xtvK2OPUXuqHkCYABg1uxw.jpeg" />
  <p>В отличие от обычных веб-воркеров, сервис-воркеры имеют дополнительные возможности, которые позволяют им выполнять свои функции прокси-сервера. После установки и активации сервис-воркеры могут перехватывать любые сетевые запросы из основного документа.</p>

    /* main.js */
    navigator.serviceWorker.register('/service-worker.js');

    /* service-worker.js */
    // Install 
    self.addEventListener('install', function(event) {
        // ...
    });
    // Activate 
    self.addEventListener('activate', function(event) {
        // ...
    });
    // Listen for network requests from the main document
    self.addEventListener('fetch', function(event) {
        // ...
    });

  <p>После перехвата сервис-воркеры могут, например, ответить, вернув документ из кэша вместо того чтобы идти за ним в сеть, тем самым позволяя веб-приложению работать автономно!</p>

    /* service-worker.js */
    self.addEventListener('fetch', function(event) {
        // Return data from cache
        event.respondWith(
            caches.match(event.request);
        );
    });

  <h2>Ворклеты:</h2>
  <p>Ворклеты — это очень легкие и специфичные воркеры. Они позволяют нам как разработчикам подключаться к различным частям процесса рендеринга браузера. Ворклеты это хуки внутри rendering pipeline браузера, позволяющий нам иметь низкоуровневый доступ к процессу рендеринга браузера, таким как вычисление стилей и расчет макета.</p>

  <h3>Типы ворклетов</h3>

  <p>Ворклеты ограничены конкретными вариантами использования; их нельзя использовать для произвольных вычислений, таких как Web Workers. Интерфейс Worklet абстрагирует свойства и методы, общие для всех видов worklet, и не может быть создан напрямую. Вместо этого вы можете использовать один из следующих классов:</p>

  <p><b>PaintWorklet - </b>Для программного создания изображения, где свойство CSS ожидает файл. Получите доступ к этому интерфейсу через CSS.paintWorklet.</p>

  <p><b>PaintWorklet - </b>Для обработки звука с помощью пользовательских AudioNodes.</p>
  <p><b>AnimationWorklet - </b>Для создания связанных с прокруткой и других высокопроизводительных процедурных анимаций.</p>
  <p><b>LayoutWorklet - </b>Для определения положения и размеров пользовательских элементов.</p>


</div>
</details>


<details>
<summary>14. Расскажите про requestAnimationFrame и requestIdleCallback?</summary>
<div>
  <h3>requestAnimationFrame</h3>
  <p>  Указывает браузеру на то, что вы хотите произвести анимацию, и просит его запланировать перерисовку на следующем кадре анимации. В качестве параметра метод получает функцию, которая будет вызвана перед перерисовкой.
  Вы должны вызывать этот метод всякий раз, когда готовы обновить анимацию на экране, чтобы запросить планирование анимации. Обычно запросы происходят 60 раз в секунду, но чаще всего совпадают с частотой обновления экрана. В большинстве браузеров в фоновых вкладках или скрытых <'iframe>, вызовы requestAnimationFrame() приостанавливаются, для того, чтобы повысить производительность и время работы батареи.</p>
  <p>Метод requestAnimationFrame предоставляет разработчикам доступ к жизненному циклу фрейма, позволяя выполнять операции перед вычислением стилей и формированием макета (layout) документа браузером. Вот почему данный метод отлично подходит для реализации анимации. Собственно, для этого он и предназначен.</p> 
  <ul>
    <li>Во-первых, он вызывается не чаще и не реже, чем браузер вычисляет макет (правильная частота). </li>
    <li>Во-вторых, он вызывается перед формированием макета (правильное время). Поэтому rAF также отлично подходит для внесения изменений в DOM или CSSOM. Он синхронизирован с vsync, как и любой другой механизм рендеринга, используемый браузером.</li>
  </ul>
  
      var start = null;
      var element = document.getElementById('SomeElementYouWantToAnimate');

      function step(timestamp) {
        if (!start) start = timestamp;
        var progress = timestamp - start;
        element.style.transform = 'translateX(' + Math.min(progress / 10, 200) + 'px)';
        if (progress < 2000) {
          window.requestAnimationFrame(step);
        }
      }

      window.requestAnimationFrame(step);

  <h3>requestIdleCallback</h3>
  <p>Метод window.requestIdleCallback() ставит в очередь функцию, которая будет вызываться во время периодов простоя браузера. Это позволяет разработчикам выполнять фоновую и низкоприоритетную работу в цикле основного события, без воздействия такими критично долгими событиями, как анимация и обработка ввода. Функции, обычно, вызываются в порядке очереди "первый вошёл - первый вышел"; однако колбэк-функции с заданными timeout, могут быть вызваны не по порядку, если необходимо запустить их до истечения таймаута.</p>

  <h3>Недостатки setTimeout, setInterval.</h3>
  <p>При написании кода, мы вручную устанавливаем, как именно будет происходить анимация покадрово. Частота кадров на мониторе и частота перерисовки браузером контента может быть не постоянной, это зависит от нагрузки, сколько одновременно запущено программ на компьютере клиента. В таких случаях можно наблюдать, как какие-то кадры замирают. Вдобавок частота кадров стремится к какому-то значению. Вот тогда и происходит рассинхронизация: setTimeout принуждает перерисовывать кадры, не синхронно со сменой кадров у компьютера. Однако самая большая проблема состоит в том, что если открыто несколько вкладок браузера, и на одной из них есть анимация, то она все равно работает, активна эта вкладка или нет. В результате, все это ведет к избыточной нагрузке на компьютер.</p>

  <h3>Пример:</h3>

      // HTML разметка
        <button class="btn">Запуск анимации</button>
    <div class="wrapper">
        <div class="box"></div>
    </div>    

  Найдем оба элемента по селектору и поместим их в переменные для наших манипуляций.

    const btn = document.querySelector('.btn'),
        elem = document.querySelector('.box');
    // Изначальная позиция квадрата
          let pos = 0;    

  requestAnimationFrame запускает функцию myAnimation() в виде коллбэка. Когда позиция элемента станет меньше 300, то нужно запустить анимацию, а если больше, то остановить анимацию. За запуск анимации отвечает requestAnimationFrame, таким образом происходит зацикливание анимации. И когда анимация выполнится 300 раз, то перестанет запускаться.

    function myAnimation() {
        pos++; // Увеличиваем позицию квадрата на единицу
        elem.style.top = pos + "px"; // Устанавливаем значение top для инлайн стилей у квадрата
          elem.style.left = pos + 'px'; // // Устанавливаем значение left для инлайн стилей у квадрата

        if (pos < 300) {
            requestAnimationFrame(myAnimation); // Запуск анимации
        }
    }

  Для запуска анимации в первый раз, отслеживаем клик по кнопке btn и вызываем requestAnimationFrame. Для отмены анимации, нужно вызвать метод cancelAnimationFrame с уникальным идентификатором.

    btn.addEventListener('click', () => requestAnimationFrame(myAnimation));

    let id = requestAnimationFrame(myAnimation);
    cancelAnimationFrame(id);    
</div>
</details>


<details>
<summary>15. Что такое замыкание?</summary>
<div>
  <h2>Набор терминов для понимания замыканий:</h2>
  <h3>Scope(Область видимости):</h3>
  <p>Область видимости — это политика пространства, которая управляет доступностью переменных.
  Область видимости изолирует переменные. </p>
  <p>Области видимости могут быть вложенными, внешняя область доступна из внутренней.</p>

  <h3>Lexical scope(Лексическое окружение):</h3>
  <p>Лексическая область видимости состоит из внешних областей видимости, определенных статически.</p>

  <h3>Closure(Замыкание):</h3>
  <img src="https://dmitripavlutin.com/abb81d8f5ca936ad83074e72cabf1d19/javascript-closure-6.svg" />
  <p>Замыкание — это функция, которая обращается к своей лексической области видимости, даже если она выполняется вне ее лексической области видимости.</p>
  <p>Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания.</p> 
  <p>Простыми словами, замыкание запоминает переменные из того места где оно было обьявлено и не важно где оно было запущено.</p>
  
  <h3>useCases:</h3>
  <p>Event handlers - Когда кнопка нажата, handleClick() выполняется где-то внутри кода DOM. Исполнение происходит далеко от места определения. </p>

  <p>Functional programming - carrying.  Каррирование происходит, когда функция возвращает другую функцию до тех пор, пока аргументы не будут предоставлены полностью.</p>
    
      function multiply(a) {
        return function executeMultiply(b) {
          return a * b;
        }
      }
      const double = multiply(2);
      double(3); // => 6
      double(5); // => 10
      const triple = multiply(3);
      triple(4); // => 12
 
</div>
</details>

<details>
<summary>16. Что такое прототип объекта в JavaScript?</summary>
<div>
  <p>В JavaScript объект может наследовать свойства другого объекта. Объект, от которого наследуются свойства, называется прототипом.</p>

  <p>Прототип даёт нам немного «магии». Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. В программировании такой механизм называется «прототипным наследованием». Многие интересные возможности языка и техники программирования основываются на нём.</p>
  <p>JavaScript ищет унаследованные свойства в прототипе объекта, а также в прототипе прототипа и так далее в цепочке прототипов.</p>
  <p>Суть прототипного наследования в JavaScript: объекты могут наследовать свойства от других объектов - прототипов. Связующим звеном выступает специальное свойство __proto__</p>
  <p>Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__. Недостаток этого подхода – он не работает в IE10-.</p>
  <p>К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ. Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.</p>
  <p>Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.</p>
  <p>При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.</p>
  
    var animal = {
      eats: true
    };

    function Rabbit(name) {
      this.name = name;
    }

    Rabbit.prototype = animal;

    var rabbit = new Rabbit("Кроль"); //  rabbit.__proto__ == animal

    alert( rabbit.eats ); // true

  <p>Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее: "При создании объекта через new Rabbit запиши ему __proto__ = animal".</p>

  <p>Значением Person.prototype по умолчанию является объект с единственным свойством constructor, содержащим ссылку на Person.</p>
  <p>Null это самый верхний прототип, у нуля уже нет прототипов.</p>
  <p>Свойство __proto__ — исторически обусловленный геттер/сеттер для [[Prototype]]
  Обратите внимание, что __proto__ — не то же самое, что [[Prototype]]. Это геттер/сеттер для него.</p>
  <p>Есть только два ограничения прототипирования:</p>
  <ul>
    <li>Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить __proto__ по кругу.</li>
    <li>Значение __proto__ может быть объектом или null. Другие типы игнорируются.</li>
  </ul>
  <p>прототипы никак не влияют на this.
  Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой. Это на самом деле очень важная деталь, потому что у нас может быть большой объект со множеством методов, от которого можно наследовать. Затем наследующие объекты могут вызывать его методы, но они будут изменять своё состояние, а не состояние объекта-родителя.</p>

  <p>Собственные и унаследованные свойства обьекта.</p>

    let animal = {
      eats: true
    };

    let rabbit = {
      jumps: true,
      __proto__: animal
    };

    // Object.keys возвращает только собственные ключи
    alert(Object.keys(rabbit)); // jumps

    // for..in проходит и по своим, и по унаследованным ключам
    for(let prop in rabbit) alert(prop); // jumps, затем eats

  <p>Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key. Но почему hasOwnProperty не появляется в цикле for..in в отличие от eats и jumps? Он ведь перечисляет все унаследованные свойства.

  Ответ простой: оно не перечислимо. То есть, у него внутренний флаг enumerable стоит false, как и у других свойств Object.prototype. Поэтому оно и не появляется в цикле.</p>
  
  <ul>
    <li>  В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.</li>
    <li> Мы можем использовать obj.__proto__ для доступа к нему (исторически обусловленный геттер/сеттер, есть другие способы, которые скоро будут рассмотрены).</li>
    <li>  Объект, на который ссылается [[Prototype]], называется «прототипом».</li>
    <li>  Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.</li>
    <li>Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).</li>
    <li>Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.</li>
    <li>Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.</li>
  </ul>
  <img src="https://learn.javascript.ru/article/native-prototypes/native-prototypes-classes.svg"/>

   <p>use cases:</p>
   <p>Одной из причин использования встроенного объекта-прототипа является многократное дублирование объекта, который будет иметь общую функциональность. Прикрепляя методы к прототипу, вы можете сэкономить на дублировании методов, создаваемых для каждого нового экземпляра. Но когда вы присоединяете метод к прототипу, все экземпляры будут иметь доступ к этим методам.</p>
</div>
</details>

<details>
<summary>17. Расскажите про классы в JavaScript?</summary>
  <h2>Класс и конструктор класса:</h2>
  <p>В JavaScript класс – это разновидность функции.</p>

    class User {
      constructor(name) { this.name = name; }
      sayHi() { alert(this.name); }
    }

    // доказательство: User - это функция
    alert(typeof User); // function
  
  <p>Вот что на самом деле делает конструкция class User {...}:</p>
  <ul>
    <li>Создаёт функцию с именем User, которая становится результатом объявления класса. Код функции берётся из метода constructor (она будет пустой, если такого метода нет).</li>
    <li>Сохраняет все методы, такие как sayHi, в User.prototype.
  При вызове метода объекта new User он будет взят из прототипа. Таким образом, объекты new User имеют доступ к методам класса.</li>
  </ul>

  <p>Можно проверить вышесказанное и при помощи кода:</p>

    class User {
      constructor(name) { this.name = name; }
      sayHi() { alert(this.name); }
    }

    // класс - это функция
    alert(typeof User); // function

    // ...или, если точнее, это метод constructor
    alert(User === User.prototype.constructor); // true

    // Методы находятся в User.prototype, например:
    alert(User.prototype.sayHi); // alert(this.name);

    // в прототипе ровно 2 метода
    alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi

  <p>Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.</p>
  <h3>Поля класса:</h3>
  <p>Поля класса — это переменные, содержащие информацию. Поля могут быть прикреплены к 2 объектам:</p>

  <ul>
    <li>Поля экземпляра класса</li>
    <li>Поля в самом классе (static)</li>
  </ul>



  <p>Поля также имеют 2 уровня доступности:</p>

  <ul>
    <li>Public: поле доступно в любом месте</li>
    <li>Private: поле доступно только внутри тела класса</li>
  </ul>

  <h3>Private fields</h3>
  <p>Приватные поля доступны только внутри тела класса.</p>

    class User {
      #name;
      constructor(name) {
        this.#name = name;
      }
      getName() {
        return this.#name;
      }
    }
    const user = new User('Jon Snow');
    user.getName(); // => 'Jon Snow'
    user.#name;     // SyntaxError is thrown

  <h3>Public static</h3>
  <p>Вы также можете определить поля в самом классе: статические поля. Они полезны для определения констант класса или хранения информации, относящейся к классу.</p>

    class User {
      static TYPE_ADMIN = 'admin';
      static TYPE_REGULAR = 'regular';
      name;
      type;
      constructor(name, type) {
        this.name = name;
        this.type = type;
      }
    }
    const admin = new User('Site Admin', User.TYPE_ADMIN);
    admin.type === User.TYPE_ADMIN; // => true

  <h3>Private static</h3>
  <p>Чтобы сделать статическое поле приватным, поставьте перед именем поля специальный символ #: static #myPrivateStaticField.

  Допустим, вы хотите ограничить количество экземпляров класса User. Чтобы скрыть детали лимитов экземпляров, вы можете создать приватные статические поля pattern singleton:</p>

    class User {
      static #MAX_INSTANCES = 1;
      static #instances = 0;
      
      name;
      constructor(name) {
        User.#instances++;
        if (User.#instances > User.#MAX_INSTANCES) {
          throw new Error('Unable to create User instance');
        }
        this.name = name;
      }
    }
    new User('Jon Snow');
    new User('Sansa Stark'); // throws Error

  <p>Эти закрытые статические поля доступны только в классе User. Ничто из внешнего мира не может помешать механизму ограничений: в этом преимущество инкапсуляции.</p>

  <h3>Static methods</h3>
  <p>Статические методы — это функции, прикрепленные непосредственно к классу. Они содержат логику, связанную с классом, а не с экземпляром класса.

      static myStaticMethod() { ... }.

  При работе со статическими методами следует помнить 2 простых правила:</p>

  <ul>
    <li>Статический метод может обращаться к статическим полям</li>
    <li>Статический метод не может получить доступ к полям экземпляра.</li>
  </ul>

    class User {
      static #takenNames = [];
      static isNameTaken(name) {
        return User.#takenNames.includes(name);
      }
      name = 'Unknown';
      constructor(name) {
        this.name = name;
        User.#takenNames.push(name);
      }
    }
    const user = new User('Jon Snow');
    User.isNameTaken('Jon Snow');   // => true
    User.isNameTaken('Arya Stark'); // => false

  <p>isNameTaken() — это статический метод, который использует статическое приватное поле User.#takenNames для проверки занятых имен.

  Статические методы могут быть приватными: static #staticFunction() {...}. Опять же, они соблюдают правила приватности: вы можете вызывать приватный статический метод только внутри тела класса.</p>

  <h3>Inheritance: extends</h3>
  <p>Классы в JavaScript поддерживают одиночное наследование с использованием ключевого слова extends.

  В выражении class Child extends Parent { } класс Child наследует от Parent конструктор, поля и методы.</p>

    class User {
      name;
      constructor(name) {
        this.name = name;
      }
      getName() {
        return this.name;
      }
    }
    class ContentWriter extends User {
      posts = [];
    }
    const writer = new ContentWriter('John Smith');
    writer.name;      // => 'John Smith'
    writer.getName(); // => 'John Smith'
    writer.posts;     // => []

  <p>ContentWriter наследует от пользователя конструктор, метод getName() и имя поля. Кроме того, класс ContentWriter объявляет новое поле posts.

  Обратите внимание, что частные члены родительского класса не наследуются дочерним классом.</p>

  <h3>Parent constructor: super() in constructor()</h3>
  <p>Если вы хотите вызвать родительский конструктор в дочернем классе, вам нужно использовать специальную функцию super(), доступную в дочернем конструкторе.

  Например, сделаем так, чтобы конструктор ContentWriter вызывал родительский конструктор User, а также инициализировал поле posts:</p>

    class User {
      name;
      constructor(name) {
        this.name = name;
      }
      getName() {
        return this.name;
      }
    }
    class ContentWriter extends User {
      posts = [];
      constructor(name, posts) {
        super(name);
        this.posts = posts;
      }
    }
    const writer = new ContentWriter('John Smith', ['Why I like JS']);
    writer.name; // => 'John Smith'
    writer.posts // => ['Why I like JS']

  <p>super(name) inside the child class ContentWriter executes the constructor of the parent class User</p>

  <h3>Parent instance: super в методах</h3>
  <p>Если вы хотите получить доступ к родительскому методу внутри дочернего метода, вы можете использовать специальный ярлык super.</p>

    class User {
      name;
      constructor(name) {
        this.name = name;
      }
      getName() {
        return this.name;
      }
    }
    class ContentWriter extends User {
      posts = [];
      constructor(name, posts) {
        super(name);
        this.posts = posts;
      }
      getName() {
        const name = super.getName();
        if (name === '') {
          return 'Unknwon';
        }
        return name;
      }
    }
    const writer = new ContentWriter('', ['Why I like JS']);
    writer.getName(); // => 'Unknwon'

  <p>getName() дочернего класса ContentWriter обращается к методу super.getName() непосредственно из родительского класса User.

  Эта функция называется переопределением метода.

  Обратите внимание, что вы также можете использовать super со статическими методами, чтобы получить доступ к статическим методам родителя.</p>

  

  <p>Итого:</p>

    class MyClass {
      prop = value; // свойство
      constructor(...) { // конструктор
        // ...
      }
      method(...) {} // метод
      get something(...) {} // геттер
      set something(...) {} // сеттер
      [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
      // ...
    }

  
  <p>MyClass технически является функцией (той, которую мы определяем как constructor), в то время как методы, геттеры и сеттеры записываются в MyClass.prototype.</p>

  <p>Давайте обобщим, какие методы для проверки типа мы знаем:</p>

  | работает | для | возвращает |
  | -------- | --- | ---------- | 
  | typeof   |	примитивов |	строка |
  | {}.toString |	примитивов, встроенных объектов, объектов с Symbol.toStringTag | строка |
  | instanceof	| объектов	| true/false |

  <p>Как мы можем видеть, технически {}.toString «более продвинут», чем typeof.

  А оператор instanceof – отличный выбор, когда мы работаем с иерархией классов и хотим делать проверки с учётом наследования. 
  instanceof является полиморфным: оператор определяет дочерний элемент как экземпляр родительского класса. </p>

  <p>Классы JavaScript инициализируют экземпляры с помощью конструкторов, определяют поля и методы. Вы можете присоединять поля и методы даже к самому классу, используя ключевое слово static.

  Наследование достигается с помощью ключевого слова extends: вы можете легко создать дочерний класс из родительского. ключевое слово super используется для доступа к родительскому классу из дочернего класса.

  Чтобы воспользоваться преимуществами инкапсуляции, сделайте поля и методы закрытыми, чтобы скрыть внутренние детали ваших классов. Имена приватных полей и методов должны начинаться с #.</p>
</details>



<details>
<summary>18. Как работают методы apply(), call() и bind()?</summary>
<div>
  <p>Функции в JavaScript никак не привязаны к своему контексту this, с одной стороны, здорово – это позволяет быть максимально гибкими, одалживать методы и так далее.</p>
  <p>Но с другой стороны – в некоторых случаях контекст может быть потерян. Способы явно указать this  - методы bind, call и apply.</p>
  <ul>
    <li>
      <p>Синтаксис метода call: func.call(context, arg1, arg2, ...)</p>
      <p>При этом вызывается функция func, первый аргумент call становится её this, а остальные передаются «как есть». Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context).</p>
    </li>
    <li>
      <p>Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply. Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.</p>
      <p>
        func.call(context, arg1, arg2) идентичен вызову func.apply(context, [arg1, arg2]);
      </p>
    </li>
    <li>
      <p>Синтаксис встроенного bind: var wrapper = func.bind(context[, arg1, arg2...])</p>
      <p>Методы bind и call/apply близки по синтаксису, но есть важнейшее отличие. Методы call/apply вызывают функцию с заданным контекстом и аргументами. А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.</p>
    </li>
  </ul>
  <p>
    <i>Источник:
      <br/>
      <a href ="https://learn.javascript.ru/call-apply#metod-apply">javascript.ru - call и apply</a>
      <br/>
      <a href ="https://learn.javascript.ru/bind#bind">javascript.ru - bind</a>
    </i>
  </p>
</div>
</details>

<details>
<summary>19. Что такое Promise (Промис)?</summary>
<div>
  <br/>
  <h1>Promise</h1>
  <p>Promise – это специальный объект, который содержит состояние выполнения асинхронной функции. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).</p>
  <p>Промисы, оборачивающие результат асинхронной операции, могут быть возвращены синхронно из функции, присвоены переменным или использованы в качестве аргументов. В этом и заключается идея промисов: инкапсулировать асинхронность и позволить функциям, обрабатывающим асинхронные операции, по-прежнему выглядеть синхронно.</p>
  <p>
    Синтаксис создания Promise:

    var promise = new Promise(function(resolve, reject) {
      // Эта функция будет вызвана автоматически

      // В ней можно делать любые асинхронные операции,
      // А когда они завершатся — нужно вызвать одно из:
      // resolve(результат) при успешном выполнении
      // reject(ошибка) при ошибке
       if (asyncOperationSuccess) {
        resolve(value); // async operation successful
      } else {
        reject(error);  // async operation error
      }
    })
  </p>
  <p>Большинство асинхронных функций популярных библиотек (например, axios) или веб-API (например, fetch()) возвращают уже созданные промисы.</p>
  <p>
    Универсальный метод для навешивания обработчиков:
    
    promise.then(onFulfilled, onRejected)
    
  <ul>
    <li>onFulfilled – функция, которая будет вызвана с результатом при resolve.</li>
    <li>onRejected – функция, которая будет вызвана с ошибкой при reject.</li>
  </ul>
    Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) – это то же самое.
  </p>
  <p>
    Возьмём setTimeout в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»:
  
    // Создаётся объект promise
    let promise = new Promise((resolve, reject) => {

      setTimeout(() => {
        // переведёт промис в состояние fulfilled с результатом "result"
        resolve("result");
      }, 1000);

    });

    // promise.then навешивает обработчики на успешный результат или ошибку
    promise
      .then(
        result => {
          // первая функция-обработчик - запустится при вызове resolve
          alert("Fulfilled: " + result); // result - аргумент resolve
        },
        error => {
          // вторая функция - запустится при вызове reject
          alert("Rejected: " + error); // error - аргумент reject
        }
      );
   В результате запуска кода выше – через 1 секунду выведется «Fulfilled: result».
  </p>
  <h1>Promise chain</h1>
  <p>Второе большое преимущество заключается в том, что промисы могут создавать цепочки для обработки нескольких зависимых асинхронных операций.

  Техническая сторона цепочки состоит в том, что методы promise.then(successCallback) и даже promise.catch(errorCallback) сами по себе возвращают промис, к которому можно присоединить методы .then() или .catch(), и т.д. на.</p>

  <h1>Методы Promise</h1>

  <p>
  <h3>Promise.all(iterable)</h3>
  Ожидает исполнения всех промисов или отклонения любого из них.
  Возвращает промис, который исполнится после исполнения всех промисов в iterable. В случае, если любой из промисов будет отклонён, Promise.all будет также отклонён.

  <br/>
  
  <h3>Promise.allSettled(iterable)</h3>
  Ожидает завершения всех полученных промисов (как исполнения так и отклонения).
  Возвращает промис, который исполняется когда все полученные промисы завершены (исполнены или отклонены), содержащий массив результатов исполнения полученных промисов.

      const statusesPromise = Promise.allSettled([
        resolveTimeout(['potatoes', 'tomatoes'], 1000),
        resolveTimeout(['oranges', 'apples'], 1000)
      ]);
      // wait...
      const statuses = await statusesPromise;
      // after 1 second
      console.log(statuses); 
      // [
      //   { status: 'fulfilled', value: ['potatoes', 'tomatoes'] },
      //   { status: 'fulfilled', value: ['oranges', 'apples'] }
      // ]

  <br/>
  
  <h3>Promise.race(iterable)</h3>
  Ожидает исполнения или отклонения любого из полученных промисов.
  Возвращает промис, который будет исполнен или отклонён с результатом исполнения первого исполненного или отклонённого промиса из .iterable.
  Promise.race устанавливается, как только выполняется любое из promise, которые вы ему передаете, независимо от того, выполнены они или отклонены.

  <h3>Promise.any(iterable)</h3>
  Promise.any(promises) — это вспомогательная функция, которая выполняет промисы параллельно и разрешает значение первого успешно разрешенного промиса из списка промисов.Полезно выполнять независимые асинхронные операции параллельно и в режиме гонки, чтобы получить значение любого первого выполненного обещания.
  Promise, возвращаемый Promise.any(), выполняется с любым первым выполненным promise. Даже если некоторые promise будут rejected, эти reject будут проигнорированы.

  <h3>Разница promse.race VS promise.any</h3>
  Promise.any решится, как только любое из переданных вами promise выполнено или все они отклонены, и в этом случае они отклоняются с AggregateError.

  <h3>Основные отличия:</h3>

  Promise.race реджектится, когда реджектиться первый promise, который вы ей даете; c any процесс происходит по другому, она обработает promise до первого успешного или пока все не отклонятся

  причиной отклонения promise.any может быть только AggregateError, но причиной отклонения promise.race может быть отклонение любого promise.
  <br/>

  <h3>Promise.reject(reason)</h3>
  Возвращает промис, отклонённый из-за reason.

  <br/>

  <h3>Promise.resolve(value)</h3>
  Возвращает промис, исполненный с результатом value.
  </p>

  <h1>async/await преимущества</h1>
  <p>Использование промисов по-прежнему требует обратных вызовов и относительно большого количества шаблонного кода, такого как .then(), .catch().</p>

  <p> Синхронно вернуть результат из Promise не получится, promise всегда возвращает promise.</p>

  К счастью, JavaScript сделал еще один шаг вперед в улучшении асинхронного кода, предоставив синтаксис async/await — действительно полезный синтаксический сахар поверх промисов.

  Когда это возможно, я настоятельно рекомендую работать с    синтаксисом async/await, а не с необработанными промисами.

  Применение синтаксиса async/await поверх промисов относительно просто:
  <ul>
    <li>Отметьте функции, использующие промисы, ключевым словом async.</li>
    <li>Внутри тела асинхронной функции всякий раз, когда вы хотите дождаться разрешения промиса, используйте синтаксис await promiseExpression</li>
    <li>Асинхронная функция всегда возвращает обещание, что позволяет вызывать асинхронные функции внутри асинхронных функций.</li>
  </ul>

      const address = fetch("https://jsonplaceholder.typicode.com/users/1")
        .then((response) => response.json())
        .then((user) => {
          return user.address;
        });

      const printAddress = async () => {
        const a = await address;
        console.log(a);
      };

      printAddress();
</div>
</details>

<details>
  <summary>20. Promise.all?</summary>
  <div>
  Допустим, нам нужно запустить множество промисов параллельно и дождаться, пока все они выполнятся.

  Например, параллельно загрузить несколько файлов и обработать результат, когда он готов.

  Для этого как раз и пригодится Promise.all.

  Синтаксис:

  let promise = Promise.all([...промисы...]);
  Метод Promise.all принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив) и возвращает новый промис.

  Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.
  Часто применяемый трюк – пропустить массив данных через map-функцию, которая для каждого элемента создаст задачу-промис, и затем обернёт получившийся массив в Promise.all.

  Например, если у нас есть массив ссылок, то мы можем загрузить их вот так:

   
    let urls = [
      'https://api.github.com/users/iliakan',
      'https://api.github.com/users/remy',
      'https://api.github.com/users/jeresig'
    ];

    // Преобразуем каждый URL в промис, возвращённый fetch
    let requests = urls.map(url => fetch(url));

    // Promise.all будет ожидать выполнения всех промисов
    Promise.all(requests)
      .then(responses => responses.forEach(
        response => alert(`${response.url}: ${response.status}`)
      
      ));

  В случае ошибки, остальные результаты игнорируются
  Если один промис завершается с ошибкой, то весь Promise.all завершается с ней, полностью забывая про остальные промисы в списке. Их результаты игнорируются.

  Например, если сделано несколько вызовов fetch, как в примере выше, и один не прошёл, то остальные будут всё ещё выполняться, но Promise.all за ними уже не смотрит. Скорее всего, они так или иначе завершатся, но их результаты будут проигнорированы.

  Promise.all ничего не делает для их отмены, так как в промисах вообще нет концепции «отмены». 
  </div>
</details>

<details>
  <summary>21. Async/await?</summary>
  <div>
  Функции, объявленные с использованием ключевого слова async (асинхронные функции), дают нам возможность писать аккуратный и не перегруженный служебными конструкциями код, позволяющий получить тот же результат, который мы получали с использованием промисов. Надо отметить, что ключевое слово async — это, в сущности, лишь «синтаксический сахар» для промисов.

  Внутри функции используется ключевое слово await, которое ставится перед вызовом функций, которые, в свою очередь, тоже возвращают промисы. Если результат этого вызова присваивается переменной или константе, то в них записывается результат вызова. Если присвоения нет, как в последнем вызове await, то происходит ожидание выполнения операции без использования её результата.

  Асинхронность в данном случае (как и в промисах) гарантирует нам, что программа не блокируется ожидая завершения вызовов, она может продолжать делать что-то еще (но не в этой функции). Но она не гарантирует параллельности. Более того, подряд идущие await в рамках одной функции всегда выполняются строго друг за другом.

  Асинхронные функции создают, пользуясь при объявлении функции ключевым словом async. Выглядит это так:

    const asyncFunction = async () => {
      // Код
    }

  Выполнение асинхронной функции можно приостановить с использованием ключевого слова await. Его можно использовать только в асинхронных функциях. Оно позволяет возвратить результат работы асинхронной функции, который будет доступен после того, как такая функция завершит выполнение некоей задачи.

  Сравним работу асинхронной функции и промиса, которые возвращают строку:

      // Асинхронная функция
      const asyncGreeting = async () => 'Greetings';
      // Промис
      const promiseGreeting = () => new Promise(((resolve) => {
        resolve('Greetings'); 
      }));
      asyncGreeting().then(result => console.log(result));
      promiseGreeting().then(result => console.log(result));

  Несложно заметить, что использование ключевого слова async позволяет писать асинхронный код, который выглядит как синхронный. С таким кодом гораздо легче работать.

  <h2>Итог: </h2>
  <p>async/await имеет 4 простых правила:</p>
  <ul>
    <li>Функция, обрабатывающая асинхронную задачу, должна быть помечена ключевым словом async.</li>
    <li>Оператор await promise приостанавливает выполнение функции до тех пор, пока обещание не будет успешно разрешено или отклонено.</li>
    <li>Если обещание разрешается успешно, оператор await возвращает разрешенное значение: const resolveValue = await обещание. В противном случае вы можете поймать отклоненное обещание внутри try/catch.</li>
    <li>Асинхронная функция всегда возвращает обещание, что дает возможность вкладывать асинхронные функции.</li>
  </ul>
  </div>
</details>


<details>
<summary>22. Что такое Set, Map, WeakSet и WeakMap?</summary>
<div>
  <br/>
  <p>В ES-2015 появились новые типы коллекций в JavaScript: Set, Map, WeakSet и WeakMap.</p>
  <p>Map – коллекция для хранения записей вида ключ:значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например:</p>
  <p>
    
    Методы и свойства:

    new Map([iterable]) – создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар [ключ,значение] для инициализации.
    map.set(key, value) – записывает по ключу key значение value.
    map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
    map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
    map.delete(key) – удаляет элемент по ключу key.
    map.clear() – очищает коллекцию от всех элементов.
    map.size – возвращает текущее количество элементов.
    Отличия от обычного объекта Object:

    Что угодно может быть ключом, в том числе и объекты.
    Есть дополнительные методы, свойство size.
  </p>
  <p>
    Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. Set для этого отлично подходит:
  </p>
  <p>
    
    Методы и свойства:

    new Set([iterable]) – создаёт Set, можно указать перебираемый объект со значениями для инициализации.
    set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
    set.delete(value) – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false.
    set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
    set.clear() – удаляет все имеющиеся значения.
    set.size – возвращает количество элементов в множестве.
    Перебор Map и Set всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это – неупорядоченные коллекции, но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.
  </p>


  <p>WeakMap - принципиально другая структура в этом аспекте. Она не предотвращает удаление объектов сборщиком мусора, когда эти объекты выступают в качестве ключей.</p>
  <p>Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями. Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта WeakMap) автоматически.  Количество элементов в коллекции WeakMap неизвестно. Движок может произвести очистку сразу или потом, или сделать это частично. По этой причине методы для доступа ко всем сразу ключам/значениям недоступны.</p>

  <p>Примеры использования weakMap: 
    Другая частая сфера применения – это кеширование, когда результат вызова функции должен где-то запоминаться («кешироваться») для того, чтобы дальнейшие её вызовы на том же объекте могли просто брать уже готовый результат, повторно используя его. Многократные вызовы process(obj) с тем же самым объектом в качестве аргумента ведут к тому, что результат вычисляется только в первый раз, а затем последующие вызовы берут его из кеша. Недостатком является то, что необходимо вручную очищать cache от ставших ненужными объектов.

    Но если мы будем использовать WeakMap вместо Map, то эта проблема исчезнет: закешированные результаты будут автоматически удалены из памяти сборщиком мусора.
  </p>
    
    В WeakMap присутствуют только следующие методы:

    weakMap.get(key)
    weakMap.set(key, value)
    weakMap.delete(key)
    weakMap.has(key)

    // текущие активные пользователи
    let activeUsers = [
      {name: "Вася"},
      {name: "Петя"},
      {name: "Маша"}
    ];

    // вспомогательная информация о них,
    // которая напрямую не входит в объект юзера,
    // и потому хранится отдельно
    let weakMap = new WeakMap();

    weakMap.set(activeUsers[0], 1);
    weakMap.set(activeUsers[1], 2);
    weakMap.set(activeUsers[2], 3);
    weakMap.set('Katya', 4); //Будет ошибка TypeError: "Katya" is not a non-null object

    alert( weakMap.get(activeUsers[0]) ); // 1

    activeUsers.splice(0, 1); // Вася более не активный пользователь

    // weakMap теперь содержит только 2 элемента

    activeUsers.splice(0, 1); // Петя более не активный пользователь

    // weakMap теперь содержит только 1 элемент
  </p>
    <p>
    WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. 
    То же самое – WeakMap для Map.</p>

  <ul>
    <li>Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).</li>
    <li>Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.</li>
    <li>Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.</li>
  </ul>

  <p>Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа «да/нет». Присутствие во множестве WeakSet может что-то сказать нам об объекте.

  Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто посещал наш сайт</p>

  <p>Наиболее значительным ограничением WeakMap и WeakSet является то, что их нельзя перебрать или взять всё содержимое. Это может доставлять неудобства, но не мешает WeakMap/WeakSet выполнять их главную задачу – быть дополнительным хранилищем данных для объектов, управляемых из каких-то других мест в коде.</p>

  <h2>Итого:</h2>
  <p>WeakMaps позволяют расширять объекты извне, не мешая сборке мусора.</p>
</div>
</details>



<details>
<summary>23. Что делает строчка “use strict”;? Какие достоинства и недостатки от ее использования?</summary>
<div>
  <p>ECMAScript 5 (ES5) добавил новые возможности в язык и изменил некоторые из существующих. Чтобы устаревший код работал, как и раньше, по умолчанию подобные изменения не применяются. Поэтому нам нужно явно их активировать с помощью специальной директивы: "use strict".</p>

  <p>
  ‘use strict’ это директива, используемая для включения строгого режима во всем скрипте или отдельных функциях.</p>
  <h2>Преимущества:</h2>
  <p>Не позволяет случайно создавать глобальные переменные.</p>
  <p>Любое присваивание, которое в обычном режиме завершается неудачей, в строгом режиме выдаст исключение.</p>
  <p>При попытке удалить неудаляемые свойства, выдаст исключение (в то время как в нестрогом режиме никакого действия бы не произошло).</p>
  <p>Требует, чтобы имена параметров функции были уникальными.</p>
  <p>this в глобальной области видимости равно undefined.</p>
  <p>Перехватывает распространенные ошибки, выдавая исключения.</p>
  <h2>Недостатки:</h2>
  <p>Нельзя использовать некоторые особенности языка, к которым привыкли некоторые разработчики.</p>
  <p>Нет доступа к function.caller и function.arguments.</p>
  <p>Объединение скриптов, написанных в строгом режиме может вызвать проблемы.</p>
  <p>В целом, я думаю, что преимущества перевешивают недостатки, и мне никогда не приходилось полагаться на функции, которые заблокированы в строгом режиме. Я бы порекомендовал использовать строгий режим.</p>
</div>
</details>

<details>
<summary>24. Расскажите про методы массивов forEach, filter, map, reduce?</summary>
<div>
  <p>forEach ни чего не возвращает. Прервать итерирование по массиву не возможно.</p>

    items.forEach((elem, index, array) => {
      // console.log(elem, index , array)
    })

  <p>filer - возвращает ту часть массива которая прошла по какому то критерию</p>

    let check = array.filter( 
      function(elem, index, array) {
        return index > 1
      })

  <p> map - проходимся по всем элементам нашего массива и точно так же вызываем функцию callback, вернет массив, каждый элемент массива будет содержать новое значение которое вернула функция callback.</p>

    let result = array.map(function(elem){
      return elem*2
    })

  <p>reduce - выполняет функцию callback на каждом элементе массива передавая результат выполнения на следующую итерацию. Из массива в итоге получиться 1 значение. Внутри acc аккамулируется сумма которую мы считаем в примере.</p>

    let total = array.reduce(function(acc, elem) {
      return acc + elem
    }, initValue)

    const array2 = ['apple', 'banana', 'peach', 'orange']

    let fruits = array2.reduce((acc, elem) => {
      acc[elem] = 1
      return acc
    }, {})

</div>
</details>



<details>
<summary>25. Что такое "чистая функция"?</summary>
<div>
  <p>
   Чистые функции — строительные блоки в функциональном программировании. Их обожают за простоту и тестируемость.  Функция должна удовлетворять двум условиям, чтобы считаться «чистой»:

  — Каждый раз функция возвращает одинаковый результат, когда она вызывается с тем же набором аргументов

  — Нет побочных эффектов
   </p> 

   <p> 1. Нечистые функции = непостоянные результаты </p>
   <p> 2. Нет побочных эффектов </p>
   <p>Примеры побочных эффектов:

    Видоизменение входных параметров
    console.log
    HTTP вызовы (AJAX/fetch)
    Изменение в файловой системе
    Запросы DOM

    
  </p> 
  <p>По сути, любая работа, выполняемая функцией, не связана с вычислением конечного результата. </p>
</div>
</details>

<details>
<summary>26. Что такое лямбда- или стрелочные функции?</summary>
<div>

  Стрелочные функции — это сокращенный способ записи функциональных выражений. Они не имеют собственных this, arguments, super и new.target. Эти функции служат хорошей альтернативой функциям, не имеющим методов, но не могут использоваться как конструкторы.
</div>
</details>


<details>
<summary>27. Что такое запоминание или мемоизация?</summary>
<div>
  Мемоизация — это способ повышения производительности функции за счет сохранения в кэше ранее полученных результатов выполнения этой функции. При каждом вызове функции переданный ей аргумент становится индексом кэша. Если данные имеются в кэше, они возвращаются без повторного выполнения функции. В противном случае, функция выполняется, а результат записывается в кэш:

    const memoizAddition = () => {
        let cache = {}
        return value => {
            if (value in cache) {
                console.log('Получение данных из кэша')
                return cache[value] // в данном случае, cache.value не может быть использовано в качестве названия свойства, поскольку названия свойств в JS не могут начинаться с числа. Поэтому используется скобочная нотация
            } else {
                console.log('Результат вычисляется')
                let result = value + 20
                cache[value] = result
                return result
            }
        }
    }
    // возвращаем функцию из memoizAddition
    const addition = memoizAddition()
    console.log(addition(20)) // Результат вычисляется 40
    console.log(addition(20)) // Получения данных из кэша 40


    const multiplayer = (x, y, str) =>{
    
      console.log(x , y, str + ' args in fn')
      return x*y
    }

    const memoize = (fn) => {
      const cache = {}

      return (...args) =>  {
        
        if(cache[args]){
          console.log('result from cache')
          return cache[args]
        } else {
          const results = fn(...args)
          cache[args] = results
          console.log('memoized')
          return results
        }
        
      }
      
      
    }

    const memFn = memoize(multiplayer)
    console.log(memFn(3, 4, 'vlad'))
    console.log(memFn(3, 4, 'vlad'))
</div>
</details>


<details>
<summary>28. Расскажите про сборку мусора в JavaScript?</summary>
<div>
  <h2>Достижимость:</h2>
  Основной концепцией управления памятью в JavaScript является принцип достижимости.

  Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.

  Существует базовое множество достижимых значений, которые не могут быть удалены.

  <a>Например:</a>
  <ul>
    <li>Локальные переменные и параметры текущей функции.</li>
    <li>Переменные и параметры других функций в текущей цепочке вложенных вызовов.</li>
    <li>Глобальные переменные.</li>
  <ul>

  <b>Эти значения мы будем называть корнями.</b>

  Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.

  Например, если в локальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым. И те, на которые он ссылается, тоже достижимы. 

  В интерпретаторе JavaScript есть фоновый процесс, который называется сборщик мусора. Он следит за всеми объектами и удаляет те, которые стали недостижимы.

  <h2>Внутренние алгоритмы:</h2>
  Основной алгоритм сборки мусора – «алгоритм пометок» (англ. «mark-and-sweep»).

  <a>Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:</a>
  <ul>
    <li>Сборщик мусора «помечает» (запоминает) все корневые объекты.</li>
    <li>Затем он идёт по их ссылкам и помечает все найденные объекты.</li>
    <li>Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них. Все объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.</li>
   <li> …И так далее, пока не будут посещены все ссылки (достижимые от корней).
    Все непомеченные объекты удаляются.</li>
  </ul>

  <a>Вот некоторые из оптимизаций:</a>
  <ul>
    <li>Сборка по поколениям (Generational collection) – объекты делятся на «новые» и «старые». Многие объекты появляются, выполняют свою задачу и быстро умирают, их можно удалять более агрессивно. Те, которые живут достаточно долго, становятся «старыми» и проверяются реже.
    </li>
    <li>Инкрементальная сборка (Incremental collection) – если объектов много, то обход всех ссылок и пометка достижимых объектов может занять значительное время и привести к видимым задержкам выполнения скрипта. Поэтому интерпретатор пытается организовать сборку мусора поэтапно. Этапы выполняются по отдельности один за другим. Это требует дополнительного учёта для отслеживания изменений между этапами, но зато теперь у нас есть много крошечных задержек вместо одной большой.</li>
    <li>Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.</li>
  </ul>
  <a>Главное из того, что мы узнали:</a>
  <ul>
    <li>Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.</li>
    <li>Объекты сохраняются в памяти, пока они достижимы.</li>
    <li>Наличие ссылки не гарантирует, что объект достижим (от корня): несколько взаимосвязанных объектов могут стать недостижимыми как единое целое.</li>
  </ul>
</div>
</details>

<details>
<summary>29. Как сравнивать обьекты в JavaScript?</summary>
  <p>JavaScript предоставляет 3 способа сравнения значений:</p>
  <ul>
    <li>1. Оператор строго равенства ===</li>
    <li>2. Оператор свободного равенста ==</li>
    <li>3. Object.is() функция</li>
  </ul>

  <p>Когда вы сравниваете обьекты одним из превиденных выше способов, сравнение выдаст true только в том случае если сравниваемые значения ссылаются на один и тот же экземпляр обьекта. </p>

      const hero1 = {
        name: 'Batman'
      };
      const hero2 = {
        name: 'Batman'
      };
      hero1 === hero1; // => true
      hero1 === hero2; // => false
      hero1 == hero1; // => true
      hero1 == hero2; // => false
      Object.is(hero1, hero1); // => true
      Object.is(hero1, hero2); // => false

  <p>Еще раз. Сравниваются ссылки, а не сами обьекты</p>

  <h2>Manual сравнение:</h2>
  <p>Очевидный способ сравнить объекты по содержимому — прочитать свойства и сравнить их вручную.</p>

    function isHeroEqual(object1, object2) {
      return object1.name === object2.name;
    }
    const hero1 = {
      name: 'Batman'
    };
    const hero2 = {
      name: 'Batman'
    };
    const hero3 = {
      name: 'Joker'
    };
    isHeroEqual(hero1, hero2); // => true
    isHeroEqual(hero1, hero3); // => false

  <p>Ручное сравнение требует ручного извлечения свойств — для простых объектов это не проблема. Но для сравнения больших объектов (или объектов с неизвестной структурой) ручное сравнение неудобно, так как требует большого количества шаблонного кода.</p>


  <h2>Shallow сравнение:</h2>
  <p>Во время поверхностной проверки на равенство объектов вы получаете список свойств (используя Object.keys()) обоих объектов, затем проверяете значения свойств на равенство</p>

      function shallowEqual(object1, object2) {
        const keys1 = Object.keys(object1);
        const keys2 = Object.keys(object2);
        if (keys1.length !== keys2.length) {
          return false;
        }
        for (let key of keys1) {
          if (object1[key] !== object2[key]) {
            return false;
          }
        }
        return true;
      }

  <p>Но объекты в JavaScript могут быть вложенными. В таком случае, к сожалению, поверхностное равенство не работает.</p>    

  <h2>Deep сравнение:</h2>
  <p>Глубокое равенство похоже на поверхностное равенство, но с одним отличием. Во время неглубокой проверки, если сравниваемые свойства являются объектами, для этих вложенных объектов выполняется рекурсивная неглубокая проверка на равенство.</p>

      function deepEqual(object1, object2) {
        const keys1 = Object.keys(object1);
        const keys2 = Object.keys(object2);
        if (keys1.length !== keys2.length) {
          return false;
        }
        for (const key of keys1) {
          const val1 = object1[key];
          const val2 = object2[key];
          const areObjects = isObject(val1) && isObject(val2);
          if (
            areObjects && !deepEqual(val1, val2) ||
            !areObjects && val1 !== val2
          ) {
            return false;
          }
        }
        return true;
      }
      function isObject(object) {
        return object != null && typeof object === 'object';
      }

  <p>Выделенная строка areObjects && !deepEqual(val1, val2) указывает на то, что, как только сравниваемые свойства становятся объектами, начинается рекурсивный вызов для проверки равенства вложенных объектов.</p>

  <p>Для глубокого сравнения рекомендуется использовать:</p>

      isDeepStrictEqual(object1, object2) of Node built-in util module
      or _.isEqual(object1, object2) of lodash library.


  <h2>Сравнение с помощью JSON.stringify()</h2>
  <p>Простой путь: </p>

    function deep_clone(a){
      return JSON.parse(JSON.stringify(a));
    };
    function is_equal(a,b){
        return JSON.stringify(a) === JSON.stringify(b);
    };

  <p>JavaScript не гарантирует порядок ключей. 
    Если они вводятся в одном и том же порядке, этот подход будет работать в большинстве случаев, но он не будет надежным.
    Кроме того, он вернет false для объектов, которые глубоко равны, но чьи ключи вводятся в другом порядке:
  </p>

    JSON.stringify({ a: 1, b: 2}) === "{"a":1,"b":2}"

    JSON.stringify({ b: 2, a: 1}) === "{"b":2,"a":1}"


  <p>Обьект с сортировкой: </p>

    JSON.stringify(sortMyObj, Object.keys(sortMyObj).sort());

  <p>Однако этот метод удаляет любые вложенные объекты, на которые нет ссылок, и не применяется к объектам внутри массивов. Вы также захотите сделать flat для объекта сортировки.</p>



  <h2>Итог:</h2>
  <ul>
    <li>Ссылочное равенство (с использованием ===, == или Object.is()) определяет, являются ли операнды одним и тем же экземпляром объекта.</li>
    <li>Ручная проверка на равенство требует ручного сравнения значений свойств. Хотя эта проверка требует написания свойств для сравнения вручную, я нахожу этот подход удобным из-за его простоты.</li>
    <li>Когда сравниваемые объекты имеют много свойств или структура объектов определяется во время выполнения, лучшим подходом является использование поверхностной проверки.</li>
    <li>Наконец, если у сравниваемых объектов есть вложенные объекты, лучше всего использовать глубокую проверку на равенство.</li>
  </ul>
</details>

<details>
<summary>30. Модули в JS?</summary>
<div>
  <p>Модуль – это просто файл. Один скрипт – это один модуль.</p>

  <p>Так как модули поддерживают ряд специальных ключевых слов, и у них есть ряд особенностей, то необходимо явно сказать браузеру, что скрипт является модулем, при помощи атрибута .</p>

    <script type="module">
  <p>Браузер автоматически загрузит и запустит импортированный модуль (и те, которые он импортирует, если надо), а затем запустит скрипт.</p>

  <h2>Основные особенности модулей:</h2>
  <h3>Всегда use strict</h3>
  <p>В модулях всегда используется режим use strict. Например, присваивание к необъявленной переменной вызовет ошибку.</p>
  <p>В модуле на верхнем уровне this не определён (undefined).</p>

    <script type="module">
      a = 5; // ошибка
    </script>
  
  <h3>Своя область видимости переменных:</h3>
  <p>Каждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.</p>
  <p>Модули должны экспортировать функциональность, предназначенную для использования извне. А другие модули могут её импортировать.</p>
  <p>В браузере также существует независимая область видимости для каждого скрипта </p>

    <script type="module">:

  <h3>Код в модуле выполняется только один раз при импорте:</h3>

  <p>Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.</p>

  <p>На практике, задача кода модуля – это обычно инициализация, создание внутренних структур данных, а если мы хотим, чтобы что-то можно было использовать много раз, то экспортируем это.</p>

  <p>Такое поведение позволяет конфигурировать модули при первом импорте. Мы можем установить его свойства один раз, и в дальнейших импортах он будет уже настроенным.</p>

  <h3>Модули являются отложенными (deffered):</h3>
  <p>Модули всегда выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом defer</p>

  <ul>
    <li>загрузка внешних модулей, таких как <'script type="module" src="...">, не блокирует обработку HTML.</li>
    <li>модули, даже если загрузились быстро, ожидают полной загрузки HTML документа, и только затем выполняются.</li>
    <li>сохраняется относительный порядок скриптов: скрипты, которые идут раньше в документе, выполняются раньше.</li>
  </ul>

  <p>Как побочный эффект, модули всегда видят полностью загруженную HTML-страницу, включая элементы под ними.</p>

  <h3>Атрибут async работает во встроенных скрпитах:</h3>
  <p>Для не-модульных скриптов атрибут async работает только на внешних скриптах. Скрипты с ним запускаются сразу по готовности, они не ждут другие скрипты или HTML-документ.</p>

  <p>Для модулей атрибут async работает на любых скриптах.</p>

  <p>Например, в скрипте ниже есть async, поэтому он выполнится сразу после загрузки, не ожидая других скриптов.</p>

  <p>Скрипт выполнит импорт (загрузит ./analytics.js) и сразу запустится, когда будет готов, даже если HTML документ ещё не будет загружен, или если другие скрипты ещё загружаются.</p>

  <p>Это очень полезно, когда модуль ни с чем не связан, например для счётчиков, рекламы, обработчиков событий.</p>

    <!-- загружаются зависимости (analytics.js) и скрипт запускается -->
    <!-- модуль не ожидает загрузки документа или других тэгов <script> -->
    <script async type="module">
      import {counter} from './analytics.js';

      counter.count();
    </script>

  <h3>Внешние скрипты:</h3>
  <p>Внешние скрипты с атрибутом type="module" имеют два отличия:</p>

  <p>1. Внешние скрипты с одинаковым атрибутом src запускаются только один раз:</p>

    <!-- скрипт my.js загрузится и будет выполнен только один раз -->
    <script type="module" src="my.js"></script>
    <script type="module" src="my.js"></script>

  <p>2. Внешний скрипт, который загружается с другого домена, требует указания заголовков CORS. Другими словами, если модульный скрипт загружается с другого домена, то удалённый сервер должен установить заголовок Access-Control-Allow-Origin означающий, что загрузка скрипта разрешена.</p>

    <!-- another-site.com должен указать заголовок Access-Control-Allow-Origin -->
    <!-- иначе, скрипт не выполнится -->
    <script type="module" src="http://another-site.com/their.js"></script>

  <p>Это обеспечивает лучшую безопасность по умолчанию.</p>

  <h2>Инструменты сборки:</h2>
  <p>В реальной жизни модули в браузерах редко используются в «сыром» виде. Обычно, мы объединяем модули вместе, используя специальный инструмент, например Webpack и после выкладываем код на рабочий сервер.</p>

  <p>Одно из преимуществ использования сборщика – он предоставляет больший контроль над тем, как модули ищутся, позволяет использовать «голые» модули и многое другое «своё», например CSS/HTML-модули.</p>

  <p>Сборщик делает следующее:</p>
  <ul>
    <li>1. Берёт «основной» модуль, который мы собираемся поместить в <'script type="module"> в HTML.</li>
    <li>2. Анализирует зависимости (импорты, импорты импортов и так далее)</li>
    <li>3. Собирает один файл со всеми модулями (или несколько файлов, это можно настроить), перезаписывает встроенный import функцией импорта от сборщика, чтобы всё работало. «Специальные» типы модулей, такие как HTML/CSS тоже поддерживаются.</li>
    <li>В процессе могут происходить и другие трансформации и оптимизации кода:</li>
    <ul>
      <li>Недостижимый код удаляется.</li>
      <li>Неиспользуемые экспорты удаляются («tree-shaking»)</li>
      <li>Специфические операторы для разработки, такие как console и debugger, удаляются.</li>
      <li>Современный синтаксис JavaScript также может быть трансформирован в предыдущий стандарт, с похожей функциональностью, например, с помощью Babel.</li>
      <li>Полученный файл можно минимизировать (удалить пробелы, заменить названия переменных на более короткие и т.д.).</li>
    </ul>
  </ul>

  <p>Если мы используем инструменты сборки, то они объединяют модули вместе в один или несколько файлов, и заменяют import/export на свои вызовы. Поэтому итоговую сборку можно подключать и без атрибута type="module", как обычный скрипт:</p>

    <!-- Предположим, что мы собрали bundle.js, используя например утилиту Webpack -->
    <script src="bundle.js"></script>

  <p>Хотя и «как есть» модули тоже можно использовать, а сборщик настроить позже при необходимости.</p>

  <h2>Async/defer</h2>
  <h3>defer</h3>
  <p>Атрибут defer сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда DOM дерево будет полностью построено.</p>
  <ul>
    <li>Скрипты с defer никогда не блокируют страницу.</li>
    <li>Скрипты с defer всегда выполняются, когда дерево DOM готово, но до события DOMContentLoaded.</li>
  </ul>

  <h3>async</h3>
  <p>Атрибут async означает, что скрипт абсолютно независим:
    <ul>
      <li>Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.</li>
      <li>Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга:</li>
        <ul>
          <li>DOMContentLoaded может произойти как до асинхронного скрипта (если асинхронный скрипт завершит загрузку после того, как страница будет готова)</li>
          <li>…так и после асинхронного скрипта (если он короткий или уже содержится в HTTP-кеше)</li>
        </ul>
      <li>Остальные скрипты не ждут async, и скрипты casync не ждут другие скрипты.</li>
      <li>Так что если у нас есть несколько скриптов с async, они могут выполняться в любом порядке. То, что первое загрузится – запустится в первую очередь</li>
    </ul>
  </p>


  <p>У async и defer есть кое-что общее: они не блокируют отрисовку страницы. Так что пользователь может просмотреть содержимое страницы и ознакомиться с ней сразу же.

  Но есть и значимые различия:</p>
  | Тип   | Порядрк    | DOMContentLoaded |
  |-------|------------|-----------------------------------------------------------------------------------|
  | async | Порядок загрузки (кто загрузится первым, тот и сработает).	| Не имеет значения. Может загрузиться и выполниться до того, как страница полностью загрузится. Такое случается, если скрипты маленькие или хранятся в кеше, а документ достаточно большой. |
  | defer | Порядок документа (как расположены в документе). | Выполняется после того, как документ загружен и обработан (ждёт), непосредственно перед DOMContentLoaded. |
  <h2>Итого:</h2>
  <p></p>

  <ul>
    <li>1. Модуль – это файл. Чтобы работал import/export, нужно для браузеров указывать атрибут <'script type="module">. У модулей есть ряд особенностей:</li>
    <ul>
      <li>Отложенное (deferred) выполнение по умолчанию.</li>
      <li>Атрибут async работает во встроенных скриптах.</li>
      <li>Для загрузки внешних модулей с другого источника, он должен ставить заголовки CORS.</li>
      <li>Дублирующиеся внешние скрипты игнорируются.</li>
    </ul>
    <li>2. У модулей есть своя область видимости, обмениваться функциональностью можно через import/export.</li>
    <li>3. В модулях всегда включена директива use strict.</li>
    <li>4. Код в модулях выполняется только один раз. Экспортируемая функциональность создаётся один раз и передаётся всем импортёрам.</li>
  </ul>
  <p>Когда мы используем модули, каждый модуль реализует свою функциональность и экспортирует её. Затем мы используем import, чтобы напрямую импортировать её туда, куда необходимо. Браузер загружает и анализирует скрипты автоматически.</p>

  <p>В реальной жизни часто используется сборщик Webpack, чтобы объединить модули: для производительности и других «плюшек»</p>
</div>
</details>




<details>
  <summary>31. OOP в JavaScript?</summary>
  <div>
  <h2>Инкапсуляция:</h2>
  <p>Инкапсуляция включает в себя идею о том, что данные объекта не должны быть напрямую доступны. Нужно вызывать методы вместо прямого доступа к данным. Инкапсуляция позволяет нам скрывать/показывать свойства функций.</p>
  <p>Инкапсуляция с использованием замыкания</p>

    const createCounter = () => {
      // Переменная, определенная в области действия фабрики или конструктора
      // является приватной для этой функции.
      let count = 0;

      return ({
        // Любые другие функции, определенные в той же области, являются привилегированными:
        // Они имеют доступ к закрытой переменной `count`
        // определенной в любом месте их цепочки областей видимости (содержащей области действия функции).
        click: () => count += 1,
        getCount: () => count.toLocaleString()
      });
    };

    const counter = createCounter();

    counter.click();  

  <h2>Абстракция: </h2>
  <p>Абстракция - это способ создания простой модели, которая содержит только важные свойства с точки зрения контекста приложения, из более сложной модели. Иными словами - это способ скрыть детали реализации и показать пользователям только функциональность. Абстракция игнорирует нерелевантные детали и показывает только необходимые. Важно помнить, что мы не можем создать экземпляр абстрактного класса.

  Всё программное обеспечение - это абстракция, скрывающая всю тяжелую работу и бездумные детали.
  
  Процесс декомпозиции - это процесс абстракции. Успешная абстракция подразумевает, что результатом является набор независимо полезных и перекомпонованных компонентов.
  </p>

  <h2>Полиморфизм:</h2>
  <p>Само слово означает много форм. Существует много толкований того, что именно оно означает, но идея заключается в способности вызывать один и тот же метод для разных объектов, и при этом каждый объект реагирует по-своему.

  Чтобы это произошло полиморфизм использует наследование</p>
  <p>Способность объекта принимать различные формы. Например, функция может быть перегружена с тем же именем, но разными параметрами. </p>

  <h2>Наследование: </h2>
  <p>Наследование - это механизм базирования объекта или class на другом объекте (наследование на основе прототипа) или class (наследование на основе класса). Мы избегаем необходимости переписывать один и тот же код, а также экономим пространство памяти, используя общие методы.</p>

  

  </div>

</details>




<details>
<summary>32. Разница между Prototypal Inheritance vs Classical Inheritance?</summary>
<div>
  <p>Экземпляры обычно создаются с помощью функций-конструкторов с ключевым словом `new`. Наследование классов может использовать или не использовать ключевое слово class из ES6. Классы, какими вы их знаете из таких языков, как Java, технически не существуют в JavaScript. Вместо этого используются функции конструктора. Ключевое слово `class` ES6 преобразует сахар в функцию-конструктор:</p>

    class Foo {}
    typeof Foo // 'function'

  <p>В JavaScript наследование классов реализовано поверх прототипного наследования, но это не значит, что оно делает то же самое:</p>

  <h3>Prototypal Inheritance</h3>
  <p>Программирование на основе прототипов - это стиль объектно-ориентированного программирования, в котором повторное использование поведения (известное как наследование) выполняется через процесс повторного использования существующих объектов посредством делегирования, которые служат как prototypes. Сторонники программирования на основе прототипов утверждают, что данный стиль поощряет программиста сосредоточиться на поведении некоторого набора примеров и лишь позднее, беспокоиться о классификации этих объектов в архетипические объекты, которые впоследствии используются аналогично классам.</p>
  <p>Наследование прототипов: прототип — это экземпляр рабочего объекта. Объекты наследуют напрямую от других объектов.</p>
  <p>Экземпляры могут состоять из множества различных исходных объектов, что обеспечивает простое выборочное наследование и плоскую иерархию делегирования [[Prototype]].</p>


  <h3>Classical Inheritance</h3>
  <p>Программирование на основе классов, или же, ориентация на классы, - это стиль объектно-ориентированного программирования (ООП), в котором наследование происходит через определение классов объектов, вместо наследования, которое происходит только через объекты.

  Tight Coupling (сильная связанность) относится к волновым эффектам, которые могут произойти с подклассами (дочерние классы), когда вносится изменение в суперкласс (родительский класс).</p>

  <p>Наследование классов JavaScript использует цепочку прототипов, чтобы связать дочерний `Constructor.prototype` с родительским `Constructor.prototype` для делегирования. Обычно также вызывается конструктор `super()`. Эти шаги формируют иерархию родитель/потомок с одним предком и создают самую тесную связь, доступную в объектно-ориентированном дизайне.</p>


  <h3>Особенности классового наследования:</h3>
  <ul>
    <li>Tight Coupling может привести ко многим непреднамеренным эффектам для подклассов.</li>
    <li>Tight Coupling может помочь избежать повторений в коде.</li>
    <li>Хрупкая проблема базового класса является фундаментальной архитектурной проблемой систем объектно-ориентированного программирования, в которых базовые классы (суперклассы) считаются «хрупкими», потому что, казалось бы, безопасные модификации базового класса, когда они наследуются производным классом, могут привести к сбоям в работе производных классов.</li>
    <li>Проблема гориллы с бананом относится к проблеме наследования слишком много от суперкласса. «Будто тебе нужен банан, а ты получаешь банан в придачу с гориллой в джунглях».</li>
    <li>Классическое наследование требует превосходного предвидения, чтобы избежать проблем неправильного наследования.</li>
  </ul>
  <h3>Особенности prototype наследования:</h3>
  <p><b>Concatenative inheritance:</b> процесс прямого наследования функций от одного объекта к другому путем копирования свойств исходных объектов. В JavaScript исходные прототипы обычно называют mixins. Начиная с ES6, эта функция имеет удобную утилиту в JavaScript, называемую `Object.assign()`. До ES6 это обычно делалось с помощью `.extend()` Underscore/Lodash.</p>
  <p></b>Prototype delegation:</b>В JavaScript объект может иметь ссылку на прототип для делегирования. Если свойство не найдено в объекте, поиск делегируется прототипу делегата, который может иметь ссылку на собственный прототип делегата, и так далее по цепочке, пока вы не дойдете до `Object.prototype`, который является корнем делегировать. Это прототип, который подключается, когда вы присоединяетесь к `Constructor.prototype` и создаете экземпляр с помощью `new`. Вы также можете использовать Object.create() для этой цели и даже смешивать эту технику с конкатенацией, чтобы свести несколько прототипов к одному делегату или расширить экземпляр объекта после создания.</p>
  <h3></h3>
  <p><b>Functional inheritance:</b>В JavaScript любая функция может создать объект. Когда эта функция не является конструктором (или `классом`), она называется factory функцией. Функциональное наследование работает, создавая объект из фабрики и расширяя созданный объект, назначая ему свойства напрямую (используя конкатенативное наследование). </p>

  <p>Как вы, вероятно, начинаете понимать, конкатенативное наследование — это секретный соус, который делает возможной композицию объектов в JavaScript, что делает как делегирование прототипов, так и функциональное наследование намного более интересными.
  Когда большинство людей думают о прототипном ОО в JavaScript, они думают о делегировании прототипа. К настоящему времени вы должны увидеть, что они многое упускают. Прототипы делегатов — не лучшая альтернатива наследованию классов, лучшаяя это композиция объектов.</p>

  <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9">Master the JavaScript Interview: What’s the Difference Between Class & Prototypal Inheritance?</a>
</div>
</details>

<details>
<summary>33. JavaScript ES6?</summary>
<div>

  <p>ECMAScript 2015 — это шестая редакция стандарта спецификации языка ECMAScript, который используется при реализации JavaScript. Чтобы запустить код ES6 в современном браузере, мы используем BABEL. BABEL — это транспилятор для JavaScript, который позволяет запускать код ES6 в любом браузере.</p>

  <h2>let & var</h2>
  <p>Одна из самых больших проблем с ключевым словом var заключается в том, что оно позволяет перезаписывать значения переменной.</p>
  <p>Если вы не хотите переприсваивать значение переменной, в этом случае мы выбираем ключевое слово let. ключевое слово let в ES6 поддерживает облочную область видимости, в которой область действия переменной ограничена блоком. В случае, если вы объявляете переменную с помощью ключевого слова var, область действия переменной может быть либо внутри функции, либо она может быть глобальной.</p>

  <h2>const</h2>
  <p>Добавлена read-only переменная  const.</p>

  <h2>Template literals</h2>
  <p>В ES6 появилась новая функция, называемая литералами шаблонов, для объединения или создания новых строк. Мы используем обратные галочки (``) для встраивания выражения. Placeholders представлены с помощью ${expression}</p>

  <h2>Spread and Rest operator</h2>
  <p>Оператор Rest позволяет нам представить количество аргументов в виде массива. Оператор Rest обозначается как (...args)</p>

    function sum(...theArgs) {
      return theArgs.reduce((previous, current) => {
        return previous + current;
      });
    }
    console.log(sum(1, 2, 3)); // output 6

  <p>Оператор spread ... используется для расширения или расширения итерируемого объекта или массива.</p>

    const arrValue = ['My', 'name', 'is', 'Jack'];

    console.log(arrValue);   // ["My", "name", "is", "Jack"]
    console.log(...arrValue); // My name is Jack


  <h2>Destructuring assignment</h2>

  <p>Деструктуризация позволяет нам извлекать значения в отдельные переменные из массива или объекта. Это позволяет нам присваивать значение левой стороне присваивания из массива или объекта.</p>
    
    const point = [10, 25, -34];

    const [x, y, z] = point;

    console.log(x, y, z); // 10 25 -34

    const [a, b,,, c] = [1, 2, 3, 4, 5, 6];
    console.log(a, b, c); // 1, 2, 5

  <h2>Arrow functions</h2>
  <p>Стрелочные функции — одна из примечательных особенностей ES6. Его поведение чем-то похоже на обычные функции, но синтаксически отличается.
  Это делает код очень четким и лаконичным.</p>

  <h2>Default parameters in ES6 </h2>
  <p>ES6 представил параметры по умолчанию для создания более гибких функций. Параметры по умолчанию возвращаются, когда параметр отсутствует для функции</p>

    function greeting(name = "Anonymous") {
      return "Hello " + name;
    }
    console.log(greeting("Dave")); // Hello Dave
    console.log(greeting()); // Hello Anonymous

  <h2>Classes in ES6</h2>
  <p>ES6 предоставляет новый способ создания объектов с использованием ключевого слова class. Использование синтаксиса класса предназначено только для синтаксиса, и это не традиционные классы, это просто функция. </p>\

    class myclass{
      constructor(){
        this.a = 2
      }
    }
    var myobj = new myclass();
    console.log(typeof myclass)// function

  <h2>Modules in ES6 </h2>
  <p>Модули — одна из самых важных функций в ES6. В ES6 каждый модуль определяется в собственном файле. функции и переменные в одном модуле не видны другому модулю, если они не были экспортированы.</p>

  <p>Чтобы экспортировать определенные переменные из модуля, вы просто используете экспорт ключевого слова. Точно так же, чтобы использовать экспортированные переменные в другом модуле, вы используете import.</p>

    //random.js
    function generateRandom() {
        return Math.random();
    }

    function multiply(a, b) {
        return a * b;
    }

    export { generateRandom, multiply}


    //app.js
    import { generateRandom, multiply} from 'utility';

    console.log(generateRandom()); //logs a random number
    console.log(multiply(1, 2)); //2

  <h2>Promises in ES6</h2>
  <p>Promise — это объект, который даст одно значение, которое может быть либо разрешенным, либо неразрешенным значением. Он находится в трех состояниях: выполнено, отклонено или ожидает выполнения. Обратные вызовы могут быть прикреплены к promise, чтобы узнать причину разрешенного или неразрешенного значения.</p>

    var wait1000 = new Promise(function(resolve, reject) {
      setTimeout(resolve, 1000);
    }).then(function() {
      console.log("Yay!");
    });
  <a href="https://medium.com/javascript-scene/how-to-learn-es6-47d9a1ac2620">How to Learn ES6</a>
</div>
</details>



<br/>

**Patterns**:

<details>
<summary>1. Singleton pattern?</summary>
<div>
  <p>
  <p>
</div>
</details>



<details>
  <summary>2. Decorator pattern?</summary>
  <div>
  <p>Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией.</p>
  <p>Обычно безопасно заменить функцию или метод декорированным, за исключением одной мелочи. Если исходная функция предоставляет свойства, такие как func.calledCount или типа того, то декорированная функция их не предоставит. Потому что это обёртка. Так что нужно быть осторожным в их использовании. Некоторые декораторы предоставляют свои собственные свойства.</p>
  <p>Декораторы можно рассматривать как «дополнительные возможности» или «аспекты», которые можно добавить в функцию. Мы можем добавить один или несколько декораторов. И всё это без изменения кода оригинальной функции!</p>
  <p>Для реализации cachingDecorator мы изучили методы:</p>
  <b>func.call(context, arg1, arg2…) – вызывает func с данным контекстом и аргументами.</b>
  <b>func.apply(context, args) – вызывает func, передавая context как this и псевдомассив args как список аргументов.</b>
  <p>В основном переадресация вызова выполняется с помощью apply:</p>

      let wrapper = function(original, arguments) {
        return original.apply(this, arguments);
      };

  <p>Мы также рассмотрели пример заимствования метода, когда мы вызываем метод у объекта в контексте другого объекта. Весьма распространено заимствовать методы массива и применять их к arguments. В качестве альтернативы можно использовать объект с остаточными параметрами ...args, который является реальным массивом.</p>
  </div>
</details>

<details>
<summary>3. Observer pattern?</summary>
<div>
  <p>В JavaScript часто возникает проблема. Вам нужен способ обновлять части страницы в ответ на определенные события с данными, которые они предоставляют. Скажем, например, пользовательский ввод, который вы затем проецируете на один или несколько компонентов. Это приводит к большому количеству push-and-pull в коде, чтобы все было синхронно.</p>

  <h2>The event observer:</h2>

    EventObserver
    │ 
    ├── subscribe: adds new observable events
    │ 
    ├── unsubscribe: removes observable events
    |
    └── broadcast: executes all events with bound data

  <p>Начните с пустого списка наблюдаемых событий и делайте это для каждого нового экземпляра.</p>

    class EventObserver {
      constructor() {
        this.observers = [];
      }
    }

  <h2>The Subscribe Method:</h2>

    subscribe(fn) {
      this.observers.push(fn);
    }

  <p>Возьмите список наблюдаемых событий и поместите новый элемент в массив. Список событий — это список функций обратного вызова.</p>

  <h2>The Unsubscribe Method:</h2>

    unsubscribe(fn) {
      this.observers = this.observers.filter((subscriber) => subscriber !== fn);
    }

  <p>Отфильтруйте из списка все, что соответствует функции обратного вызова. Если совпадений нет, обратный вызов остается в списке. Фильтр возвращает новый список и переназначает список наблюдателей.</p>

  <h2>The Broadcast Method:</h2>
  <p>Для вызова всех events:</p>

    broadcast(data) {
      this.observers.forEach((subscriber) => subscriber(data));
    }

  <p>Перебираем список наблюдаемых событий и выполняем все обратные вызовы. При этом мы получаем необходимое отношение «один ко многим» с подписанными событиями. Мы передаем параметр data, который связывает колбэки.</p>


    class EventObserver {
      constructor() {
        this.observers = [];
      }

      subscribe(fn) {
        this.observers.push(fn);
      }

      unsubscribe(fn) {
        this.observers = this.observers.filter((subscriber) => subscriber !== fn);
      }

      broadcast(data) {
        this.observers.forEach((subscriber) => subscriber(data));
      }
    }

    const getWordCount = (text) => text ? text.trim().split(/\s+/).length : 0;

    const wordCountElement = document.createElement('p');

    wordCountElement.className = 'wordCount';
    wordCountElement.innerHTML = 'Word Count: <strong id="blogWordCount">0</strong>';
    document.body.appendChild(wordCountElement);

    const blogObserver = new EventObserver();

    blogObserver.subscribe((text) => {
      const blogCount = document.getElementById('blogWordCount');

      blogCount.textContent = getWordCount(text);
    });

    const blogPost = document.getElementById('blogPost');

    blogPost.addEventListener('keyup', () => blogObserver.broadcast(blogPost.value));

  <p>The observer pattern может помочь вам решить реальные проблемы в JavaScript. Он решает извечную проблему синхронизации множества элементов с одними и теми же данными. Как это часто бывает, когда браузер запускает определенные события.</p>



  <a href="https://www.sitepoint.com/javascript-design-patterns-observer-pattern/">JavaScript Design Patterns: The Observer Pattern</a>
</div>
</details>

<details>
<summary>4. Observer pattern RxJs (deprecated)?</summary>
<div>
  <h3>Observable:</h3>
  <p>Observable объекты — это объекты, которые могут выдавать данные в течение некоторого времени. Вы можете думать об этом как о функции, которая возвращает поток данных наблюдателям синхронно или асинхронно. Количество данных, возвращаемых потоком, варьируется от нуля до бесконечности.</p>

  <h3>Observers & Subscriptions:</h3>
  <p>Чтобы Observable работал, ему нужен Observer и подписка. Observer — это потребитель значений, предоставляемых Observable.

  Подписка служит связующим звеном между Observable и Observer: Observer подключается к Observable через метод subscribe().</p>

  <h3>Observable lifecycle:</h3>
  <ul>
    <li>Creation</li>
    <li>Subscription</li>
    <li>Execution</li>
    <li>Disposal</li>
  </ul>

  <h3>Creating Observable:</h3>
  <p>Обратите внимание, что каждая подписка приводит к отдельному выполнению Observable. Несколько наблюдателей, которые подписались на один и тот же Observable, никак не связаны между собой.

  Observable создает n-значений (синхронно или асинхронно), которые доставляются подписчику во время выполнения. Существует три типа значений, которые может предоставить Observable Execution:</p>

  <ul>
    <li>"next": отправляет значение, такое как число, строка, объект и т. д. Количество «следующих» уведомлений не ограничено.</li>
    <li>"error": отправляет ошибку или исключение JavaScript.</li>
    <li>"Complete": не отправляет значение, служит сигналом об успешном завершении Observable. Вы не можете передавать значения с этим уведомлением!</li>
  <ul>

  <p>Состояния Complete и error являются окончательными. Это означает, что Observables не может выдавать никаких данных после доставки этих уведомлений.</p>

  <h3>Hot & Cold Observables:</h3>
  <ul>
    <li>Если данные генерируются самим Observable, мы называем его «холодным» Observable;</li>
    <li>Если данные генерируются вне Observable, мы называем это «горячим».</li>
  </ul>

  <p><b>COLD</b> По умолчанию Observable ленивы — выполнение Observable происходит только для каждого наблюдателя, который подписывается. Observable запускает новое выполнение для каждого подписчика, данные между ними не распределяются.</p>

  <p><b>HOT</b> Чтобы превратить холодный Observable в горячий, нам просто нужно перенести генерацию данных за пределы Observable. </p>

  <p>Чаще всего,  лучше держать Observables холодными, если только:</p>
  <ul>
    <li>Вам нужна возможность иметь n-подписчиков, которые будут получать одни и те же данные</li>
    <li>Вы имеете дело с новым экземпляром. Например, подключение по WebSocket: вы, вероятно, не хотите создавать отдельное подключение для каждого нового подписчика. Вместо этого вы хотели бы использовать одно соединение между ними всеми.</li>
  </ul>

  <a href="https://www.akveo.com/blog/an-introduction-to-rxjs-things-you-need-to-know-in-2022">RxJs obserables</a>
</div>
</details>


<br/>

**React**:

<details>
<summary>1. Что такое React?</summary>
<div>
  <p>
   React это *открытая (с открытым исходным кодом) JavaScript-библиотека для фронтенда*, предназначенная для создания пользовательских интерфейсов, особенно, если речь идет о создании одностраничного приложения. Она отвечает за слой представления (view layout в Model View Controler) в веб и мобильных приложениях. React был создан [Jordan Walke](https://github.com/jordwalke), разработчиком программного обеспечения из Facebook. React был представлен на Facebook News Feed в 2011 году, а для Instagram - в 2012 году.
   </p>
   <p>
    <a>Основными особенностями React является следующее:</a> <br>
    1. Использование *VirtualDOM* (виртуальной объектной модели документа) вместо *RealDOM* (настоящий или реальный DOM), поскольку манипуляции с *RealDOM* являются дорогостоящими с точки зрения производительности<br>
    2. Поддержка *рендеринга на стороне сервера* (Server Side Rendering, SSR)<br>
    3. Следование принципу *однонаправленного* потока данных. Данные передаются от родителя к ребенку, сверху вниз. При этом props — неизменяемый объект, предназначенный только для чтения.<br>
    4. Использование *переиспользуемых/компонуемых* компонентов пользовательского интерфейса <br>
   </p>
</div>
</details>

<details>
<summary>2. Основные принципы работы с React JS?</summary>
<div>
  <p>Ключевые особенности React: декларативность, универсальность, компонентный подход, виртуальный DOM, JSX. </p>


  <a>Декларативность:</a></br>
  <p>Декларати́вное программи́рование — парадигма программирования, в которой задаётся спецификация решения задачи, то есть описывается ожидаемый результат, а не способ его получения.  Декларативное программирование — это как попросить вашего друга нарисовать пейзаж. Тебе все равно, как он рисует, это зависит от него.
</p>

  <a>Универсальность:</a></br>
  <p>Одна из ключевых особенностей React — универсальность. Эту библиотеку можно использовать на сервере и на мобильных платформах с помощью React Native. Это принцип Learn Once, Write Anywhere или «Научитесь один раз, пишите где угодно».


  <a>Composition:</a><br>
  <p>
     Композиция это обьединения частей или елементов в единое целое. Композиция в React JS используется вместо наследования.<br>
     Модель композиции React: <br>
     1. Родитель может знать, а может и не знать кто будет компонентом ребенком в будущем.<br>
     2. Ребенок ни когда не знает кто родитель.<br>
     3. Ребенок ни когда не знает кто его братья и сестры.<br>
     4. Отношения между компонентами проиходят через всем понятный интерфейс (ПРОПСЫ).<br>

  </p>

</div>
</details>

<details>
<summary>3. Что такое JSX(Javascript Syntax Expression)?</summary>
<div>
  *JSX* (JavaScript и XML) - это XML-подобный синтаксис, расширяющий возможности ECMAScript. По сути, он является синтаксическим сахаром для функции `React.createElement()`, совмещая выразительность JavaScript с HTML-подобным синтаксисом разметки. За парсинг и отработку отвечает babel.
  JSX- выражение, это означает, что вы можете использовать JSX внутри операторов if и for, присваивать его переменным, принимать его в качесиве аргументов и возвращать из функций:
   <p> В приведенном ниже примере, текст внутри тега `h1` в методе `render()` возвращается в виде JavaScript-функции: </p>

    
    class App extends React.Component {
      render() {
        return (
             <h1 className="greeting">
               Привет, мир!
             </h1>
          </div>
        )
      }
    }
  
    const element = React.createElement(
    'h1',
    {className: 'greeting'},
    'Привет, мир!'
    );

    
</div>
</details>

<details>
<summary>4.  Что такое Lifting State Up (поднятие) в React??</summary>
<div>
 <p>Часто несколько компонентов должны отражать одни и те же изменяющиеся данные. Мы рекомендуем поднимать общее состояние до ближайшего общего предка. </p>
 <img src="https://res.cloudinary.com/practicaldev/image/fetch/s--vrgvZSMl--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://aviyel.com/assets/uploads/files/1636976926667-image.png" />
</div>
</details>

<details>
<summary>5. Что такое props в React?</summary>
<div>
  <p>
  *Props* - это входные данные для компонента. Это простые значения (примитивы) или объект, содержащий несколько значений, которые передаются компонентам при их создании с помощью синтаксиса, похожего на атрибуты HTML-тегов.

  <p>Основное назначение пропов в React заключается в предоставлении компоненту следующего функционала:</p>

  <p>1. Передача данных компоненту</p>
  <p>2. Вызов изменения состояния</p>
    Создадим элемент со свойством `reactProp`:
  <p>

      <Element reactProp={'1'} />
  </p>
    Этот `reactProp` добавляется в качестве свойства ко встроенному объекту *props*, который присутствет во всех компонентах, созданных с помощью React.
  <p>

     props.reactProp
  </p>  
  </p>
</div>
</details>


<details>
<summary>6. Как работает виртуальный DOM?</summary>
<div>
  
  <img src="https://api.bcode.dev/v1/content/storage/post/100004/a36995c00227434eb59af3dfd8f246c5.png"/>

  <p>🔸 В React каждый пользовательский интерфейс — это отдельный компонент, и у каждого компонента есть свое состояние.</p>
  <p>🔸 React следует observable pattern и наблюдает за изменениями состояний.</p>
  <p>🔸 Всякий раз, когда в состояние какого-либо компонента вносится изменение, React обновляет виртуальное дерево DOM, но не изменяет реальное дерево DOM.</p>
  <p>🔸 После обновления React сравнивает текущую версию виртуального DOM с предыдущей версией.</p>
  <p>🔸 React знает, какие объекты изменяются внутри виртуальном DOM, основываясь на том, что он изменяет только эти объекты в реальном DOM, совершая минимальные манипуляционные операции.</p>
  <p>🔸 Этот процесс отмечен как "diffing". Изображение ниже прояснит концепцию больше.</p>

  <img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/12a/500/0c2/12a5000c239d0c3eb96cd4848e7221a1.jpg"/>

  <a>Эффективный diff алгоритм:</a> 
  <p>Для дерева с числом элементов «n» сложность порядка O(n3). React реализует оптимизированный алгоритм O(n) на основе двух предположений:</p>

   1. Элементы разных типов будут создавать разные деревья. 

  <p>React анализирует дерево с помощью поиска в ширину (Breadth-first search). Для узла дерева, если тип элемента изменен, например, с «section» на «div». React уничтожит все поддерево под этим элементом и восстановит его с нуля.</p>

   1. Разработчик указывает с помощью ключа (key prop), на то какие элементы должны быть стабильны в разных рендерах.

  <p>React будет использовать этот ключ для сопоставления элементов между двумя деревьями и минимизации ненужных мутаций.</p>

</div>
</details>


<details>
<summary>7. Что такое React Fibers?</summary>
<div>
  <p>Fiber - это новый механизм согласования или повторной реализации основного алгоритма в React v16. Цель React Fiber -  увеличении производительности при разработке таких задач как анимация, организация элементов на странице и движение элементов. Ее главная особенность это инкрементный рендеринг: способность разделять работу рендера на единицы и распределять их между множественными фреймами.
</div>
</details>


<details>
<summary>8. Согласование в React?</summary>
<div>
  <p>Каждый раз, когда происходит изменение в состоянии компонента, запускается механизм, именуемый "согласование" (reconciliation), который вычисляет разницу (дифф) между прошлым состоянием и новым. С алгоритмической точки зрения происходит поиск отличий в двух деревьях. В общем случае алгоритм, выполняющий это вычисление, работает со сложностью O(n3).</p>
  <img src="https://api.bcode.dev/v1/content/storage/post/100004/a36995c00227434eb59af3dfd8f246c5.png"/>
</div>
</details>


<details>
<summary>9. В чем разница между теневым (Shadow) и виртуальным DOM?</summary>
<div>
  <p>*Shadow DOM* - это браузерная технология, спроектированная для ограничения области видимости переменных и CSS в *веб-компонентах*. Используется для инкапсуляции.</p>
</div>
</details>

<details>
<summary>10. В чем разница между настоящим и виртуальным DOM?</summary>
<div>
Ниже представлены основные отличие между реальным и виртуальным DOM:

| Реальный DOM | Виртуальный DOM |
| ----- | ------- |
| Обновления медленные | Обновления быстрые |
| Манипуляции с DOM очень дорогостоящие | Манипуляции с DOM не очень дорогие |
| Вы можете обновлять HTML напрямую | Вы не можете обновлять HTML напрямую |
| Активная работа с DOM часто приводит к утечкам памяти | Утечки памяти практически полностью исключены |
| При обновлении элемента создается новая DOM | При изменении элемента обновляется только JSX |
</div>
</details>

<details>
<summary>11. Что такое фрагмент (Fragment)?</summary>
<div>
  <p>
  Это распространенный паттерн в React, который используется в компонентах, возвращающих несколько элементов. *Fragments* позволяют группировать дочерние элементы без создания лишних DOM-узлов:</p>
  <p>

    render() {
      return (
        <React.Fragment>
          <ChildA />
          <ChildB />
          <ChildC />
        </React.Fragment>
      )
    }
  </p>

  <p>Также существует *сокращенный синтаксис*, но он не поддерживается в некоторых инструментах:</p>
  <p>

    render() {
      return (
        <>
          <ChildA />
          <ChildB />
          <ChildC />
        </>
      )
    }
  </p>

  <p>1. Фрагменты немного быстрее и используют меньше памяти. Реальная польза от этого ощущается в очень больших и глубоких деревьях элементов</p>
  <p>2. Некоторые механизмы CSS, например, *Flexbox* и *Grid* используют связь родитель-ребенок (предок-потомок, если угодно), поэтому добавление дополнительных `div` может сломать макет страницы.</p>
  <p>3. Удобнее пользоваться инспектором DOM</p>
  </p>
</div>
</details>



<details>
<summary>12. Что такое `React.memo()`?</summary>
<div>
  <a>Определение React.memo:</a>
  <p>Когда компонент заключен в React.memo(), React рендерит компонент и запоминает результат. Перед следующим рендерингом, если новые пропсы одинаковы, React повторно использует memoизированный результат, пропуская следующий рендеринг.</p>

  <p>React всегда перерисовывает компонент при изменении состояния, даже если компонент обернут в React.memo(). </p>

  ```jsx
  export function Movie({ title, releaseDate }) {
    return (
      <div>
        <div>Movie title: {title}</div>
        <div>Release date: {releaseDate}</div>
      </div>
    );
  }
  export const MemoizedMovie = React.memo(Movie);
  ```

<p>Похожий функционал предоставляет хук `useMemo()`.</p>

<a>Использование кастомного сравнения props:</a>
<p>По-умолчанию мемо делает поверхностное сравнение props. Функцию для кастомного сравнения можно передать вторым параметром:</p>

```jsx
React.memo(Component, [areEqual(prevProps, nextProps)]);
```

<p>Функция areEqual должна вернуть true если пропсы равны.</p>

<a>Когда использовать memo:</a>
<img src="https://dmitripavlutin.com/static/c07d2ce4ede6301197b9605a75ae9b4e/47a22/when-to-use-react-memo-infographic.webp" />
</div>
</details>


<!-- <details>
<summary>13. Какие преимущества предоставляет использование React?</summary>
<div>
  <p>Удобная работа с DOM.  </p>
    <p>Virtual DOM - это древовидная структура JavaScript простых обьектов которая синхронизуется в памяти. Использовать Virtual DOM быстрее потому что он никогда не рендериться для пользователя, он остается только в памяти.   </p>
    <p>Когда приложение React грузится, React создает копию реального DOM дерева. Когда изменяется state вместо того что бы перерисовывать все реально DOM дерево, React сначала обновляет virtual DOM с обновленным state.  </p>
    <p>Потом React сравнивает Virtual DOM vs Real DOM для того что бы узнать что именно должно быть обновлено. После этого только изменяется Real DOM. Только те элементы которые притерпели изменения.  </p>
  </p>
<p>JSX</p>
  <p>JSX используется препроцессорами (например Babel). Для трансформации HTML-like текста в JS файлы в JS обьекты которы будут распрешены.</p>
<p>Components</p>
<p>React components нужны для того что бы сделать код легко переиспользуемым. И разделить весь UI на мелкие и разные части.  </p>
<p>React components работают идентично JS функциям. Они имеют доступ к произвольным входным данным **props**. И должны возвращать элемент описывающий то что мы будет показывать пользователю.</p>

</div>
</details> -->


<details>
<summary>13. Как реализовать рендеринг на стороне сервера или SSR?</summary>
<div>
  <p>React поддерживает рендеринг на стороне Node-сервера из коробки. Для этого используется специальная версия DOM-рендерера, которая реализует такой же паттерн, что и клиентская версия:</p>

   
    import ReactDOMServer from 'react-dom/server'
    import App from './App'

    ReactDOMServer.renderToString(<App />)
    

  <p>Этот метод возвращает обычный HTML в виде строки, которая затем может быть помещена в тело (body) ответа сервера. На стороне клиента React определяет предварительно отрендеренный контент и просто вставляет его в существующее дерево компонентов.
  </p>
</div>
</details>


<details>
<summary>14. Какие методы жизненного цикла компонента существуют в React?</summary>
<div>
<img src='https://cdn-images-1.medium.com/max/1600/1*cPwvUhZrnB1dtZnjBEfXfA.png' />
  <ul>
    <li>
      <b>constructor()</b> - Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. 
      <br>
      Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру.
      <br>
      <b>useState</b> - заменяет конструктор. Служит для управление локальным state у компонента.
    </li>
    <br/>
    <li>
      <b>componentDidMount()</b> - вызывается сразу после монтирования. В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
      <br/>
      Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().
      <br/>
      <b>useEffect(callBack, [])</b> - Инициализируется немедленно после первого рендера, инициализирует state которому могут понадобиться DOM ноды, Network запросы и другие side effects.
    </li>
    <br/>
    <li>
      <b>componentDidUpdate(prevProps, prevState, snapshot)</b> - вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.
      <br>
      <p>

        const mounted = useRef()
        useEffect(() => {
          if(!mounted.current) {
            mounted.current = true
          } else {
            console.log('componentDidUpdate !)
          }

        })

   </p>
    <b>useEffect(callBack)</b> - вызывается и при первом рендере и после обновления. Для эмуляции componentDidUpdate нужна проверка на первый рендер и useRef.
    </li>
    <br/>
    <li>
      <b>componentWillUnmount()</b> - вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().
    </li>
    <br/>
      <b>useEffect(callBack)</b> - return функция. Возвращает функцию которая будет запущена после unmount'a компоненты. Подходит для отмены таймеров, сетевых запросов и подписок.
    <br/>
    <li>
      <b>useRef</b> - предоставляет доступ к DOM елементам созданным при рендере, помогает useEffect симитировать работу componentDidUpdate.
       <p>useRef() - это хук принимающий в качестве аргумента какое то значение и возвращающий референс. Референс это специальный обьект у которого есть свойство current.</p>
       reference.current - предоставляет доступ к значению, reference.current = newValue обновляет значение.<br/>
       1. Значение референса остается не изменным между ререндерами. <br/>
       2. Обновление референса не вызывает ререндер. <br/>
    </li>
    <br/>
    <li>
      <b>useMemo()</b> - сохраняет результат полученной функции между ререндерами и не перезапускает ее до тех пор пока не изменятся зависимости.
       <p>useMemo(compute, dependencies)</b> - принимает на вход два параметра. Compute - функия результат которой надо запомнить. Dependencies - зависимости без изменения которых не будет перезапущена функция compute.</p>
       Если сравнивать useMemo и useCallback то useCallback более специфическая функция для запоминания callback, но useMemo тоже умеет запоминать callback.<br/>
    </li>
    <br/>
    <li>
      <b>useCallback()</b> - при не изменяющемся deps, хук вернет тот же самый instance функции между ререндерами.
       <p>useCallback(callbackFnc, deps)</b> - принимает на вход два параметра. CallbackFnc - функия incstance которой надо запомнить. Deps - зависимости без изменения которых instance функции останется тем же самым.</p>
       Кейсы использования useCallback():<br/>
       <p>1. Функциональная компонента обернута React.memo() и принимает функцию как аргумент.</p>
       <p>2. Когда функция является зависимостью для других hooks, useEffect(..., [callback)]</p>
       <p>3. Когда у функции есть внутреннее состояние, когда функция debounced или throttled.</p>
    </li>
    <br/>
  </ul>
  
  <img src='https://res.cloudinary.com/practicaldev/image/fetch/s--S1NFg-EJ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://miro.medium.com/max/800/1%2AJ1OWWbEDit18yTrM0sthgA.png'/>
  <img src ='https://res.cloudinary.com/practicaldev/image/fetch/s--HiDZKzEO--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://miro.medium.com/max/1000/1%2A2ANppcgcNvccNSsS8fHbnQ.png'/>
</div>
</details>

<details>
<summary>15. Что такое Context в React и для чего он используется?</summary>
<div>
  <br />
  <p>Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык).</p>
  <p>Контекст позволяет избежать передачи пропсов в промежуточные компоненты: 
    
    // Контекст позволяет передавать значение глубоко
    // в дерево компонентов без явной передачи пропсов
    // на каждом уровне. Создадим контекст для текущей
    // UI-темы (со значением "light" по умолчанию).
    const ThemeContext = React.createContext('light');

    class App extends React.Component {
      render() {
        // Компонент Provider используется для передачи текущей
        // UI-темы вниз по дереву. Любой компонент может использовать
        // этот контекст и не важно, как глубоко он находится.
        // В этом примере мы передаём "dark" в качестве значения контекста.
        return (
          <ThemeContext.Provider value="dark">
            <Toolbar />
          </ThemeContext.Provider>
        );
      }
    }

    // Компонент, который находится в середине,
    // теперь не должен явно передавать UI-тему вниз.
    function Toolbar(props) {
      return (
        <div>
          <ThemedButton />
        </div>
      );
    }

    class ThemedButton extends React.Component {
      // Определяем contextType, чтобы получить значение контекста.
      // React найдёт (выше по дереву) ближайший Provider-компонент,
      // предоставляющий этот контекст, и использует его значение.
      // В этом примере значение UI-темы будет "dark".
      static contextType = ThemeContext;
      render() {
        return <Button theme={this.context} />;
      }
    }
  </p>
  <p>Обычно контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных уровнях вложенности. По возможности не используйте его, так как это усложняет переиспользование компонентов.</p>
</div>
</details>



<details>
<summary>16. Для чего нужен атрибут key при рендере списков?</summary>
<div>
  <br />
  <p>
    Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.
  </p>
  <p>
    Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи. Главное что бы ключи были уникальные и не смещались.</p>
    <p>Чаще всего с этой задачей не возникает проблем, так как у любой сущности, с которой мы работаем, есть свой идентификатор (например, primary key из базы данных).
    Так же можно использовать UUID. </p>
    <p>Кстати, key не обрабатывается как обычный проп и его нельзя получить внутри компонента как this.props.key. Если вам нужны данные, которые были переданы в key внутри компонента, то просто передайте их отдельным пропом (например, id):
  </p>
  
</div>
</details>

<details>
<summary>17. Как работает проп children?</summary>
<div>
  <br />
  <p>
    Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод:
    
    function FancyBorder(props) {
      return (
        <div className={'FancyBorder FancyBorder-' + props.color}>
          {props.children}
        </div>
      );
    }
  </p>
    <p>Если внимательно посмотреть на документацию React, то можно увидеть следующее определение children: "children are an opaque data structure" (свойство children – непрозрачная структура данных). Другими словами, нельзя однозначно полагаться на тип этого пропса, так как снаружи можно передать всё что угодно. Подобное поведение может приводить к трудноотловимым ошибкам. Например проверка this.props.children.length это не всегда количество детей. Если children это одиночный элемент, например строка, то свойство length вернет длину этой строки.
  </p>
  <p>
    Это позволит передать компоненту произвольные дочерние элементы, вложив их в JSX:
  
    function WelcomeDialog() {
      return (
        <FancyBorder color="blue">
          <h1 className="Dialog-title">
            Добро пожаловать
          </h1>
          <p className="Dialog-message">
            Спасибо, что посетили наш космический корабль!
          </p>
        </FancyBorder>
      );
    }
  </p>
  <p>
    Всё, что находится внутри JSX-тега <FancyBorder>, передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри div, все переданные элементы отображаются в конечном выводе.
  </p>
</div>
</details>


<details>
<summary>18. В чем разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?</summary>
<div>
  <br />
  <p> В HTML элементы формы, такие как input, textarea и select, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState().
  </p>
  <p>
    В управляемом компоненте с каждой мутацией состояния связана функция-обработчик. Благодаря этому валидация или изменение введённого значения становится простой задачей. Например, если мы хотим, чтобы имя обязательно было набрано заглавными буквами, можно написать такой handleChange:
    
    handleChange(event) {
      this.setState({value: event.target.value.toUpperCase()});
    }
  </p>
  <p>
    Вместо того, чтобы писать обработчик события для каждого обновления состояния, вы можете использовать неуправляемый компонент и читать значения из DOM через реф.
  
    class NameForm extends React.Component {
      constructor(props) {
        super(props);
        this.handleSubmit = this.handleSubmit.bind(this);
        this.input = React.createRef();
      }

      handleSubmit(event) {
        alert('Отправленное имя: ' + this.input.current.value);
        event.preventDefault();
      }

      render() {
        return (
          <form onSubmit={this.handleSubmit}>
            <label>
              Имя:
              <input type="text" ref={this.input} />
            </label>
            <input type="submit" value="Отправить" />
          </form>
        );
      }
    }
  </p>
  <p>
    Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. Поэтому в обычных ситуациях мы рекомендуем использовать управляемые компоненты.
  </p>
  <p>Настройка контролируемого input включает в себя 3 шага: </p>
    1. Создать стейт для хранения значения input: 
    <p>

      [val, setVal] = useState('') 
   </p>
    1. Определить event handler для обновления state когда пользователь вводит данные в input 
    <p> 

      onChange = event => setVal(event.target.value)
   </p>    
    1. Присоединить eventHandler и установить значение аттрибута value на input field: 
    <p>

      <input onChange={onChange} value={val} />.
   </p>
    Debouncing значения input'a в state требует создания нового разделенного состояния с использованием hook'a useDebouncedValue(value, wait):
    <p>  
    
     debouncedQuery = useDebouncedValue(value, wait). 
   </p>
</div>
</details>

<details>
<summary>19. Что такое PureComponent?</summary>
<div>
  <br />
  <p>
    React.PureComponent похож на React.Component. Отличие заключается в том, что React.Component не реализует shouldComponentUpdate(), а React.PureComponent реализует его поверхностным сравнением пропсов и состояния.
  </p>
  <p>
    Если метод render() вашего React-компонента всегда рендерит одинаковый результат при одних и тех же пропсах и состояниях, для повышения производительности в некоторых случаях вы можете использовать React.PureComponent.
  </p>
  <p>
    Метод shouldComponentUpdate() базового класса React.PureComponent делает только поверхностное сравнение объектов. Если они содержат сложные структуры данных, это может привести к неправильной работе для более глубоких различий (то есть, различий, не выраженных на поверхности структуры). Наследуйте класс PureComponent только тогда, когда вы ожидаете использовать простые пропсы и состояние
  </p>
  <p></p>
</div>
</details>

<details>
<summary>20. Что такое state в React?</summary>
<div>
  <br />
  <p>
   State это JavaScript объект, который хранит динамические данные компонента и позволяет компоненту отслеживать изменения между рендерами(render).
  </p>
  <p>
    Ещё раз: крайне важно не изменять state напрямую. Для установки нового состояния в React предусмотрена функция setState. 
    setState() планирует обновления объекта состояния компонента. Когда состояние изменяется, компонент отвечает повторным рендерингом.
     Вызовы setState является асинхронными, когда они находятся внутри обработчиков событий, и когда вы не полагаетесь на this.state, чтобы отобразить новое значение сразу после вызова setState.
  </p>
  <p>
   Общая рекомендация, которую дают разработчики React, это делать структуру максимально плоской, похожей на то, как хранятся данные в базе данных. Причём желательно в хорошо нормализованном виде. Другими словами, не нужно дублировать данные в состоянии. 
  </p>
</div>
</details>

<details>
<summary>21. События в React?</summary>
<div>
  <br />
  <p>
   В любой обработчик события при вызове передаётся объект типа SyntheticEvent, кроссбраузерный "враппер" (обёртка) над нативным объектом события. Интерфейсно он не отличается от нативного, кроме того, что работает одинаково во всех браузерах.

      class Component extends React.Component {
        onClick = (event) => {
          console.log(event); // => SyntheticBaseEvent
          console.log(event.type); // => "click"
        }

        // ...
      }
  </p>
  <p>
    SyntheticEvent хранит в себе оригинальный объект события и предоставляет интерфейс для доступа к его свойствам и методам. Этот интерфейс одинаков для всех браузеров, что крайне удобно с точки зрения разработки. К примеру, необходимо отменить действие по умолчанию (перезагрузку страницы) при отправке формы:

        handleSubmit = (e) => {
          e.preventDefault();
          this.setState({ count: this.state.count + 1 });
        };
  </p>
  <p>
   Точно так же нужно поступать при необходимости предотвратить всплытие события. Только вместо preventDefault вызывается функция stopPropagation.
  </p>
  <p>
    React нормализует события так, что они имеют консистентные свойства в различных браузерах. Кроме того, в формах добавляется событие onChange, которое ведёт себя в соответствии со своим названием и сильно упрощает работу.  
  </p>
  <p><a>stopPropagation</a> предотвращает дальнейшее распространение текущего события на этапах захвата и всплытия.

  <a>preventDefault</a> предотвращает действие браузера по умолчанию для этого события.
  </p>
</div>
</details>

<details>
<summary>22. Что такое Компонент высшего порядка (Higher-Order Component, HOC)?</summary>
<div>
  <br />
  <p>
    Компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент. React Higher Order Component — это паттерн, который проистекает из природы React, которая отдает предпочтение композиции, а не наследованию. HOC часто встречаются в сторонних библиотеках, например connect в Redux и createFragmentContainer в Relay.
    
    HOC — это чистая функция с нулевыми побочными эффектами.
    Помогает для Воспроизведения DRY. Прим. memo.
    const EnhancedComponent = higherOrderComponent(WrappedComponent);
  </p>
  <p>
    Заметьте, что HOC ничего не меняет и не наследует поведение оборачиваемого компонента, вместо этого HOC оборачивает оригинальный компонент в контейнер посредством композиции. HOC является чистой функцией без побочных эффектов.  Оборачиваемый компонент получает все пропсы, переданные контейнеру, а также проп data. Для HOC не важно, как будут использоваться данные, а оборачиваемому компоненту не важно, откуда они берутся.
  </p>

  <H2>Для чего нужны HOC?<H2>

  <p>1. Обеспечения возможности переиспользования кода, логики, а так же начальная загрузка</p>
  <p>2. Перехват рендеринга (RenderHighjacking)</p>
  <p>3. Абстрагирования и манипулирования состоянием</p>
  <p>4. Манипулирования пропами</p>


  <a>Примеры использования: </a>
  <p>1. Для отображения лоадера пока компонент ждет данные. Отслеживает props и пока они пусты будет показывать значек загрузки.</p>
  <p>2. Компоненты которые рендерятся по условию. Когда их props достигают определенных значений.</p>
</div>
</details>

<details>
<summary>23. Хук useState?</summary>
<div>
  <br />
  <p>
    Хук состояния - useState. ASYNC.
    Возвращает массив где первой значение это начальное значение стейт, а второе функция сеттер.
  </p>
  <p>
    Говорит реакту запустить следующую итерацию рендера. Однако реакт так же может оптимизировать процесс. Несколько вызовов useState приведут к одному рендеру.
  </p>
  <br />
      ​ // Toggle a boolean
      ​ const [toggled, setToggled] = useState(false);
    ​   setToggled(toggled => !toggled);
  <p>
    Ленивая инициализация state:
    Каждый раз при ре-рендере компонента реакт запускает useState(initialState). Когда туда передается примитивный тип данных проблем не возникает. Когда initialState требует тяжелых вычислительных операций выгодно передавать в useState саму функцию. 
  </p>

    function MyComponent({ bigJsonData }) {
      const [value, setValue] = useState(function getInitialState() {
        const object = JSON.parse(bigJsonData); // expensive operation
        return object.initialValue;
      });
      // ...
    }
  <p>getInitialState() выполняется только один раз при начальном рендеринге, чтобы получить начальное состояние.

  При более последующих ререндерах компонента getInitialState() не вызывается, пропуская дорогостоящую операцию.</p>

</div>
</details>


<details>
<summary>24. Хук useEffect?</summary>
<div>
  <br />
  <p>
    Для выполнения побочных эффектов, например, прямой работы с DOM в React используется встроенный хук useEffect(). Он заменяет собой три колбека жизненного цикла:
  </p>
      •	componentDidMount()
      •	componentDidUpdate()
      •	componentWillUnmount()

  <br />
  <p>
    Колбек, переданный в useEffect(), отрабатывает после того как изменения будут запущены в дом (Асинхронно). То есть произошло объединение методов componentDidUpdate() и componentDidMount(). Такое изменение было сделано ради удобства. Мировая практика использования React показала, что, в основном, эффекты происходят после каждого рендера, независимо от того, первая эта отрисовка или все последующие.
  </p>
  <p>
    Второй параметр передаваемый в useEffect это массив. Отсуствующий массив - useEffect запускается после каждого ререндера, пустой массив [] - useEffect запускается единождый после инициализирующего рендера,  Массив с зависимостями [state/props] - useEffect запускается при изменении значений переданных в массив state/props.
  </p>

  <p>
      Сброс эффекта:</p>
    <p>В некоторых случаях эффект нужно сбрасывать. Например, когда эффект после изменения пропсов перестает быть актуальным, его нужно "зачистить". Для этого достаточно вернуть функцию из useEffect(), внутри которой выполняется очистка:
  </p>

     // Предположим, что этот эффект зависит от пропса userId
     useEffect(() => {
     const id = setTimeout(/* какой-то код с userId */);

     return () => clearTimeout(id);
    }, [userId]);
</div>
</details>


<details>
<summary>25. Хук ref?</summary>
<div>
  <p>
   useRef() – хранение любых данных между вызовами компонента. Этот хук возвращает обычный объект со свойством current внутри. Единственное отличие этого объекта, от создаваемого вручную { current: ... }, в том, что хук возвращает один и тот же объект при каждом вызове компонента. По своему поведению useRef() похож на использование обычного свойства внутри классового компонента (this.someproperty).
  </p>
</div>
</details>


<details>
<summary>26. Хук useMemo?</summary>
<div>
  <p>
    Встроенный в реакт хук, который запоминает результат выполнения функции. На вход принимается сама  функция и массив ее зависимостей. Во время иницилизирующего рендера хук запоминает результат выполнения функции. Если во время следующих ререндеров зависимости не изменяются useMemo не запустит функцию, но вернет ее результат.
  </p>

      const memoizedResult = useMemo(compute, dependencies);
  <p>
    Но если зависимости изменились useMemo запустит функцию и сохранит ее результат.
    Если callback использует state или props нужно не забыть указать их как зависимости.
  </p>

      const memoizedResult = useMemo(() => {
        return expensiveFunction(propA, propB);
      } , [propA, propB]);

  <p>
    useCallback по сравнению с useMemo более специализированный хук для сохранения callbacks.  useMemo может заменить useCallback:
  </p>

    const callback = () => {
      return 'Result';
    };
    const memoizedCallback = useMemo(() => callback, [prop]);

  <p>Просто обернув callback  в стрелочную функцию.</p>
</div>
</details>


<details>
<summary>27. Хук useCallback?</summary>
<div>
  <p>
   useCallback возвращает один и тот же экземпляр передаваемой функции (параметр 1) вместо создания нового при каждом повторном рендеринге компонента. Новый экземпляр передаваемой функции (параметр 1) может быть создан только при изменении массива зависимостей (параметр 2).
  </p>

      function MyComponent() {
        // handleClick is the same function object
        const handleClick = useCallback(() => {
        console.log('Clicked!');
      }, []);

      // ...
      }
</div>
</details>

<details>
<summary>28. Разница useCallback vs useMemo?</summary>
<div>
  <p>
   useCallback(fn, deps)` это просто `useMemo(() => fn, deps)`
  </p>

  <p>Когда компонент собирается повторно визуализироваться, React сравнивает каждый созданный под его исходным компонентом объект с новой версией этого объекта. И хотя объекты точно такие же, они не указывают на один и тот же объект. React идентифицирует их как разные объекты, позволяя воссоздавать снова и снова при каждом повторном рендеринге.</p>

  <h2>Для чего нужны useCallback и useMemo?</h2>

  <p>Если useCallback и useMemo используются правильно, они необходимы, чтобы предотвратить повторные рендеры и сделать код более эффективным.</p>

  <p>useMemo используется вместо того, чтобы возвращать невызванную функцию, как это делает useCallback – он работает с передаваемой функцией и возвращает результирующее значение только при изменении массива параметров. Другими словами, useMemo вызывает функцию только при необходимости и возвращает кэшированное значение для других визуализаций.</p>

  <p>Когда компонент повторно визуализируется, он создает новые экземпляры всех объектов, включая все функции в нем:

  useCallback – кэширует экземпляр функции между визуализациями.
  useMemo – кэширует значение между визуализациями.</p>



</div>
</details>


<details>
<summary>29. Назовите правила использования хуков?</summary>
<div>
<p>При использовании хуков необходимо соблюдать два правила:</p>

<p>1. Хуки не должны вызываться внутри циклов, условий или вложенных функций. Это позволяет обеспечить одинаковый порядок вызова хуков при повторном рендеринге и сохранять состояние хуков между несколькими вызовами `useState()` и `useEffect()`</p>
<p>2. Хуки можно вызывать только внутри функциональных компонентов React и других хуков, вы не должны вызывать их внутри обычных функций</p>

</div>
</details>

<details>
<summary>30. Что такое порталы в React?</summary>
<div>
  <br />
  <p>
    Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.

    ReactDOM.createPortal(child, container)
  </p>
  <p>
    Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент.
  </p>
  <p>
    Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.
  </p>
  <p><i>Источник: <a href ="https://ru.reactjs.org/docs/portals.html">ru.reactjs.org</a></i></p>
</div>
</details>

<details>
<summary>31. Что такое debounce и throttle?</summary>
<div>
  <br />
  <p>Это две похожие но разные техники контроля за тем сколько раз будет вызвана функция за определенное время.
  </p>
  <p>
  Debounce - возвращает функцию которая может быть вызвана любое количество раз, но будет вызвана только после N ms после вызова идущей перед ней функции.
  </p>
  <p>
  Throttle - возвращает функцию которая может быть вызвана любое количество раз, но будет вызывать callback не чаще одного раза в N ms.
  </p>
  <p>Use case: Поиск города в огромном массиве из всех городов по мере ввода названия города. Каждый поиск является тяжеловестным, что влечет за собой зависания.
  Это означает, что в нашем фильтре городов мы не сможем попросить наш компьютер отфильтровать города с буквами «Sa», пока он все еще пытается сделать то же самое для городов с буквой «S» в названии. Нам придется либо предотвратить второй процесс, либо остановить первый, а затем запустить второй.</p>
</div>
</details>

<details>
<summary>32. Что такое React Reconciliation (Cверка) и как он работает?</summary>
<div>
  <br />
  <p>
    Reconciliation (Cверка) - это процесс, посредством которого React обновляет DOM. В этот процесс входит и Virtual DOM и Diffing алгоритм. Когда состояние компонента изменяется, React должен рассчитать необходимость обновления DOM. Это делается путем создания виртуального DOM и сравнения его с текущим DOM. В этом контексте виртуальный DOM будет содержать новое состояние компонента.
  </p>
  <p>
    При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов. 
  </p>
  <p>
    Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. 
  </p>
  <p>
    При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты.
  </p>
  <p>
    По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие. Эта неэффективность может стать проблемой. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева.
  </p>
</div>
</details>

<details>
<summary>33. Можно создавать анимации в React?</summary>
<div>
  <br />
  <p>
    React может использоваться для создания крутых анимаций! В качестве примера посмотрите библиотеки React Transition Group и React Motion.
  </p>
  <p><i>Источник: <a href ="https://ru.reactjs.org/docs/faq-styling.html#can-i-do-animations-in-react">ru.reactjs.org</a></i></p>
</div>
</details>

<details>
<summary>34. Что такое DRY?</summary>
<div>
  <p> Don’t Repeat Yourself </p>
  <p> Не повторять свой код. Главный из паттернов для поддержания этого принципа High-Order Component. </p>
  <p>Также важно понимать, что DRY нужен не для того, чтобы писать код быстрее. Его задача — упростить чтение и поддержку нашего решения. Поэтому не спешите создавать абстракции сразу. Лучше сделать простую реализацию какой-то части кода, а потом проанализировать, какие абстракции нужно создать, чтобы упростить чтение кода и уменьшить количество мест для изменений, когда они понадобятся.

  <a>Чеклист правильной абстракции:</a>

    1. Имя абстракции полностью соответствует ее назначению
    2. Абстракция выполняет конкретную, понятную задачу
    3. Чтение кода, из которого была выделена абстракция, улучшилось
</p>
</div>
</details>

<details>
<summary>35. Что такое KISS?</summary>
<p>
  KISS — «Оставьте код простым и тупым». Думаю, с понятием простого кода вы знакомы. Но что значит «тупой» код? В моем понимании, это код, который решает задачу, используя минимальное количество абстракций, при этом вложенность этих абстракций друг в друга также минимальна.
</p>
</div>
</details>

<details>
<summary>36. Что такое YAGNI?</summary>
<p>
  YAGNI — «Вам это не понадобится». Код должен уметь делать только то, для чего он написан. Мы не создаем никакой функционал, который может понадобиться потом или который делает приложение лучше на наш взгляд. Делаем только то, что нужно конкретно для реализации поставленной задачи.
</p>
</div>
</details>


<details>
<summary>37. Хук useLayoutEffect?</summary>
<p>
  Согласно официальной документации хук useLayoutEffect по своим параметрам (сигнатуре) полностью идентичен хуку useEffect. Главное же отличие заключается в том, что useLayoutEffect вызывается синхронно, после всех изменений в DOM. Также сами разработчики React рекомендуют использовать useLayoutEffect только в случае острой необходимости, чтобы вдруг не возникло проблем с правильным рендерингом компонентов. Хук useLayoutEffect можно использовать в случаях, когда необходимо произвести какие-то вычисления либо замеры в реальном DOM или провести синхронно мутацию (изменения).
</p>

<h3>Отличия:</h3>
<p>У useEffect одна загвоздка в том, что он запускается после того, как React отрисовывает ваш компонент и гарантирует, что ваш callback эффекта не блокирует отрисовку браузера. Отличается от  componentDidMount и componentDidUpdate тем что они запускаютс синхронно после рендера компонента. 
Однако, если ваш эффект мутирует DOM (например через ссылку узла DOM) и мутация DOM изменит внешний вид узла DOM между моментом его рендеринга и изменениями от вашего useEffect, тогда вам не стоит использовать useEffect . Вам лучше использовать useLayoutEffect. В противном случае пользователь может увидеть мерцание, когда ваши мутации DOM вступят в силу. Это почти единственный случай, когда вы хотите избежать использования useEffect и вместо этого использовать useLayoutEffect.</p>

<p>useEffect запускается асинхронно и после рендеринга на экране.
Итак, это выглядит:</p>

    1. Вы каким-то образом вызываете рендеринг (изменение состояния или повторный рендеринг родителя)
    2. React отображает ваш компонент (вызывает его)
    3. Экран визуально обновлен
    4. ТОГДА запускается useEffect

<p>useLayoutEffect, с другой стороны, запускается синхронно после рендеринга, но до обновления экрана. Это выглядит вот так:</p>

    1. Вы каким-то образом вызываете рендеринг (изменение состояния или повторный рендеринг родителя)
    2. React отображает ваш компонент (вызывает его)
    3. useLayoutEffect запускается, и React ждет его завершения.
    4. Экран визуально обновлен

<h3>use case:</h3>
<p>Если ваш компонент мерцает при обновлении состояния — например, он сначала рендерится в частично готовом состоянии, а затем сразу же повторно рендерится в своем конечном состоянии — это хороший признак того, что пришло время поменять местами в useLayoutEffect.

Так же useLayoutEffect будет иметь место, когда ваше обновление представляет собой двухэтапный (или многоэтапный) процесс. Вы хотите «сгруппировать» пару обновлений вместе перед перерисовкой экрана? Попробуйте использовать этот хук.</p>


</div>
</details>


<details>
<summary>38. Что такое React.lazy(), suspense?</summary>
<div>
  <p> Функция React.lazy позволяет рендерить динамический импорт как обычный. Проще говоря, она позволяет загружать дополнительные компоненты в наш общий файл bundle (для браузера) только тогда, когда они понадобятся. Это дает возможность облегчить загрузку страницы сразу, но с другой стороны увеличивает ожидание, когда приходит время подгрузки. Поэтому тут важно построить «цепочку поведения пользователей» и правильно разделить компоненты на «пачки».</p>
  <p> Suspense («задержка») позволяет показать запсное содержание, пока подгружается компонента черзе React.lazy.
  Меняем обычный импорт на импорт с «ленивой загрузкой». Например, отложим загрузку двух компонент в файле App.js. </p>
  </br>

  <a>Было:</a>

    import DialogsContainer from './components/Dialogs/DialogsContainer';
    import ProfileContainer from './components/Profile/ProfileContainer';
    ....
  <a>Стало:</a>

    const DialogsContainer = React.lazy(() => import('./components/Dialogs/DialogsContainer'));
    const ProfileContainer = React.lazy(() => import('./components/Profile/ProfileContainer'));
  </br>

  <p>Теперь сами ленивые компоненты в том же файле нам в месте вызова нужно обернуть в компоненту Suspense, которая позволяет нам показать запасное содержимое (например, индикатор загрузки) пока происходит загрузка ленивой компоненты. Сам компонент Suspense можно разместить где угодно выше над этими компонентами. Например:</p>

    return (
          
            <div className="app-wrapper">
              <HeaderContainer />
              <Navbar />
              <div className="app-wrapper-content">
                <Suspense fallback={<Preloader />}> //вот начало оборачивания
                  <Route path='/dialogs' render={ () => <DialogsContainer /> } />
                <Route path='/profile/:userId?' render={ () => <ProfileContainer /> } />
                </Suspense>
                  <Route path='/users' render={ () => <UsersContainer /> } />
                  <Route path='/news' render={ () => <News /> } />
                  <Route path='/music' render={ () => <Music /> } />
                  <Route path='/setings' render={ () => <Setings /> } />
                  <Route path='/login' render={ () => <Login /> } />
              </div>
            </div>
        );
    

  <p>Можно в качестве альтернативы создать подобие ХОКа, как показывал Димыч у видео. Для этого создаем файл src/components/hoc/withSuspense.js:</p>

    import React, { Suspense } from 'react';
    import Preloader from '../common/Preloader/Preloader';
    export const withSuspense = (Component) => {
        return (props) => {
            return  <Suspense fallback={<Preloader />}>
                <Component {...props} />
                </Suspense>
        }
    }
  </br>

  <p>И теперь оборачиваем те же наши компоненты этим ХОКом, а не самой компонентой Suspense:</p>

    return (
        
          <div className="app-wrapper">
            <HeaderContainer />
            <Navbar />
            <div className="app-wrapper-content">
                <Route path='/dialogs' render={ withSuspense(DialogsContainer) } /> //вот
                <Route path='/profile/:userId?' render={ withSuspense(ProfileContainer) } /> //и вот
                <Route path='/users' render={ () => <UsersContainer /> } />
                <Route path='/news' render={ () => <News /> } />
                <Route path='/music' render={ () => <Music /> } />
                <Route path='/setings' render={ () => <Setings /> } />
                <Route path='/login' render={ () => <Login /> } />
            </div>
          </div>
      );

</div>
</details>


<details>
<summary>39. React 18 в кратце об изменениях?</summary>
<div>
  <a>Automatic Batching</a>
  <p>До версии 18, React уже объединял/группировал (batched) несколько обновлений состояния в одно, чтобы уменьшить количество ненужных повторных отрисовок. Однако это происходило только в обработчиках событий DOM, поэтому промисы, тайм-ауты или другие обработчики этим не могли воспользоваться. Дело в том, что ранее каждый вызов useState (установка нового значения) приводил к перерисовке компонентов. Чуть позже движок оптимизировали и такие вызовы начали группироваться и выполняться за один раз, что должно было сократить количество перерисовок. Теперь данный функционал еще больше оптимизировали. 
 </p>
 </br>
  <p>ReactDOM.flushSync() может принудительно заставить компонент перерисовываться при каждом вызове useState (установка нового значения). Это может иногда понадобиться.</p>
  </br>
  <a>Strict Mode</a>
  <p>Напомню что Strict Mode был добавлен в React 16.3. Данный режим позволяет реакту производить дополнительные проверки что бы исключить возможные проблемы приложения.
  Далее, некоторые дополнения к строгому режиму (Strict Mode), включая новое поведение, называемое «строгими эффектами» (“strict effects”). Данный режим будет вызывать двойные эффекты — в частности, монтирование и размонтирование (mount и unmount). Добавление <StrictMode> в приложение React добавляет особое поведение (только в режиме DEV) ко всем компонентам, вокруг которых оно выполняется. Например, при работе в «строгом режиме» React намеренно выполняет двойной рендеринг компонентов, чтобы избавиться от небезопасных побочных эффектов.
  Эти дополнительные проверки предназначены для проверки нескольких циклов монтирования/размонтирования. Он обеспечивает не только более устойчивые компоненты, но и правильное поведение с технологией Fast Refresh во время разработки (когда компоненты монтируются/размонтируются для обновления) и новый «Offscreen API», который в настоящее время находится в разработке. </p>

  <a>Offscreen API</a>
  <p> Обеспечивает лучшую производительность, скрывая компоненты вместо их размонтирования, сохраняя состояние и по-прежнему вызывая эффекты монтирования/размонтирования. Это сыграет решающую роль в оптимизации таких компонентов, как вкладки, виртуализированные списки и т. д. </p>

  <a>Root API</a>
  <p>Немного про новое API, ориентированных на пользователя. Функция рендеринга (render) — та, которая находится в корне каждого приложения React, будет заменена на createRoot.
  Новый API — это шлюз для доступа к новым функциям React 18. createRoot предоставляется вместе с устаревшим API, чтобы способствовать постепенному внедрению и упрощению возможных сравнений производительности.</p>
  
    import ReactDOM from "react-dom";
    import App from "App";

    const container = document.getElementById("app");

    // Old
    ReactDOM.render(<App />, container);

    // New
    const root = ReactDOM.createRoot(container);

    root.render(<App />);

  <a>Параллельный рендеринг — Concurrent Rendering</a>
  <p>Если совсем просто про concurrent rendering то так: В обычном поведении, если React начал перерисовывать DOM, все остальные обновления в очереди блокируются и дожидаются окончания обновления. Concurrent rendering должен решить эту проблему. В конкурентном режиме рендеринг не блокируется. Он прерывается. Это улучшает UX и открывает новые возможности.</p>
</div>
</details>



<br/>

**Flux-архитектура, Redux и MobX**:

<details>
  <summary>1. Что такое Flux - архитектура? Какие сущности она имеет?</summary>
  <div>
    <p>
      Flux-архитектура — архитектурный подход или набор шаблонов программирования для построения пользовательского интерфейса веб-приложений, сочетающийся с реактивным программированием и построенный на однонаправленных потоках данных.
    </p>
    <p>
      Основной отличительной особенностью Flux является односторонняя направленность передачи данных между компонентами Flux-архитектуры. Архитектура накладывает ограничения на поток данных, в частности, исключая возможность обновления состояния компонентов самими собой. Такой подход делает поток данных предсказуемым и позволяет легче проследить причины возможных ошибок в программном обеспечении.
    </p>
    <img src="https://miro.medium.com/max/1400/1*MZj98upz0EUO52VAB4B41Q.jpeg" />
  </div>
</details>

<details>
<summary>2. Назовите ключевые принципы Redux</summary>
<div>
  <p>Redux следует трем фундаментальным принципам:</p>

  <p>1. Единственный источник истины:** состояние всего приложения хранится в древовидном объекта - в одном хранилище. Единственное состояние-дерево облегчает наблюдение за изменениями и отладку или инспектирование приложения</p>
  <p>2. Состояние доступно только для чтения:** единственный способ изменить состояние заключается в запуске операции - объекте, описывающем произошедшее. Это позволяет гарантировать, что ни представления, ни сетевые коллбеки не буду иметь возможности изменять состояние напрямую</p>
  <p>3. Изменения производятся с помощью "чистых" функций:** для определения того, как изменяется состояние в зависимости от операции, создаются редукторы (reducers). Редукторы - это "чистые" функции, принимающие предыдущее состояние в качестве аргумента и возвращающие новое. Благодаря чистым функциям доступен time travel в RTK.</p>
</div>
<img src="https://d33wubrfki0l68.cloudfront.net/01cc198232551a7e180f4e9e327b5ab22d9d14e7/b33f4/assets/images/reduxdataflowdiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif"/>
</details>

<details>
<summary>3. Store?</summary>
<div>
  <img src="https://habrastorage.org/webt/gm/ww/nq/gmwwnqmma6rdwtf3ofir3fjrcmy.gif" />
  <p>Все, что хранится в хранилище, мы называем состоянием, но не все состояния одинаково полезны. Вот какую классификацию вводит документация Redux:</p>

  <a>Domain data — данные приложения, которые нужно отображать, использовать и модифицировать. Например, список пользователей, загруженный с сервера.</a>
  </br>
  <a>App state — данные, определяющие поведение приложения. Например, текущий открытый URL.</a>
  </br>
  <a>UI state — данные, определяющие то, как выглядит UI. Например, вывод списка в плиточном виде.</a>
  </br>

  <p>
    Так как стор представляет собой ядро приложения, данные внутри него должны описываться в терминах domain data и app state, но не как дерево компонентов UI. Например, такой способ формирования состояния state.leftPane.todoList.todos — плохая идея. Крайне редко дерево компонентов отражается напрямую на структуру состояния, и это нормально. Представление зависит от данных, а не данные от представления.</p>
  
   <h2>Store API:</h2>

      const store = new Store(reducers, initialState);

   <h3>dispatch(action):</h3>
   <p>Метод dispatch позволит передать инструкцию для Store, что мы хотим изменить дерево состояния. Это обрабатывается с помощью только что рассмотренного редюсера.
   Функция reduce для хранилища будет вызываться с текущим результатом getState() и заданным действием синхронно. Его возвращаемое значение будет считаться следующим состоянием. С этого момента он будет возвращаться из getState(), и listeners  будут немедленно уведомлены.</p>

   <h3>subscribe(listener):</h3>
   <p>Метод subscribe позволит передать в Store функцию-подписчик, которой, когда наше дерево состояния изменится, мы сможем передать эти его новые изменения с помощью аргумента в обратном вызове .subscribe().</p>

   <h3>replaceReducer(nextReducer):</h3>
   <p>Заменяет редюсер, используемый в настоящее время хранилищем для вычисления состояния.
      Это расширенный API. Это может понадобиться, если ваше приложение реализует разделение кода и вы хотите динамически загружать некоторые редюсеры. Вам также может понадобиться это, если вы реализуете механизм горячей перезагрузки для Redux.</p>

   <h3>getState():</h3>
   <p>Возвращает текущее дерево состояний вашего приложения. Оно равно последнему значению, возвращенному редьюсером хранилища.</p>

</div>
</details>

<details>
<summary>4. Reducers?</summary>
<div>
  <p>(reducer) — это чистая функция, которая вычисляет следующее состояние дерева на основании его предыдущего состояния и применяемого действия.

    (currentState, action) => newState

  Чистая функция работает независимо от состояния программы и выдаёт выходное значение, принимая входное и не меняя ничего в нём и в остальной программе. Получается, что редуктор возвращает совершенно новый объект дерева состояний, которым заменяется предыдущий.

  Чего не должен делать редуктор
  Редуктор — это всегда чистая функция, поэтому он не должен:

  <li>мутировать аргументы;</li>
  <li>мутировать состояние. Вместо этого создаётся новое состояние с помощью Object.assign({}, ...);</li>
  <li>иметь побочные эффекты (никаких API-вызовов с какими-либо изменениями);</li>
  <li>вызывать нечистые функции. Это функции, результат которых зависит от чего-то кроме их аргументов (например, Date.now() или Math.random()).</li>
  </br>

      Редуктор для каждой части состояния
    const title = (state = '', action) => {
      if (action.type === 'CHANGE_LIST_TITLE') {
        return action.title
      } else {
        return state
      }
    }
    const list = (state = [], action) => {
      switch (action.type) {
        case 'ADD_ITEM':
          return state.concat([{ title: action.title }])
        case 'REMOVE_ITEM':
          return state.map((item, index) =>
            action.index === index
              ? { title: item.title }
              : item
        default:
          return state
      }
    }
</p>
</div>
</details>

<details>
<summary>5. Dispatcher?</summary>
<div>
  <p>Что бы обновить store необходимо вызвать метод dispatch(). Он вызывается у объекта store который вы создаёте в store.js. Этот объект принято называть store поэтому обновление состояния в моём случае выглядит так:</p>

    store.dispatch({ type: ACTION_1, value_1: "Some text" });

    ACTION_1 это константа события о которой речь пойдет дальше (см. Actions).

  <p>Эта функция вызовет функцию reducer который обработает событие и обновит соответствующие поля хранилища.</p>
  
</div>
</details>



<details>
<summary>6. Что такое селекторы (selectors) Redux и зачем их использовать?</summary>
<div>
<p>*Selectors* - это функции, принимающие состояние Redux в качестве аргумента и возвращающие некоторые данные для передачи компоненту.</p>

<p>Например, так можно извлечь данные пользователя из состояния:</p>

  ```javascript
  const getUserData = state => state.user.data
  ```

<p>Селекторы имеют два главных преимущества:</p>

<p>1. Селектор забирает из стора конкретные нужные данные.</p>
<p>2. Селектор не выполняет повторных вычислений до тех пор, пока не изменится один из его аргументов</p>

    const Foo = () => {
      const value = useSelector(state => state.value);

      return (
        <Bar value={value} />
      );
    };

    export default Foo;

</div>
</details>


<details>
<summary>7. Что такое операция (action) в Redux?</summary>
<div>
<p>*Actions* - это обычные JavaScript-объекты, содержащие данные приложения, которые отправляются в хранилище. Операции должны иметь свойство `type`, указывающее какой тип операции необходимо выполнить. Операции также могут содержать полезную нагрузку (payload) - данные для обновления состояния.</p>

<p>Вот как может выглядеть операция по добавлению новой задачи в список:</p>

  ```
  // здесь используется константа
  {
    type: ADD_TODO,
    text: 'Добавление задачи в список'
  }
  ```
</div>
</details>



<details>
<summary>8. Проведите сравнение Redux и Flux</summary>
<div>
  <p>Отличия между Redux и Flux можно свести к следующему:</p>

  <p>1. **Недопустимость мутаций:** во Flux состояние может быть изменяемым, а Redux требует, чтобы состояние было иммутабельным, и многие библиотеки для Redux исходят из предположения, что вы никогда не будете менять состояние напрямую. Вы можете обеспечить иммутабельность состояния с помощью таких пакетов, как `redux-immutable-state-invariant`, `Immutable.js` или условившись с другими членами команды о написании иммутабельного кода</p>
  <p>2. **Осторожность в выборе библиотек:** Flux не пытается решать такие проблемы, как повторное выполнение/отмена выполнения, стабильность (постоянство) кода или проблемы, связанные с обработкой форм, явно, а Redux имеет возможность к расширению с помощью промежуточного программного обеспечения (middleware) и предохранителей хранилища, что породило богатую экосистему</p>
  <p>3. **Отсутствие интеграции с Flow:** Flux позволяет осуществлять очень выразительную статическую проверку типов, а Redux пока не поддерживает такой возможности</p>

   
</div>
</details>

<details>
<summary>9. В чем разница между `mapStateToProps()` и `mapDispatchToProps()`?</summary>
<div>
<p> `mapStateToProps()` - это утилита, помогающая компонентам получать обновленное состояние (которое было обновлено другим компонентом):</p>

<p>

    const mapStateToProps = (state) => {
      return {
        todos: getVisibleTodos(state.todos, state.visibilityFilter)
      }
    }
</p>

<p>`mapDispatchToProps()` - утилита, помогающая компонентам вызывать операции (которые могут привести к обновлению состояния приложения):</p>

<p>

    const mapDispatchToProps = (dispatch) => {
      return {
        onTodoClick: (id) => {
          dispatch(toggleTodo(id))
        }
      }
    }
</p>

<p>Ваши компоненты должны быть связаны только с отображением информации. Единственное место, откуда они должны получать информацию, — это пропсы.</p>

<p>Отдельно от «отображения материала» (компонентов) стоит:
    как вы получаете данные для отображения,
    и как вы обрабатываете события.
    Для этого есть контейнеры.</p>

<p>

    class FancyAlerter extends Component {
      sendAlert = () => {
          this.props.sendTheAlert()
      }

      render() {
          <div>
            <h1>Today's Fancy Alert is {this.props.fancyInfo}</h1>
            <Button onClick={sendAlert}/>
          </div>
      }
    }

</p>

<p>Вот где появляется mapDispatchToProps: в соответствующем контейнере:</p>

    function mapDispatchToProps(dispatch) {
        return({
            sendTheAlert: () => {dispatch(ALERT_ACTION)}
        })
    }

    function mapStateToProps(state) {
        return({fancyInfo: "Fancy this:" + state.currentFunnyString})
    }

    export const FancyButtonContainer = connect(
        mapStateToProps, mapDispatchToProps)(
        FancyAlerter
    )

<p>Теперь FancyButtonContainer знает о redux, dispatch, store, state и... прочем.

Компонент в шаблоне, FancyAlerter, который выполняет рендеринг, не должен знать ни о чем из этого: он получает свой метод для вызова при нажатии кнопки через свои props.

И... mapDispatchToProps был полезным средством, которое предоставляет Redux, позволяющим контейнеру легко передавать эту функцию в обернутый компонент в своих реквизитах.</p>
</div>
</details>

<details>
<summary>10. Обязательно ли хранить состояние всех компонентов в хранилище Redux?</summary>
<div>
<p>Данные приложения следует хранить в хранилище Redux, а состояние компонентов пользовательского интерфейса в соответствующих компонентах. У создателя Redux Дэна Абрамова по этому поводу есть статья под названием "Следует ли вам использовать Redux?"</p>
</div>
</details>


<details>
<summary>11. Как рекомендуется получать доступ к хранилищу Redux?</summary>
<div>
<p>Лучшим способом получить хранилище в компоненте является использование функции `connect()`, которая создает новый компонент, оборачивающий существующий. Этот паттерн называется *компоненты высшего порядка*, он является предпочтительным способом расширения функциональности компонента в React. Это позволяет передавать в компонент состояние и "создателей операций" (action creators), в том числе, при обновлении хранилища.</p>

<p>Создадим компонент `FilterLink` с помощью `connect()`:</p>

<p>

     import { connect } from 'react-redux'
     import { setVisibilityFilter } from '../actions'
     import Link from '../components/Link'

     const mapStateToProps = (state, ownProps) => ({
       active: ownProps.filter === state.visibilityFilter
     })

     const mapDispatchToProps = (dispatch, ownProps) => ({
       onClick: () => dispatch(setVisibilityFilter(ownProps.filter))
     })

     const FilterLink = connect(
       mapStateToProps,
       mapDispatchToProps
     )(Link)

     export default FilterLink
</p>

<p>Поскольку такой вариант имеет несколько оптимизаций производительности и, как правило, меньше подвержен "багам", разработчики Redux почти всегда рекомендуют использовать `connect()` вместо прямого доступа к хранилищу (с помощью API контекста).</p>

     class MyComponent {
       someMethod() {
         doSomethingWith(this.context.store)
       }
     }
</p>
</div>
</details>

<details>
<summary>12. Для чего в Redux нужны константы??</summary>
<div>
<p>Константы позволяют легко обнаруживать все случаи их применения в проекте при использовании IDE. Они также позволяют избегать глупых ошибок, связанных с типами - немедленно выбрасывается исключение `ReferenceError`.</p>

<p>Обычно, мы сохраняем константы в отдельном файле  (`constants.js` или `actionTypes.js`)</p>

```javascript
export const ADD_TODO = 'ADD_TODO'
export const DELETE_TODO = 'DELETE_TODO'
export const EDIT_TODO = 'EDIT_TODO'
export const COMPLETE_TODO = 'COMPLETE_TODO'
export const COMPLETE_ALL = 'COMPLETE_ALL'
export const CLEAR_COMPLETED = 'CLEAR_COMPLETED'
```

<p>В Redux мы используем их в двух местах:</p>

1. **Во время создания операции:**

      `actions.js`:

      ```javascript
      import { ADD_TODO } from './actionTypes';

      export function addTodo(text) {
        return { type: ADD_TODO, text }
      }
      ```

2. **В редукторах:**

      `reducer.js`:

      ```javascript
      import { ADD_TODO } from './actionTypes'

      export default (state = [], action) => {
        switch (action.type) {
          case ADD_TODO:
            return [
              ...state,
              {
                text: action.text,
                completed: false
              }
            ];
          default:
            return state
        }
      }
      ```
       
</div>
</details>



<details>
<summary>13. Как структурировать директории верхнего уровня в Redux?</summary>
<div>
<p>Большинство приложений имеют несколько "топовых" директорий:</p>

<p>1. **components**: используется для "тупых" компонентов, не знающих о Redux</p>
<p>2. **containers**: используется для "умных" компонентов, подключенных к Redux</p>
<p>3. **actions**: используется для всех создателей операций - названия файлов указывают на соответствующие части приложения</p>
<p>4. **reducers**: используется для всех редукторов - названия коррелируют с ключами состояния</p>
<p>5. **store**: используется для инициализации хранилища</p>

<p>Такая структура прекрасно подходит для небольших и средних приложений.</p>
</div>
</details>


<details>
<summary>14. Обязательно ли хранить все состояние в Redux? Можно ли использовать внутреннее состояние компонентов?</summary>
<div>
<p>Вы сами принимаете решение, что использовать. В этом заключается работа разработчика - определить, какое состояние требуется  приложению и где должна храниться каждая часть этого состояния. Одни разработчики предпочитают хранить все состояние в Redux, что обеспечивает полную сериализацию и управляемость приложения. Другие предпочитают хранить некритичное состояние UI, такое как "открыт ли выпадающий список" внутри компонента.</p>

<p>Ниже представлены основные правила определения того, какие типы данных следует хранить в Redux:</p>

     1. Нуждаются ли другие части приложения в этих данных?
     2. Требуется ли создавать производные данные на основе оригинальных?
     3. Используются ли эти данные несколькими компонентами?
     4. Существует ли вероятность того, что потребуется восстанавливать прошлое состояние?
     5. Собираетесь ли вы кэшировать данные (для использования версии из кэша вместо повторного запроса)?
</div>
</details>

<details>
<summary>15. Middleware?</summary>
<div>
  <img src="https://d33wubrfki0l68.cloudfront.net/08d01ed85246d3ece01963408572f3f6dfb49d41/4bc12/assets/images/reduxasyncdataflowdiagram-d97ff38a0f4da0f327163170ccc13e80.gif" />

  <p>Мидлвары — функции, которые последовательно вызываются в процессе обновления данных в хранилище.</p>

  <h3>Общий принцип работы таков:</h3>

  <p>Мидлвары встраиваются в хранилище при его создании
  Во время диспатчинга (отправки действий) данные проходят через них и только затем попадают в редьюсер</p>
  
  Типичные примеры использования включают:

    Логирование
    Оповещение об ошибках
    Работу с асинхронным API
    Маршрутизацию
  </br>
  <p>Посмотрим как их подключить:</p>

    import { createStore, applyMiddleware } from 'redux';
    import thunk from 'redux-thunk';

    const store = createStore(
      reducer,
      /* preloadedState, */
      applyMiddleware(thunk)
    )
  <p>thunk — это мидлвар, но перед тем, как передать его в функцию createStore, нужно применить к нему функцию applyMiddleware. Также обратите внимание на то, что мидлвар мы передаём вторым параметром, хотя в предыдущем уроке вторым параметром шёл initState. Объясняется это просто — функция createStore проверяет тип второго параметра и в зависимости от этого понимает, что перед ней. В общем случае она принимает три параметра: редьюсер, начальное состояние и мидлвары</p>  
</div>
</details>


<details>
<summary>16. RTK Slice?</summary>
<div>
  <p> Чтобы мы не делали внутри слайсов, в конце-концов они генерируют обычные редьюсеры и действия, которые затем передаются в Redux. То есть, слайсы не добавляют никаких новых возможностей в сам Redux. Они автоматизируют рутину, сокращают количество кода и предоставляют более удобные "ручки" для управления действиями и состоянием.</p>

  <p>Для создания слайса нам нужно как минимум три компонента: имя, начальное состояние, набор редьюсеров.</p>

    import { createSlice } from '@reduxjs/toolkit';

    // Начальное значение
    const initialState = {
      value: 0,
    };

    const counterSlice = createSlice({
      name: 'counter',
      initialState,
      // Редьюсеры в слайсах мутируют состояние и ничего не возвращают наружу
      reducers: {
        increment: (state) => {
          state.value += 1;
        },
        decrement: (state) => {
          state.value -= 1
        },
        // пример с данными
        incrementByAmount: (state, action) => {
          state.value += action.payload
        },
      },
    });

  <a>Имя:</a>
  <p>Имя это свойство в состоянии приложения, внутри которого хранятся данные текущего слайса. Кроме того, имя используется как префикс в названии действия. На картинке слева Navigator. Помогает отладке, мы видим откуда взялось действие.</p>
  <img src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImM2ODlmN2VlNWE0OTkxZDhlNmIxOTE0ZGI5YTE0NWM3LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=47a192fc8d37671228ecb3ad1cb1d72f2fcbbbd052400fb316bc3cb84440bac1" />

  <a>Начальное состояние:</a>

  <p>Под начальным состоянием понимается базовая структура данных и какие-то статические данные, если они есть, например значение 0 для счетчика. А вот те данные, которые нужно выкачать по API, к начальным не относятся. Они заполняются уже потом, через действия.</p>

  <a>Редьюсеры:</a>
  <p>Редьюсеры в Toolkit очень похожи на редьюсеры самого Redux, но имеют несколько важных отличий. Каждый редьюсер соответствует конкретному действию, поэтому внутри нет конструкции switch, а сами редьюсеры очень маленькие. И внутри редьюсеров происходит прямое изменение состояния. Как такое возможно?

  <p>Redux, несмотря на свою концептуальную красоту и чистоту, становится неудобным в работе, когда состояние становится глубоко вложенным. Запрет на прямое изменение порождает сложные конструкции, которые приходится писать для обновления глубоко спрятанных данных:</p>

    {
      ...state,
      firstLevel: {
        ...state.firstLevel,
        secondLevel: {
          ...state.firstLevel.secondLevel,
          thirdLevel: {
            ...state.firstLevel.secondLevel.thirdLevel,
            property1: action.data
          },
        },
      },
    }

 <p>Для решения этой проблемы в JavaScript написали немало библиотек, но все они требуют изучения еще одного инструмента, который хоть и сокращает количество кода, но вносит еще один уровень абстракции, со своими проблемами и сложностями использования. Так продолжалось до тех пор, пока не появился Immer.</p>   


 <p>И наконец экспорты. Функция createSlice() генерирует редьюсер и экшены к нему. Всё это нужно экспортировать в показанном стиле: редьюсер по умолчанию, действия по именам:</p>

    export const { increment, decrement, incrementByAmount } = counterSlice.actions;
    export default counterSlice.reducer; 
</div>
</details>


<details>
<summary>17. Immer?</summary>
<div>
  <p>Immer. Эта библиотека позволяет отследить прямые изменения внутри объекта, так чтобы обновить оригинал без мутаций, то есть создавая копию в стиле Redux.</p>

    import produce from 'immer';

    const baseState = [
      {
        title: "Learn TypeScript",
        done: true
      },
      {
        title: "Try Immer",
        done: false
      },
    ];


    // draft содержит такие же данные как и baseState,
    // но они обернуты в Proxy для отслеживания изменений
    // Эти изменения затем используются для обновления baseState
    const nextState = produce(baseState, (draft) => {
      draft[1].done = true;
      draft.push({title: 'Hexlet teach me'});
    });

    // Разные объекты!
    nextState !== baseState;

<p>В отличие от прямого изменения baseState, Immer делает это как редьюсеры в Redux, в неизменяемом стиле.</p>

  <p>Получается, что каждый редьюсер в Toolkit, это тот колбек из Immer, в который передается draft. Теперь мы можем мутировать состояние, но внутри все работает так, как будто мы этого не делаем. Благодаря такому подходу сохраняются все возможности, которые предоставляет Redux, включая его DevTool - утилиту для анализа происходящего в браузере. В этом заключается главная фантастика происходящего. Мы получили плюсы от обоих миров, сохранив всю экосистему Redux.</p>

  
</div>
</details>


<details>
<summary>18. Batch?</summary>
<div>
  <p>Когда появляется несколько слайсов, то возникает необходимость обновить состояние сразу несколькими экшенами. Если это делать обычным способом, то на каждое действие будет происходить перерисовка компонента:</p>

    import React, { useEffect } from 'react';
    import { useDispatch } from 'react-redux';
    import { addUsers } from '../slices/usersSlice.js';
    import { addPosts } from '../slices/postsSlice.js';
    import Posts from './Posts.jsx';

    export default () => {
      const dispatch = useDispatch();

      useEffect(async () => {
        // получаем данные users и posts
        const { data: posts } = await axios.get('/posts');
        const { data: users } = await axios.get('/users');
        dispatch(addPosts(posts));
        dispatch(addUsers(users));
      });

      return (<Posts />)
    };
  
    export default () => {
    // Вытаскиваем данные из хранилища. state – все состояние
    const users = useSelector((state) => state.usersSlice.users);
    const posts = useSelector((state) => state.postsSlice.posts);

    const renderPost = (post) => {
      const author = users.find((user) => user.id === post.authorId); // ошибка! users ещё не добавлен в стор
      const body = `Автор: ${author.name}. Текст: ${post.body}.`;
      return <div>{body}</div>;
    };

      return (
        {posts.map(renderPost)}
      );
    };

  <p>Компонент Posts отрисовывается при каждом изменении состояния. Происходит это дважды: когда мы добавляем посты dispatch(addPosts(posts)) и когда добавляем пользователей dispatch(addUsers(users)). В первом случае возникает проблема, так как пользователи ещё не добавлены, то автор не будет найден. Чтобы этого избежать есть специальная функция batch(), она позволяет объединить несколько обработчиков состояния:</p>

    // file: components/App.jsx

    import React, { useEffect } from 'react';
    // импортируем batch
    import { batch } from 'redux';
    import { useDispatch } from 'react-redux';
    import { addUsers } from '../slices/usersSlice.js';
    import { addPosts } from '../slices/postsSlice.js';
    import Posts from './Posts.jsx';

    export default () => {
      const dispatch = useDispatch();

      useEffect(async () => {
        // получаем данные users и posts
        const { data: posts } = await axios.get('/posts');
        const { data: users } = await axios.get('/users');
        // batch принимает функцию, внутри которой мы можем диспатчить экшены
        batch(() => {
          dispatch(addPosts(posts));
          dispatch(addUsers(users));
        });
      }, []);

      return (<Posts />)
    };
  <p>Теперь, при загрузке постов и пользователей и добавлении их в стор, компонент Posts отрисуется один раз, когда все данные уже добавлены.</p>

  
</div>
</details>



<details>
<summary>19. Организация хранения данных в Redux/RTK?</summary>
<div>

  <p>Нормализация – это процесс удаления избыточных данных.
    Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.</p>

  <p>Правильный подход при работе с Redux — воспринимать его как реляционную базу данных. Данные внутри хранилища должны быть нормализованы. При таком взгляде каждый слайс работающий с набором сущностей может восприниматься как отдельная таблица в базе данных.</p>

  <p>Основные принципы организации данных в хранилище:</p>

    Каждая сущность хранится в своём редьюсере.

    Коллекция сущностей одного типа хранится в виде объекта, где ключи — идентификаторы объектов, а значения — сами объекты.

    Порядок данных в этом объекте задаётся отдельным массивом состоящим только из идентификаторов.

    Данные ссылаются друг на друга только по идентификаторам.
  
  <h2>Было:</h2>

    const blogPosts = [
    {
      id: 'post1',
      author: { username: 'user1', name: 'User 1' },
      body: '......',
      comments: [
        {
          id: 'comment1',
          author: { username: 'user2', name: 'User 2' },
          comment: '.....'
        },
        {
          id: 'comment2',
          author: { username: 'user3', name: 'User 3' },
          comment: '.....'
        }
      ]
    },
    ];
  <h2>Стало:<h2>  

    {posts: {
        entities: {
          post1: {
            id: 'post1',
            author: 'user1',
            body: '......',
            comments: ['comment1', 'comment2'],
          },
          post2: {
            id: 'post2',
            author: 'user2',
            body: '......',
            comments: [],
          },
        },
        ids: ['post1', 'post2'],
      },
      comments: {
        entities: {
          comment1: {
            id: 'comment1',
            author: 'user2',
            comment: '.....',
          },
          comment2: {
            id: 'comment2',
            author: 'user3',
            comment: '.....',
          },
        },
        ids: ['comment1', 'comment2'],
      },
      users: {
        entities: {
          user1: {
            username: 'user1',
            name: 'User 1',
          },
          user2: {
            username: 'user2',
            name: 'User 2',
          },
          user3: {
            username: 'user3',
            name: 'User 3',
          },
        },
        ids: ['user1', 'user2', 'user3'],
      }
    }

  <p>  Теперь данные нормализованы. Каждая сущность хранится в своём собственном редьюсере. Объект entities хранит сами сущности, а ids - идентификаторы. Какие преимущества мы получили?</p>

    Массив с id хранит в себе еще и порядок сущность в entities.

    Данные не повторяются, а значит достаточно поменять только одно место при их изменении

    Редьюсеры не имеют вложенности

    Данные в таком виде легко извлекать и модифицировать

    Теперь посмотрим как это будет выглядеть внутри слайсов:
    
    const slice = createSlice({
      name: 'users',
      initialState: {
        ids: [],
        entities: {},
      },
      reducers: {
        addUser(state, action) {
          const { user } = action.payload;

          state.entities[user.id] = user;
          state.ids.push(user.id);
        }
        removeUser(state, action) {
          const { userId } = action.payload;

          delete state.entities[userId];
          state.ids = state.ids.filter((id) => id !== userId);
        },
        updateUser(state, action) {
          const { userId, data } = action.payload;

          Object.assign(state.entities[userId], data);
        }
      },
    });

    dispatch(addUser({ user }));
    dispatch(removeUser({ userId }));
    dispatch(updateUser({ userId, data }));

</div>
</details>


 <details>
<summary>20. RTK entity adapter?</summary>
<div>
  <p>Entity Adapter. Он предоставляет набор готовых редьюсеров и селекторов для основных операций над сущностями. Сначала пример:</p>

    import {
      createSlice,
      createEntityAdapter,
    } from '@reduxjs/toolkit';

    const usersAdapter = createEntityAdapter();

    // По умолчанию: { ids: [], entities: {} }
    const initialState = usersAdapter.getInitialState();

    const slice = createSlice({
      name: 'users',
      initialState,
      reducers: {
        addUser: usersAdapter.addOne,
        addUsers: usersAdapter.addMany,
        removeUser: usersAdapter.removeOne,
        updateUser: usersAdapter.updateOne,
      },
    });

    // Где-то в приложении

    // По соглашению, в передаваемых данных должен быть id для правильной работы
    dispatch(addUser(user));
    // Данные передаются в формате: { id, changes }
    dispatch(updateUser({ id: user.id, changes: data }));
    // Достаточно передать идентификатор
    dispatch(removeUser(user.id));

  <p> Буквально 4 строчки в редьюсерах и мы получили полноценную реализацию стандартных операций над пользователем. Но это еще не все, кроме готовых редьюсеров, Entity Adapter дает нам набор готовых селекторов для извлечения данных из хранилища. Для этого их нужно сгенерировать и экспортировать из файла со слайсом:</p> 

    // Колбек определяет базовый селектор, извлекающий нужную часть состояния из Redux
    // Для слайса users это state.users
    export const selectors = usersAdapter.getSelectors((state) => state.users);

  <p>Пример использования в приложении:</p>

    import { useSelector, useDispatch } from 'react-redux';

    import { selectors } from '../slices/usersSlice.js';

    const MyComponent = (props) => {
      // Извлекаем всех пользователей в виде массива
      // Внутри происходит выборка данных из state.users.entities
      // отсортированная по state.users.ids
      const users = useSelector(selectors.selectAll);

      // тут логика вывода
    }
    Кроме selectAll(state) мы получаем:

    selectIds(state) – возвращает ids
    selectEntities(state) – возвращает entities
    selectTotal(state) – возвращает общее количество
    selectById(state, id) – возвращает конкретную сущность или undefined если ничего не найдено

    // id – какой-то идентификатор
    const user = useSelector((state) => selectors.selectById(state, id));  
</div>
</details>


<details>
<summary>21. RTK Extra Reducers?</summary>
<div>
  <p>Разделение данных по слайсам (а фактически по редьюсерам в Redux) приводит к ситуациям, когда на одно действие нужно реагировать в разных частях хранилища. Например, если удаляется пост, то нужно удалить и его комментарии, которые находятся в другом слайсе.</p>

  <p>В Redux такая задача решалась просто добавлением в switch реакции на нужное действие по его имени. В Redux Toolkit так уже не получится из-за железной связи редьюсеров с действиями. Это цена, которую мы платим за сокращение кода.</p>

  <p>Для реакции на действия, происходящие в других слайсах, Redux Toolkit добавляет механизм дополнительных редьюсеров extraReducers. Работает он достаточно просто. В слайс добавляется свойство extraReducers, через которое можно устанавливать реакцию (редьюсеры) на внешние действия:</p>

     // Импортируем из других слайсов действия на которые нужно реагировать
    import { removePost } from '../postsSlice.js';

    const postCommentsAdapter = createEntityAdapter();
    const initialState = postCommentsAdapter.getInitialState();

    const postCommentsSlice = createSlice({
      name: 'comments',
      initialState: initialState,
      reducers: {
        // Обычные редьюсеры
      },
      extraReducers: (builder) => { // Дополнительные редьюсеры
        // При удалении поста нужно удалить все его комментарии
        builder.addCase(removePost, (state, action) => {
          const postId = action.payload;
          // Выбираем все комментарии кроме тех, что нужно удалить
          const restEntities = Object.values(state.entities).filter((e) => e.postId !== postId);
          // setAll удаляет текущие сущности и добавляет новые
          postCommentsAdapter.setAll(state, restEntities);
        });
      },
    });

    // Где-то в приложении
    dispatch(removePost(post.id));

  <p>Дополнительные редьюсеры добавляются как кейсы в объект builder, изменяя его напрямую. Поэтому нам не нужно ничего возвращать. Более того, builder поддерживает цепочки, а значит мы можем вызывать добавление кейсов друг за другом builder.addCase().addCase()....</p>  
</div>
</details>

<details>
<summary>22. Redux-thunk?</summary>
<div>
  <p>Redux thunk это термин в программировании который обозначает "кусочек кода который делает какую то отложенную работу". Вместо того, чтобы выполнять некоторую логику сейчас, мы можем написать тело функции или код, который можно использовать для выполнения работы позже.</p>

  <p>В частности, для Redux «thunks» — это шаблон написания функций с логикой внутри, которые могут взаимодействовать с dispatcher хранилища Redux и методами getState.</p>

  <p>Redux-thunk: это промежуточное программное обеспечение, которое отслеживает каждое действие, проходящее через систему, и, если это функция, она вызывает эту функцию.</p>


  <p>Redux будет передавать два аргумента функциям-преобразователям: dispatch, чтобы они могли отправлять новые действия, если им это нужно; и getState, чтобы они могли получить доступ к текущему состоянию. Код redux-thunk выглядит вот так:</p>

    function createThunkMiddleware(extraArgument) {
      return ({ dispatch, getState }) => next => action => {
        if (typeof action === 'function') {
          return action(dispatch, getState, extraArgument);
        }

        return next(action);
      };
    }

    const thunk = createThunkMiddleware();
    thunk.withExtraArgument = createThunkMiddleware;

    export default thunk;

  <p>Функция getState может быть полезна для принятия решения о том, следует ли извлекать новые данные или возвращать кешированный результат, в зависимости от текущего состояния.</p>



  <h2>Для чего используются thunks?</h2>
  <p>Thunks позволяют нам писать дополнительную логику, связанную с Redux, отдельно от слоя пользовательского интерфейса. Эта логика может включать побочные эффекты, такие как асинхронные запросы или генерация случайных значений, а также логика, требующая dispatching нескольких действий или доступа к состоянию хранилища Redux.</p>

  <p>Reducers Redux не должны содержать побочных эффектов, но для реальных приложений требуется логика, имеющая побочные эффекты. Некоторые из них могут находиться внутри компонентов, но некоторым может потребоваться жить вне уровня пользовательского интерфейса. Thunks (и другое промежуточное ПО Redux) дают нам место для размещения этих побочных эффектов.</p>
  <p>Это может быть сделано для улучшения тестируемости логики, чтобы уровень пользовательского интерфейса оставался как можно более тонким и «презентативным», или для улучшения повторного использования и совместного использования кода.</p>


  <h2>Итого:</h2>
  <p>redux-thunk позволяет создавать actions которые будут функциями с возможность dispatch другие функции, а не только action обьекты.</p>
  <p>redux-thunk это пример Redux Middleware и как таковой должен придеживаться сигнатуры validMiddleware => (store) => (next) => (action)
  
  Где store = {dispatch, getState}</p>

  <p>redux-thunk логика достаточно проста. Выполняется проверка на то, является ли переданный action функцией. И если да, функция запускается. По умолчанию происходит импорт Middleware без extraArgument, но потом к thunk добавляется поле withExtraArgument = createThunkMiddleware. При необходимости эта функция будет использована.</p>

  <a href="https://daveceddia.com/what-is-a-thunk/#commento-login-box-container">thunk theory</a>
  <a href="https://user3141592.medium.com/understanding-the-redux-thunk-source-code-b3f8b930faf6">thunk underhood</a>

</div>
</details>



<details>
<summary>23. ES6 generators?</summary>
<div>
  <p>Как видно из примера, генераторы вводят новый синтаксис в язык. Во-первых, это звездочка после слова function. Она просто указывает на то, что мы имеем дело с генератором. Во-вторых, выражение yield (подчеркиваю: это – не инструкция).</p>

  <p>Генератор в отличие от обычной функции при своем вызове не выполняет тело, а возвращает специальный объект с методом next. Каждый раз, когда вызывается next, запускается тело генератора с того места, где оно остановилось последний раз. При первом вызове выполнение идёт с самого начала генератора и продолжается до встречи с выражением yield. В этот момент управление передаётся наружу, next возвращает то, что было передано в yield, а генератор замирает в этом состоянии, на выражении yield. Последующие вызовы начинают работу от yield.</p>

  <p>Еще один пример для осознания:</p>

    const gen = function* () {
      yield 1;
      yield 2;
      yield 3;
    };

    const it = gen();
    it.next(); // { value: 1, done: false }
    it.next(); // { value: 2, done: false }
    it.next(); // { value: 3, done: false }
    it.next(); // { value: undefined, done: true }

  <p>Или даже так:</p>

    const it = gen();
    [...it]; // [1, 2, 3]

  <p>Кроме yield в генераторах можно использовать версию yield*, которая ожидает на вход коллекцию и делает yield для каждого элемента этой коллекции.</p>

    const makeIterator = function* () {
      yield* this.collection;
    };

  <p>Теперь можно переписать наш первый пример вот таким образом:</p>

    const obj = {
      collection: ['yo', 'ya'],
      [Symbol.iterator]: function* () {
        yield* this.collection;
      },
    };

    for (const v of obj) {
      console.log(v);
    }
    // yo
    // ya

</div>
</details>




<details>
<summary>24. Redux-saga?</summary>
<div>
  <p>Redux-saga это библиотека нацеленная делать сайд-эффекты проще и лучше путем работы с сагами.</p>
  <p>Саги это дизайн паттерн, который пришел из мира распределенных транзакций, где сага управляет процессами, которые необходимо выполнять транзакционным способом, сохраняя состояние выполнения и компенсируя неудачные процессы.</p>
  <p>Работает на генераторах, умеет приостанавливать и возобновлять свою работу в любой момент.</p>
  <p>Это библиотека, абстрагирующая и облегчающая работу с побочными эффектами в react/redux приложениях.</p>
  <p>Сага работает в "фоне".</p>
  <p>Саги позволяют организовать сложные цепочки побочных эффектов в последовательные вызовы.</p>
  
  <img src="https://raw.githubusercontent.com/rohit120582sharma/Documentation/master/images/redux-saga_architecture.png" />


  <h2>createSagaMiddleware(options)</h2>
  <h3>Options: Object</h3>
  <p>Список опций для передачи в middleware.</p>
  <ul>
    <li>context: Object - иницианизирующее значение saga context.</li>
    <li>sagaMonitor - для выведения логов</li>
    <li>onError: (error: Error, { sagaStack: string }) - если установлено, то мидллвар будет вызывать ее с uncaught ошибками из Saga. Полезно для того что бы посылать не обработанные exception в следящие сервисы.</li>
    <li>effectMiddlewares - Функция [] - позволяет вам перехватывать любой эффект, разрешать его самостоятельно и отправлять в следующий middleware.</li>
  </ul>



  <h2>Saga watcher</h2>

  <p>Следят за действиями в приложении, и когда происходит экшн реагируют.</p>

  <h2>Saga worker</h2>

  <p>Выполняет бизнес логику (запрос/таймаут/запись в кэш)</p>

  <h2>Effects:</h2>
  <p>Блокирующие/Не блокирующие</p>
  <img src="https://soshace.com/wp-content/uploads/rcl-uploads/articles/2019/11/1484933.jpg" />
  <h3>Take</h3>
  <a>Блокирующий</a>
  <p>Указывает middleware ждать dispatch указанного действия. Генератор приостанавливается до тех пор, пока не будет отправлено указанное действие. Ждет какого либо диспатча и когда он происходит может выполнится.</p>
  
  <h3>Take Every</h3>
  <p>Создает и запусткает worker-saga на каждый dispatch данного экшена.<p>

  <h3>Take Latests</h3>
  <p>Автоматически отменяет любую предыдущую задачу саги, запущенную ранее, если она все еще выполняется.<p>  

  <h3>Take Leading</h3>
  <p>Автоматически отменяет любую следующу задачу саги, запущенную позднее, если первая запущенная еще выполняется.<p>  

  <h3>Put</h3>
  <p>Вызывает dispatch с переданным action.<p>  

  <h3>Call</h3>
  <a>Блокирующий</a>
  <p>Выполняет переданную функцию. Если функция вернет promise, приостанавлевает сагу до тех пор, пока promise не вызовет Resolve. Принимает простые функции, асинхронные функции или генераторы. Вторым аргументом передается данные на вход переданной функции.<p>  

  <h3>Fork</h3>
  <a>Не блокирующий</a>
  <p>Указывает Redux middleware выполнить не блокирующий вызов переданной функции. Все форкнутые задачи прикреплены к своим родителям. Любая ошибка всплывает к родительской задаче. Если ошибка произошла родительская задача блокируется и не выполняется. Возвращает таску, к которой можно джоинится.</p>

  <h3>Spawn</h3>
  <a>Не блокирующий</a>
  <p>Позволяет создать паралельную задачу в корне саги, сам процесс не привязан к родителю.</p>

  <h3>Join</h3>
  <p>Заблокировать не блокирующую задачу и получить результат.</p>

    export function* workerSaga() {
    // бизнес логика

        const  task = yield fork(loadPeople)
        yield fork(loadPlanets)

        const people = yield join(task)
        
    }
  <h3>All</h3>
  <p>Запускает несколько эффектов параллельно и ждет их завершения</p>

  <h3>Apply</h3>
  <p>Вызывает функцию в контексте первого аргумента</p>

  

</div>
</details>






<br/>

**Веб - технологии**:

<details>
  <summary>1. Что такое HTTP?</summary>
  <div>
    <p>
      Протокол передачи гипертекста (Hypertext Transfer Protocol - HTTP) - это прикладной протокол для передачи гипертекстовых документов, таких как HTML. Он создан для связи между веб-браузерами и веб-серверами, хотя в принципе HTTP может использоваться и для других целей. Протокол следует классической клиент-серверной модели, когда клиент открывает соединение для создания запроса, а затем ждет ответа. HTTP - это протокол без сохранения состояния, то есть сервер не сохраняет никаких данных (состояние) между двумя парами "запрос-ответ". Несмотря на то, что HTTP основан на TCP/IP, он также может использовать любой другой протокол транспортного уровня с гарантированной доставкой.
    </p>
    <p>
      Ниже перечислены общие функции, управляемые с HTTP:
    </p>
    <ul>
      <li>
        <b>Кэш.</b> Сервер может инструктировать прокси и клиенты: что и как долго кэшировать. Клиент может инструктировать прокси промежуточных кэшей игнорировать хранимые документы.
      </li>
      <li>
        <b>Ослабление ограничений источника.</b> Для предотвращения шпионских и других, нарушающих приватность, вторжений, веб-браузер обчеспечивает строгое разделеление между веб-сайтами. Только страницы из того же источника могут получить доступ к информации на веб-странице. Хотя такие ограничение нагружают сервер, заголовки HTTP могут ослабить строгое разделение на стороне сервера, позволяя документу стать частью информации с различных доменов (по причинам безопасности).
      </li>
      <li>
        <b>Аутентификация.</b> Некоторые страницы доступны только специальным пользователям. Базовая аутентификация может предоставляться через HTTP, либо через использование заголовка WWW-Authenticate и подобных ему, либо с помощью настройки спецсессии, используя куки.
      </li>
      <li>
        <b>Прокси и тунелирование.</b> Серверы и/или клиенты часто располагаются в интранете, и скрывают свои истинные IP-адреса от других. HTTP запросы идут через прокси для пересечения этого сетевого барьера. Не все прокси -- HTTP прокси. SOCKS-протокол, например, оперирует на более низком уровне. Другие, как, например, ftp, могут быть обработаны этими прокси.
      </li>
      <li>
        <b>Сессии.</b> Использование HTTP кук позволяет связать запрос с состоянием на сервере. Это создает сессию,  хотя ядро HTTP -- протокол без состояния.  Это полезно не только для корзин в интернет-магазинах, но также для любых сайтов, позволяющих пользователю настроить выход.
      </li>
    </ul>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/Overview">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>2. Из чего состоит HTTP-запрос?</summary>
  <div>
    <img src='https://mdn.mozillademos.org/files/13687/HTTP_Request.png' />
    <p>
      Запросы содержат следующие элементы:
    </p>
    <ul>
      <li>
        HTTP-метод, обычно глагол подобно GET, POST или существительное, как OPTIONS или HEAD, определяющее операцию, которую клиент хочет выполнить. Обычно, клиент хочет получить ресурс (используя GET) или передать значения HTML-формы (используя POST), хотя другие операция могут быть необходимы в других случаях.
      </li>
      <li>
        Путь к ресурсу: URL ресурсы лишены элементов, которые очевидны из контекста, например без protocol (http://), domain (здесь developer.mozilla.org), или TCP port (здесь 80).
      </li>
      <li>
        Версию HTTP-протокола.
      </li>
      <li>
        Заголовки  (опционально), предоставляюшие дополнительную информацию для сервера.
      </li>
      <li>
        Или тело, для некоторых методов, таких как POST, которое содержит отправленный ресурс.
      </li>
    </ul>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/Overview">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>3. Какие методы может иметь HTTP-запрос?</summary>
  <div>
    <p>
      HTTP определяет множество методов запроса, которые указывают, какое желаемое действие выполнится для данного ресурса. Несмотря на то, что их названия могут быть существительными, эти методы запроса иногда называются HTTP глаголами. Каждый реализует свою семантику, но каждая группа команд разделяет общие свойства: так, методы могут быть безопасными, идемпотентными или кэшируемыми.
    </p>
    <ul>
      <li>
        <b>GET</b> запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.
      </li>
      <li>
        <b>HEAD</b> запрашивает ресурс так же, как и метод GET, но без тела ответа.
      </li>
      <li>
        <b>POST</b> используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.
      </li>
      <li>
        <b>PUT</b> заменяет все текущие представления ресурса данными запроса.
      </li>
      <li>
        <b>DELETE</b> удаляет указанный ресурс.
      </li>
      <li>
        <b>CONNECT</b> устанавливает "туннель" к серверу, определённому по ресурсу.
      </li>
      <li>
        <b>OPTIONS</b> используется для описания параметров соединения с ресурсом.
      </li>
      <li>
        <b>TRACE</b> выполняет вызов возвращаемого тестового сообщения с ресурса.
      </li>
      <li>
        <b>PATCH</b> используется для частичного изменения ресурса.
      </li>
    </ul>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>4. Что такое Cross-Origin Resource Sharing (CORS)?</summary>
  <div>
    <p>
      Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.
    </p>
    <p>
      В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки.
    </p>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/CORS">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>5. Что такое HTTP cookie и для чего их используют?</summary>
  <div>
    <p>
      HTTP cookie (web cookie, cookie браузера) - это небольшой фрагмент данных, отправляемый сервером на браузер пользователя, который тот может сохранить и отсылать обратно с новым запросом к данному серверу. Это, в частности, позволяет узнать, с одного ли браузера пришли оба запроса (например, для аутентификации пользователя). Они запоминают информацию о состоянии для протокола HTTP, который сам по себе этого делать не умеет.
    </p>
    <p>
      Cookie используются, главным образом, для:
    </p>
    <ul>
      <li>
        Управления сеансом (логины, корзины для виртуальных покупок)
      </li>
      <li>
        Персонализации (пользовательские предпочтения)
      </li>
      <li>
        Мониторинга (отслеживания поведения пользователя)
      </li>
    </ul>
    <p>
      Получив HTTP-запрос, вместе с откликом сервер может отправить заголовок  Set-Cookie с ответом. Cookie обычно запоминаются браузером и посылаются в значении заголовка HTTP  Cookie с каждым новым запросом к одному и тому же серверу. Можно задать срок действия cookie, а также срок его жизни, после которого cookie не будет отправляться. Также можно указать  ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту  оно отсылается.
    </p>
    <p>
      Куки можно создавать через JavaScript при помощи свойства Document.cookie. Если флаг HttpOnly не установлен, то и доступ к существующим cookies можно получить через JavaScript.
    </p>

      document.cookie = "yummy_cookie=choco"; 
      document.cookie = "tasty_cookie=strawberry";
   <p><i>Источник: <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%9A%D1%83%D0%BA%D0%B8">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>6. Какие существуют основные принципы ООП?</summary>
  <div>
    <br/>
    <p>
      Базовые принципы ООП:
    </p>
    <ul>
      <li>
        Абстракция — отделение концепции от ее экземпляра;
      </li>
      <li>
        Полиморфизм — реализация задач одной и той же идеи разными способами;
      </li>
      <li>
        Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
      </li>
      <li>
        Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.
      </li>
    </ul>
    <p>
     <i>
       Источник: <a href="https://tproger.ru/translations/oop-principles-cheatsheet/">tproger.ru</a>
     </i>
    </p>
  </div>
</details>

<details>
  <summary>7. Что такое SOLID (объектно-ориентированное программирование)?</summary>
  <div>
    <br/>
    <p>
      SOLID (сокр. от англ. single responsibility, open-closed, Liskov substitution, interface segregation и dependency inversion) в программировании — мнемонический акроним, введённый Майклом Фэзерсом (Michael Feathers) для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов объектно-ориентированного программирования и проектирования. Принципы SOLID — это руководства, которые также могут применяться во время работы над существующим программным обеспечением для его улучшения - например для удаления «дурно пахнущего кода».
    </p>
    <p>
      Избавиться от "признаков плохого проекта" помогают следующие пять принципов SOLID:
    </p>
    <ul>
      <li>
        <b>S</b> -  <p>Принцип единственной ответственности (The Single Responsibility Principle) каждый копмпонент решает только одну задачу.</p>
        <p>Компонент имеет принцип единственной отвественности в том случае если всего один причина для изменения. </p>
      </li>
      <li>
        <b>O</b> - Принцип открытости/закрытости (The Open Closed Principle) «программные сущности должны быть открыты для расширения, но закрыты для модификации.» 
        <p>Каплинг (coupling) понятие основанное на уровне связанности компонентов. Выделяются два тип: </p>
        <p>Сильная связь (Tight coupling) - когда компоненты знают много деталей друг о друге.</p>
        <p>Слабая связь (Loose coupling) - когда компоненты мало знают о друг друге или не знают совсем (малое количество точек связи между компонентами).</p>
        <p>Слабая связь дает следующие плюсы:</p>
        <ul>
          <li>
            <p>Позволяют изменять одну часть приложения не оказывая влияния на остальные</p>
          </li>
          <li>  
            <p>Любой компонент может быть заменен альтернативным</p>
          </li>
          <li>  
            <p>Позволяют переиспользовать компоненты во всем приложении, таким образом отдавая предпочтение принципу "не повторяться"</p>
          </li>
          <li>  
            <p>Не зависимые компоненты проще тестировать, тем самым увеличивается покрытие кода тестами</p>
          </li>
        </ul>
        <li>
          <b>L</b> - Принцип подстановки Барбары Лисков (The Liskov Substitution Principle) «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.» См. также контрактное программирование. Наследующий класс должен дополнять, а не изменять базовый.
        </li>
        <li>
          <b>I</b> - Принцип разделения интерфейса (The Interface Segregation Principle) «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
        </li>
      <li>
        <b>D</b> - Принцип инверсии зависимостей (The Dependency Inversion Principle) «Зависимость на Абстракциях. Нет зависимости на что-то конкретное.» Модули верхних уровней не должны импортировать сущности из модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
      </li>
    </ul>
  </div>
</details>
  
<details>
  <summary>8. Что такое Babel и для чего он используется?</summary>
  <div>
    <br/>
    <p>
      Babel.JS – это транспайлер, переписывающий код на ES-2015 в код на предыдущем стандарте ES5.
    </p>
    <p>
      Обычно Babel.JS работает на сервере в составе системы сборки JS-кода (например webpack или brunch) и автоматически переписывает весь код в ES5.
    </p>
    <p>
      Настройка такой конвертации тривиальна, единственно – нужно поднять саму систему сборки, а добавить к ней Babel легко, плагины есть к любой из них.
    </p>
    <p>
      Конфигурация Babel прописывается в файле babel.config.js, либо в .babelrc для настроек одного пакета, а также в package.json или .babelrc.js
    </p>
    <p>
    Пример конфига в babel.config.js:
      
      module.exports = function (api) {
        api.cache(true);

        const presets = [ ... ];
        const plugins = [ ... ];

        return {
          presets,
          plugins
        };
      }
   </p>
    <p>
     <i>
       Источник: 
        <a href="https://learn.javascript.ru/es-modern-usage#babel-js">learn.javascript.ru</a>, 
        <a href="https://babeljs.io/docs/en/next/configuration">babeljs.io</a>
     </i>
    </p>
  </div>
</details>

<details>
  <summary>9. Для чего используется WebSocket? В чем принцип его работы?</summary>
  <div>
    <br/>
    <p>
      Протокол WebSocket («веб-сокет»), описанный в спецификации RFC 6455, обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.
    </p>
    <p>
      Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:
      <code>
        let socket = new WebSocket("ws://javascript.info");
      </code>
    </p>
    <p>
      Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
    </p>
    <ul>
      <li>
        <b>open</b> – соединение установлено,
      </li>
      <li>
        <b>message</b> – получены данные,
      </li>
      <li>
        <b>error</b> – ошибка,
      </li>
      <li>
        <b>close</b> – соединение закрыто.
      </li>
    </ul>
    <p>
      Вот пример:
    </p>
    <p>
      
      let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");
      
      socket.onopen = function(e) {
        alert("[open] Соединение установлено");
        alert("Отправляем данные на сервер");
        socket.send("Меня зовут Джон");
      };
      
      socket.onmessage = function(event) {
        alert(`[message] Данные получены с сервера: ${event.data}`);
      };
      
      socket.onclose = function(event) {
        if (event.wasClean) {
          alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
        } else {
          // например, сервер убил процесс или сеть недоступна
          // обычно в этом случае event.code 1006
          alert('[close] Соединение прервано');
        }
      };
      
      socket.onerror = function(error) {
        alert(`[error] ${error.message}`);
      };
   </p>
    <p>
      Вызов socket.send(body) принимает body в виде строки или любом бинарном формате включая Blob, ArrayBuffer и другие. Дополнительных настроек не требуется, просто отправляем в любом формате. При получении данных, текст всегда поступает в виде строки. А для бинарных данных мы можем выбрать один из двух форматов: Blob или ArrayBuffer.
    </p>
    <p>
     <i>
       Источник: <a href="https://learn.javascript.ru/websocket">javascript.ru</a>
     </i>
    </p>
  </div>
</details>

<details>
  <summary>10. Что такое DOM (У браузера)?</summary>
  <div>
    <br/>
    <p>
     Браузер выполняет запрос на сервер (предварительно выяснив этот адрес с помощью DNS)
      GET /courses HTTP/1.1
      HOST: ru.hexlet.io
      В ответ сервер отправляет HTML.</p>
    <p> 
      Когда HTML получен, браузер начинает его разбор (говорят парсинг) и формирование внутренней структуры под названием DOM-дерево.
    </p>
    <p>
      Затем это дерево (а не исходный HTML) используется для физической отрисовки страницы, которую мы и наблюдаем.
      Процесс отрисовки страницы браузером
    </p>
    <img src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImE4OWJkOGMxMTk3ZGNkMDVjODUxYmU1OWYwYmNhODViLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=58c5a3d031ffb3f83ab9f54975057ce22b5f4a9625c8b4162deb9cfdd4214952"></img>
  </div>
</details>

<details>
  <summary>11. Что такое REST API ?</summary>
  <div>
    Representational State Transfer (REST) в переводе — это передача состояния представления. Технология позволяет получать и модифицировать данные и состояния удаленных приложений, передавая HTTP-вызовы через интернет или любую другую сеть.
    Application Programming Interface (API), или программный интерфейс приложения — это набор инструментов, который позволяет одним программам работать с другими. API предусматривает, что программы могут работать в том числе и на разных компьютерах. В этом случае требуется организовать интерфейс API так, чтобы ПО могло запрашивать функции друг друга через сеть.
  </div>
</details>

<details>
  <summary>12. Методы REST API ?</summary>
  <div>
   GET /books/ – получает список всех книг. Как правило, это упрощенный список, т.е. содержащий только поля идентификатора и названия объекта, без остальных данных.
   </div>
   <div>
    GET /books/{id} – получает полную информацию о книге.
    </div>
   <div>
    POST /books/ – создает новую книгу. Данные передаются в теле запроса.
    </div>
   <div>
    PUT /books/{id} – изменяет данные о книге с идентификатором {id}, возможно заменяет их. Данные также передаются в теле запроса.
    </div>
   <div>
    OPTIONS /books – получает список поддерживаемых операций для указанного ресурса (практически не используется)
    </div>
   <div>
    DELETE /books/{id}– удаляет данные с идентификатором {id}.
  </div>
  <div>
    Идемпотентный запрос — это запрос, эффект которого от         многократного выполнения равен эффекту от однократного выполнения.
  </div>
</details>
<details>
  <summary>13. Объясните, что такое всплытие и погружение (event bubbling)</summary>
  <div>
    Всплытие и погружение — это фазы жизненного цикла события. Разница заключается в моменте определения факта наступления события. Изначально, при взаимодействии юзера с элементом интерфейса (клик на кнопку, например) событие погружается от объекта window к целевому элементу (target), после наступает стадия всплытия и событие всплывает от target обратно к window. Так, одно и то же событие может быть перехвачено раньше или позже.
  </div>
</details>  

<details>
  <summary>14. Что такое сервис-воркер (service worker)? </summary>
<div>
  Сервис-воркер — это скрипт, который выполняется независимо от веб-страницы, на которой он был запущен, и действий пользователя. Фактически сервис-воркер выполняет роль прокси-сервера между приложением и браузером. Основными возможностями сервис-воркеров является следующее: обеспечение работы приложения в режиме офлайн, периодическая фоновая синхронизация, пуш-уведомления, перехват и обработка сетевых запросов и программное управление кэшем.
</div>
</details>  

<details>
  <summary>15. Что такое веб-хранилище (Web Storage)?</summary>
<div>   
  Веб-хранилище — это интерфейс, позволяющий хранить данные в виде пар ключ/значение локально, т.е. в браузере пользователя, более удобным способом, чем при использовании куки. Веб-хранилище предоставляет два механизма хранения данных:

  Локальное хранилище (local stotage) — хранит данные текущего пользователя неограниченное количество времени
  Сессионное хранилище (session storage) — хранит данные на протяжении текущей сессии, т.е. при закрытии вкладки браузера данные будут потеряны
</div>
</details> 

<details>
  <summary>16. Что такое куки (cookie)?</summary>
<div>   
  Куки — это небольшой фрагмент данных, который сохраняется на компьютере пользователя для последующего использования браузером. Куки сохраняются в виде пар ключ/значение:

  document.cookie = 'username=John'
  <img src="https://habrastorage.org/webt/uv/0q/jv/uv0qjvrn1vx9ruhuxn6aa0aniqg.png"/>
</div>
</details>

<details>
  <summary>17. Зачем нужны куки?</summary>
<div>   
  Куки используются для сохранения информации о пользователе (не рекомендуется использовать для хранения конфиденциальной информации). Обычно, данный процесс состоит из двух этапов:

  При первом посещении страницы профиль пользователя сохраняется в куки
  При повторном посещении страницы профиль пользователя извлекается из куки
</div>
</details>

<details>
  <summary>18. Что такое ООП?</summary>
<div>   
  Куки используются для сохранения информации о пользователе (не рекомендуется использовать для хранения конфиденциальной информации). Обычно, данный процесс состоит из двух этапов:

  При первом посещении страницы профиль пользователя сохраняется в куки
  При повторном посещении страницы профиль пользователя извлекается из куки
</div>
</details>


<details>
  <summary>19. Какими возможностями обладают куки?</summary>
<div>   
  По умолчанию, куки удаляются при закрытии браузера, однако это можно изменить, установив время жизни (expires) (в формате UTC):

  document.cookie = 'username=John; expires=Sat, 5 Sep 2020 12:00:00 UTC'

  По умолчанию, куки принадлежат текущей странице, однако это также можно изменить, установив путь (path):

  document.cookie = 'username=John; path=/services'
</div>
</details>

<details>
  <summary>19. Что такое Веб-компоненты и какие технологии в них используются?</summary>
  <div>
    <br/>
    <p>
      Веб-компоненты — технология, которая позволяет создавать многократно используемые компоненты в веб-документах и веб-приложениях. Веб-компоненты поддерживаются веб-браузерами напрямую и не требуют дополнительных библиотек для работы.
    </p>
    <p>
      Веб-компоненты включают четыре технологии, каждая из которых может использоваться отдельно от других:
    </p>
    <ul>
      <li>
        Custom Elements — API для создания собственных HTML элементов.
      </li>
      <li>
        HTML Templates — тег <template> позволяет реализовывать изолированные DOM-элементы.
      </li>
      <li>
        Shadow DOM — изолирует DOM и стили в разных элементах.
      </li>
      <li>
        HTML Imports — импорт HTML документов.
      </li>
    </ul>
  </div>
</details>
