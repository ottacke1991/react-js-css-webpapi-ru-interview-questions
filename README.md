## Вопросы на собеседовании фронтенд разработчика React.js

Здесь собраны самые популярные вопросы, задаваемые на русскоязычных собеседованиях front-end разработчиков на React.js.  Тематика вопросов включает в себя как основы JavaScript и веб-технологий так и глубокое понимание работы React.js и смежных технологий (Redux, MobX и прочего).Красным цветом обозначены узлы, которые были обновлены. Эти узлы представляют элементы UI, состояние которых изменилось. После этого вычисляется разница между предыдущей и текущей версиями виртуального DOM-дерева. Затем все родительское поддерево подвергается повторному рендерингу для представления обновленного UI. Наконец, это обновленное дерево используется для обновления RDOM.



**CSS**:

<details>
<summary>1. Зачем за ранее указывать размер картинок?</summary>
<div>
  <li> Потому что при загрузке страницы, по мере загрузки картинок, изображение начнет прыгать. </li>  
</div>  
</details>  
  
<details>
<summary>2. Что такое блочная модель, и как, с помощью CSS, менять расположение блоков на странице в браузере?</summary>
<div>
  <li>Блочная модель — модель, при которой каждый элемент представляет собой прямоугольный блок и имеет ширину, высоту, поля, границы и отступы. Менять расположение элементов можно с помощью позиционирования (position), отступов (margin) и трансформирования (transform).</li>  
  <img src="https://vaden-pro.ru/sites/default/files/box-model1.jpg"/>
* </div>  
</details> 

<details>
<summary>3. Что вы можете рассказать о медиа-запросах?</summary>
<div>
  <li> Медиавыражения используются в тех случаях , когда нужно применить разные CSS-стили, для разных устройств по типу отображения (например: для принтера, монитора или смартфона), а также для устройств с определенными характеристиками: ширина (width), высота (height), соотношение ширины к высоте области просмотра (aspect-ratio), ориентация (orientation), разрешение (resolution), количество бит на каждый из цветовых компонентов устройства (color) и другие. </li>  
</div>  
</details>  
  
<details>
<summary>4. Что такое препроцессор и зачем он нужен?</summary>
<div>
  <p>CSS препроцессор (от англ. CSS preprocessor) — это надстройка над CSS, которая добавляет ранее недоступные возможности для CSS, с помощью новых синтаксических конструкций.</p>

  <p>Основная задача препроцессора — это предоставление удобных синтаксических конструкций для разработчика, чтобы упростить, и тем самым, ускорить разработку и поддержу стилей в проектах.</p>

  <p>CSS препроцессоры преобразуют код, написанный с использованием препроцессорного языка, в чистый и валидный CSS-код.</p>
</div>  
</details>  

<details>
<summary>5. Что такое Mixins, переменные и вложенность в препроцессорах?</summary>
<h2>Mixins</h2>
<div>
  Миксины – это шаблоны с готовым CSS-кодом, легко подставляемые к любому из элементов сайта или приложения. Достаточно вписать их название в блок оформления селектора. Миксины отчасти похожи на функции, так как умеют принимать аргументы при использовании. 
</div>  

    @flex ($justify, $align) {
      display: flex;
      justify-content: $justify;
      align-items: $align;
      flex-flow: column;
    }

    div {
      .flex(center, stretch);
    }
<div>
<h2>Переменные</h2>

<p>Да, они есть и в «чистом» CSS, но реализованы менее удобно. </p>

    @colorForButton: #76AB04
    button {
      background: @colorForButton;
    }

<h2>Вложенность</h2>

<p>Благодаря препроцессорам не нужно каждую строку прописывать отдельно. В них действуют элементарные правила вложенности, как и в структуре HTML. </p>

    div {
      dispaly: flex;
      anotherDiv {
        margin: 20px 0px;
      }
      @media (max-width: 720px) {
        position: absolute;
      }
    }

</div>
</details>



<details>
<summary>6. Расскажите про блочные и строчные элементы?</summary>
<div>
<h2>Блочные</h2>
<p> Такой элемент представляет собой прямоугольник, который по умолчанию занимает всю доступную ширину страницы (если иное значение не указано в CSS), а длина элемента зависит от его содержимого. Такой элемент всегда начинается с новой строки, то есть, располагается под предыдущим элементом. Блочный элемент может содержать в себе другие блочные и строчные элементы.

Примеры блочных элементов: ```<div>, <p>, <ul>, <ol>, <h1> ```и т. д.</p>

<h2>Строчные</h2>
<p>В отличие от блочного, строчный элемент не переносится на новую строку, а располагается на той же строке, что и предыдущий элемент. Такие элементы, как правило, находятся внутри блочных элементов и их ширина зависит лишь от содержимого и настроек CSS. Еще одно отличие строчного элемента от блочного заключается к том, что в нем может находиться только контент и другие строчные элементы. Блочные элементы в строчные вкладывать нельзя.

Примеры строчных элементов: ```<a>, <span>, <strong>, <em>, <img>``` и т. д.</p>

<img src="https://idg.net.ua/blog/wp-content/uploads/block-and-inline.png"/>
</div>
</details>



<details>
<summary>7. Какие бывают значения display? Расскажите как ведёт себя каждое свойство?</summary>
<div>

```CSS
  display: block | inline | inline-block | inline-table |
  inline-flex | flex | list-item | none |
  run-in | table | table-caption | table-cell | table-column-group 
  | table-column |
  table-footer-group | table-header-group | table-row | table-row-group
```

<H2>block</H2>

Элемент показывается как блочный. Применение этого значения для строчных элементов, например span, заставляет его вести подобно блокам — происходит перенос строк в начале и в конце содержимого.

<H2>inline</H2>

Элемент отображается как строчный. Использование блочных элементов, таких, как div и p, автоматически создаёт перенос и показывает их содержимое с новой строки. Значение inline отменяет эту особенность, поэтому содержимое блочных элементов начинается с того места, где окончился предыдущий элемент.

<H2>inline-block</H2>

Это значение генерирует блочный элемент, который обтекается другими элементами веб-страницы подобно строчному элементу. Фактически такой элемент по своему действию похож на встраиваемые элементы (вроде img). При этом его внутренняя часть форматируется как блочный элемент, а сам элемент — как строчный.

<H2>inline-table</H2>

Определяет, что элемент является таблицей, как при использовании table, но при этом таблица является строчным элементом и происходит её обтекание другими элементами, например, текстом.

<H2>inline-flex</H2>

Элемент ведёт себя как строчный и выкладывает содержимое согласно флекс-модели.

<H2>flex</H2>

Элемент ведёт себя как блочный и выкладывает содержимое согласно флекс-модели.

<H2>list-item</H2>

Приведёт к тому, что элемент будет вести себя как элемент списка.
</div>  
</details>  

<details>
<summary>8. Какие бывают значения у свойства position? Расскажите как ведёт себя каждое свойство?</summary>
<div>
  
```CSS
  position: absolute | fixed | relative | static | sticky
```  

<img src="https://chenhuijing.com/assets/images/posts/css-positioning.jpg" />

<h1>Нормальный поток</h1>
<H2>relative</H2>

Относительное позиционирование. Cмещает элемент относительно того места, где он должен находится в нормальном потоке. (top - смещение сверху на указанные единицы , right смещает относительно правой стороны "статичного" положения и тд и тп). Элемент остается в потоке.

<H2>static</H2>

Статичное позиционирование. Элементы отображаются как обычно. Использование свойств left, top, right и bottom не приводит к каким-либо результатам. Элемент остается в потоке.

<h1>Поток с абсолютным позиционированием</h1>

<H2>absolute</H2>

Абсолютное позиционирование. Элемент удаляется из потока и позиционируется относительно ближайшего позиционированного предка (т.е. любого не статичного).Другие элементы отображаются на веб-странице словно абсолютно позиционированного элемента и нет. 

Блочные элементы при АП начинают напоминать строчные. Они перестают занимать всю ширину, потому что больше не находятся в потоке.  Занимают ширину только своего контента и отступов (внутренних  и внешних). 

Если указать left и right одновременно = 0. То блок растянется на всю рабочую ширину браузера. Так как должен находиться и в левой и в правой крайней точке.

<H2>fixed</H2>

Фиксированное позиционирование. По своему действию это значение близко к absolute, но в отличие от него привязывается к указанной свойствами left, top, right и bottom точке на экране и не меняет своего положения при прокрутке веб-страницы. Отличительной чертой фиксированного позиционирования является то, что элемент позиционируется относительно ТОЛЬКО (не дрегого позиционированного элемента) видимой области браузера.


<H2>sticky</H2>

Это сочетание относительного и фиксированного позиционирования. Элемент рассматривается как позиционированный относительно , пока он не пересекает определённый порог, после чего рассматривается как фиксированный.

Состоит из двух основных частей: «липкого» элемента и «липкого» контейнера.
«Липкий» элемент — это элемент, которому мы задали position: sticky. Элемент будет становиться плавающим, как только область видимости достигнет определённой позиции, например top: 0px.

Пример:
.some-component {
  position: sticky;
  top: 0px;
}

«Липкий» контейнер — это HTML-элемент, который оборачивает «липкий» элемент. Это максимальная область, в которой может перемещаться наш элемент.

<h2>Тонкости:</h2>

  Не залипает если является единственным ребенком своего родителя.
  Без хотя бы top:0px; не залипает.
</div>  
</details> 


<details>
<summary>9. Расскажите про float?</summary>
<div>
<p>Плавающий элемент (float : right; или float: left;)
вынимается из потока и “прижимается” (“притягивается”, “плывёт”) к левой или правой стороне содержащего блока. Поток всё также идет от самого верха родительского элемента-контейнера, но ширина потока уменьшается на ширину плавающего элемента.
После “плавающего” элемента поток опять займёт всю доступную ширину.</p>
<br />
  
<p>Если в блоке-контейнере нет элементов кроме плавающих (как в первом примере из предыдущего урока) его высота равна нулю, контейнер ведет себя как пустой, потому что плавающие элементы удалены из потока. </p>
<br />

</div>  
</details>  
  
<details>
<summary>10. Какие существуют методы очистки floats и какие из них подходят для какого контекста ?</summary>
<div>
<img src="https://miro.medium.com/max/1400/1*ZCnZj_89gK7qs_FnQ9qzlQ.png" />

<br /> 
  
  left, right, both
  
<h2>Есть несколько основных способов, как реализуется clear:</h2>

<p>Использование правила clear: both для элемента, который необходимо «очистить».</p>

<p>Создание пустого блочного элемента. У него впоследствии указывается правило clear: both.</p>


<p>Свойство overflow со значением hidden. Само по себе свойство overflow управляет отображением содержимого блока (добавляет полосы прокрутки, обрезает не поместившийся контент), в добавок, значения auto, scroll или hidden отменяют свойство float. В данном случае текс уменьшится на ширину флоата по всей длинне.</p>

</div>  
</details> 

<details>
<summary>11. Расскажите о различия padding и margin?</summary>

<img src="https://webcodius.ru/wp-content/uploads/2014/11/otstup.png" />
<div>
<H2>margin</H2>

  Это расстояние между границей текущего элемента веб-страницы и границами соседних элементов, либо родительского элемента. Размер расстояния регулируется свойством margin. Такой отступ находится вне элемента.

<H2>padding</H2>

  Это расстояние от воображаемой границы элемента до его содержимого. Величина расстояния задается с помощью параметра padding. Такой отступ принадлежит самому элементу и находится внутри него.
</div>  
</details>  
  


<details>
<summary>12. Как ведут себя margin у двух элементов по соседству?</summary>
<div>
У блочных элементов расположенных рядом друг с другом по вертикали наблюдается эффект схлопывания, когда отступы не суммируются, а объединяются между собой. Само схлопывание действует на два и более блока (один может быть вложен внутрь другого) с отступами сверху или снизу, при этом примыкающие отступы комбинируются в один. Для отступов слева и справа схлопывание никогда не применяется.

<p>Схлопывание не срабатывает:</p>

<p>для элементов, у которых на стороне схлопывания задано свойство padding.</p>
<p>для элементов, у которых на стороне схлопывания задана граница; на элементах с абсолютным позиционированием, т. е. таких, у которых position установлено как absolute;</p>
<p>на плавающих элементах (для них свойство float задано как left или right);</p>
<p>для строчных элементов;</p>
<p>для html.</p>

</div>  
</details>  
  


<details>
<summary>13. Какие вы знаете псевдоэлементы? Где их используют??</summary>
<div>
<br/>
<p>Псевдоэлемент — это дополнение к селектору, с помощью которого можно стилизовать элемент, не определённый в структуре HTML документа. Добавляется он к селектору c помощью символов ::, т.е. так селектор::псевдоэлемент
</p>
<h1>Самые «ходовые»:</h1>

<h2>:after</h2>
<h2>:before</h2>

  Предназначены для создания псевдоэлемента внутри элемента перед/после его контента. По умолчанию данный псевдоэлемент имеет display: inline. Если псевдоэлементу before нужно установить другое отображение, то его нужно указать явно (например: display: block).

  Содержимое данного псевдоэлемента задаётся с помощью CSS свойства content. При этом если псевдоэлемент будет без содержимого, то данное свойство всё равно необходимо указывать и использовать в качестве его значения пустую строку content: "". Без указания content псевдоэлемент отображаться не будет.

  Псевдоэлемент before не наследует стили. Поэтому если необходимо чтобы у него были стили как у родительского элемента, то ему необходимо их явно прописывать.
  <br/>

<h2>:placeholder</h2>

  Псевдоэлемент, с помощью которого задаётся стилевое оформление подсказывающего текста, созданного атрибутом

<h2>:selection</h2>

  Применяет стиль к выделенному пользователем тексту. В правилах стилей допускается использовать следующие свойства: color, background и background-color.

</div>  
</details>  
  


<details>
<summary>14. Что такое БЭМ?</summary>

  .block__element_mod
<div>
  БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая «Copy-Paste».
</div>  
<p>
  Блок — это независимый интерфейсный компонент. Блок может быть простым или составным (содержать другие блоки). При создании блока нужно обеспечивать возможность его использования в любом месте web-страницы, а также повторения в том же самом месте страницы (родительском элементе). Блок должен включать в себя всю реализацию, необходимую для представления части интерфейса, которую он выражает.
</p>
<p>
  Элемент — это составная часть блока. Элементы контекстно-зависимы: они имеют смысл только в рамках своего блока. Элемент — не обязательная составляющая блока, небольшие блоки обходятся без элементов.
</p>
<p>
  Модификатор — это свойство блока или элемента, задающее изменения в их внешнем виде или поведении. Модификатор может быть булевым (например, button_big) или парой ключ-значение (например, menu_type_bullet, menu_type_numbers). У блока или элемента может быть несколько модификаторов одновременно.
</p>

<h2>Правила формирования имен</h2>
block-name__elem-name_mod-name_mod-val

Имена записываются латиницей в нижнем регистре.

Для разделения слов в именах используется дефис (-).

Имя блока задает пространство имен для его элементов и модификаторов.

Имя элемента отделяется от имени блока двумя подчеркиваниями (__).

Имя модификатора отделяется от имени блока или элемента одним подчеркиванием (_).

Значение модификатора отделяется от имени модификатора одним подчеркиванием (_).

Значение булевых модификаторов в имени не указывается.


</p>
</details>  
  

 
<details>
<summary>15. Что такое семантические элементы и для чего они нужны?</summary>
<div>
  <img src="https://html5css.ru/html/img_sem_elements.gif" />
  
    <article>	Определяет статью
    <aside>	Определяет блок сбоку от основного контента
    <details>	Определяет дополнительную информацию, которую пользователь может открывать или закрывать
    <figcaption>	Определяет пояснение для элемента <figure>
    <figure>	Используется для группирования различных самодостаточных элементов - иллюстраций, диаграмм, фотографий, листингов кода и т.д.
    <footer>	Определяет "подвал" документа или раздела
    <header>	Определяет "шапку" документа или раздела
    <main>	Определяет основной контент документа
    <mark>	Определяет маркированный/подсвеченный текст
    <nav>	Определяет блок навигационных ссылок
    <section>	Определяет раздел в документе
    <summary>	Определяет видимый заголовок элемента <details>
    <time>	Определяет дату/время

  <p>В качестве примера не семантических элементов можно привести теги <'div> и <'span>. Они ничего не говорят о характере их контента.

  Примеры семантических элементов: <'form>, <'table> и <'article>. Они четко описывают, какого характера контент они содержат.

  Семантические элементы HTML5 поддерживаются всеми современными браузерами.</p>

  <p></p>
</div> 
</details>



<details>
<summary>16. Что такое box-sizing: border-box?</summary>
<div>
  <b>content-box</b>
  <p>Это значение по умолчанию. В этом случае свойства width/height обозначают то, что находится внутри padding.</p>
  
  <b>border-box</b>
  <p>Значения width/height задают высоту/ширину всего элемента.</p>

  <img src="https://learn.javascript.ru/article/box-sizing/border-box.svg" />


</div> 
</details>


<br/> 
  
**JavaScript**:

<details>
<summary>1. Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования? (L)</summary>
<div>

  <h2>Парадигма программирования.</h2>
  <p>Парадигма программирования это подход к конструированию программного обеспечения, основанный на нескольких определяющих принципах. Функциональное программирование это одна из таких парадигм, которая состоит из чистых функций (Pure Function), и позволяет избежать разделяемого состояния (Shared State), изменчивых данных (Mutable Data) и побочных эффектов (Side effect). Функциональное программирование является больше декларативным, чем императивным. Cостояние приложения в функциональном программировании, в отличие от объектно-ориентированного программирования, протекает через чистые функции.

  Код в функциональном программировании имеет тенденцию быть более кратким, более предсказуемым и более простым для     тестирования, чем императивный код, но он может быть сложным для обучения.</p>

  <h2>Чистые функции (Pure functions)</h2>
  <p>Первое фундаментальное понятие это чистые функции. Чистые функции задействованы в надежном параллелизме (concurrency), React/Redux приложениях и функциональном программировании. Рассмотрим, что делает функцию «чистой»:

  <ul>
    <li>чистая функция всегда возвращает одинаковое значение при одинаковых входах;</li>
    <li>чистая функция не имеет побочных эффектов.</li>
  </ul>
  
  
  Чистые функции полностью независимы от внешнего состояния и, следовательно, невосприимчивы ко многим ошибкам, связанным с разделяемым и изменчивым состоянием. Благодаря этому, чистые функции чрезвычайно легко перемещать. С ними легко делать рефакторинг и реорганизацию кода, что адаптирует программы к будущим изменениям.
  </p>



  <h2>Композиция (Function composition)</h2>
  <p>Композиция функций — это способ объединения чистых функций для создания более сложных. Подобно обычной композиции функций в математике, результат одной функции передается в качестве аргумента следующей, а результат последней является результатом целого.</p>
  
  <h2>Каррированная функция (Curried functions)</h2>
  <p>Каррированные функции — это функции, которые принимают несколько параметров, только по одному за раз (имеют целую армию из одного параметра). Их можно создать в JavaScript с помощью функций высокого порядка.</p>


  <h2>Предотвращение разделяемого состояния(Preventing Shared State)</h2>
  <p>Разделяемое состояние это любая переменная, объект или пространство памяти, которые существуют в общей области (shared scope), или свойство объекта, передаваемое между областями. Проблема с разделяемым состоянием состоит в том, что нужно знать всю историю каждой общей переменной, которую функция использует или затрагивает, чтобы понять результат вызова функции. Вторая проблема, связанная с общим состоянием, заключается в том, что изменение порядка вызова функций может вызвать ряд сбоев.

  Функциональное программирование избегает разделяемое состояние, используя структуры неизменных данных и чистые вычисления для получения новых данных из уже существующих.
  </p>

  <h2>Неизменность(Immutable)</h2>
  <p>Неизменный объект (immutable object) это объект, который нельзя изменить после его создания. Если вы хотите изменить неизменяемый объект, лучше всего создать новый объект с новым значением. Неизменность это ключевое понятие функционального программирования. Без него теряется история состояний, и ошибки могут проникнуть в вашем программное обеспечение.</p>

  <h2>Побочные эффекты(Side-effects)</h2>
  <p>Побочный эффект (Side Effect) это любое изменение состояния приложения, которое наблюдается за пределами вызываемой функции, кроме ее возвращаемого значения. Примеры побочных эффектов:

  <ul>
    <li>изменение любой внешней переменной или свойства объекта;</li>
    <li>вход в консоль;</li>
    <li>запись в файл.</li>
  </ul>

  Функциональное программирование позволяет избежать побочных эффектов, что облегчает расширение, рефакторинг, отладку, тестирование и обслуживание программы.</p>


  <p>Функциональное программирование предпочитает чистые функции вместо разделяемого состояния и побочных эффектов, неизменность вместо изменяемых данных и композицию функций вместо обязательного управления потоком. Функциональное программирование часто легче понять, потому что оно не меняет состояние и зависит только от предусмотренного ввода.</p>

  Объект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования.


  <a href="https://frontend-stuff.com/blog/javascript-functional-programming/">функциональное программирование</a>
</div>
</details>

<details>
<summary>2. Hoisting?</summary>
<div>
  Hoisting - не существует на самом деле. Это выдуманная концепция. Это метафора для описания того, что на самом деле происходит, когда компилятор находит объявления переменных и связывает их с областью действия, к которой они принадлежат, чтобы их можно было использовать в этой области.

  Это механизм перемещения объявления переменных и функций в верхнюю часть области видимости функции (или глобальной области видимости, если она находится вне какой-либо функции).
</div>  
  <p>Hoisting влияет на жизненный цикл переменной, который состоит из следующих 3 шагов:</p>

  <ul>
    <li>Declaration - создать новую переменную. Например. переменная. myValue</li>
    <li>Initialization - инициализировать переменную значением. myValue = 150</li>
    <li>Usage - получить доступ и использовать значение переменной. alert(myValue)</li>
  </ul>

    // Declare
    var strNumber; 
    // Initialize
    strNumber = '16';
    // Use
    parseInt(strNumber); // => 16

  <p>JavaScript не следует строго этой последовательности и предлагает большую гибкость. Например, перед объявлением можно использовать функции: use -> declare.</p>

  <p>Это происходит потому, что объявление функции в JavaScript поднимается наверх области видимости.

Hoisting действует по-разному:

<ul>
  <li>объявления переменных: использование ключевых слов var, let или const</li>
  <li>объявления функций: использование синтаксиса function name () {...}</li>
  <li>объявления класса: использование ключевого слова класса</li>
</ul>
</p>

<p>Разница между объявлениями var / function и объявлениями let / const / class заключается в инициализации. Первые инициализируются с неопределенным значением undefined. Однако, вторые, лексически объявленные переменные, остаются не инициализированными. Это означает, что ReferenceError выбрасывается при попытке доступа к ним. Они будут инициализированы только после того, как операторы let / const / class будут определены. Всё что до, называется временной мертвой зоной.</p>

<p>Временная мертвая зона - это не синтаксическое местоположение, а время между созданием переменной(DECLARE) и инициализацией. Ссылка на переменную в коде над объявлением не является ошибкой, если этот код не выполняется (например, тело функции или просто мертвый код), но ошибка будет выдана, если мы запросим доступ к переменной до её инициализации.</p>

<p>
  <b>Var:</b>
  <br/>
  Переменные, объявленные с помощью var, поднимаются в верхнюю часть области действия  функции. Если к переменной обращаются до объявления, она оценивается как undefined.
  Когда переменная поднимается, объявление перемещается вверх, но начальное присвоение значения остается на месте:

    // Declare num variable
    var num;
    console.log(num); // => undefined
    // Declare and initialize str variable
    var str = 'Hello World!';
    console.log(str); // => 'Hello World!'

  С объявлениями var невозможно отличить объявленную переменную от инициализированной переменной, потому что объявления var автоматически инициализируются в начале области видимости, поэтому они доступны для использования во всей области видимости. Вы не можете наблюдать uninitialized объявление var.
</p> 
<p>Синтаксис var позволяет не только объявлять, но и    сразу  присваивать начальное значение: var str = 'начальное значение'. Когда переменная поднимается, объявление перемещается вверх, но начальное присвоение значения остается на месте:</p>

    function sum(a, b) {
      console.log(myString); // => undefined
      var myString = 'Hello World';
      console.log(myString); // => 'Hello World'
      return a + b;
    }
    sum(16, 10); // => 26

<p>
<b>Let/Const:</b>
<br/>

    function isTruthy(value) {
      var myVariable = 'Value 1';
      if (value) {
        /**
        * temporal dead zone for myVariable
        */
        // Throws ReferenceError: myVariable is not defined
        console.log(myVariable);
        let myVariable = 'Value 2';
        // end of temporary dead zone for myVariable
        console.log(myVariable); // => 'Value 2'
        return true;
      }
      return false;
    }
    isTruthy(1); // => true

  Возникает интересный вопрос: действительно ли myVariable поднята до начала блока, или может быть просто не определена во временной мертвой зоне (до объявления)? Исключение ReferenceError выдается также, когда переменная вообще не определена.

  Если вы посмотрите на начало функционального блока, var myVariable = 'Value 1' объявляет переменную для всей области действия функции. В блоке if (value) {...}, если бы переменные let не покрывали переменные внешней области видимости, то во временной мертвой зоне myVariable имело бы значение 'Value 1', чего не происходит. Таким образом, блочные переменные грубо подняты.

  <b>В точном описании, когда движок встречает блок с оператором let, сначала переменная объявляется в верхней части блока. В объявленном состоянии переменная по-прежнему не может использоваться, но она покрывает переменную из внешней области видимости с тем же именем. Позже, когда передается строка let myVar, переменная находится в инициализированном состоянии и может использоваться.</b>

  расширение let во всем блоке защищает переменные от модификации внешними областями видимости даже до объявления. Генерация ошибок ссылок при доступе к переменным let во временной мертвой зоне обеспечивает лучшую практику кодирования: сначала объявить, а затем использовать.
</p>


<p>
<b>Функция:</b>
<br/>
  Подъем в объявлении функции позволяет использовать функцию в любом месте включающей области видимости, даже до объявления. Другими словами, функция может быть вызвана из любого места текущей или внутренней области видимости (без неопределенных значений, временных мертвых зон или ошибок ссылок).

  <b>Обратите внимание на разницу между объявлением функции function name() {...} и выражением функции var name = function() {...}. Оба используются для создания функций, однако имеют разные механизмы подъема. Следующий пример демонстрирует различие (TypeError: substraction is not a function):</b>
</p>

    // Call the hoisted function
    addition(4, 7); // => 11
    // The variable is hoisted, but is undefined
    substraction(10, 7); // TypeError: substraction is not a function
    // Function declaration
    function addition(num1, num2) {
      return num1 + num2;
    }
    // Function expression
    var substraction = function (num1, num2) {
      return num1 - num2;
    };

<p>
<b>Класс:</b>
<br/>
Переменные класса регистрируются в начале области блока. Но если вы попытаетесь получить доступ к классу до определения, JavaScript выдаст ReferenceError: имя не определено. Таким образом, правильный подход заключается в том, чтобы сначала объявить класс, а затем использовать его для создания экземпляров объектов.

Hoisting в объявлениях классов похож на переменные, объявленные с помощью оператора let.
</p>

</details> 


<details>
<summary>3. Что такое область видимости (Scope)?</summary>
  Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).

  Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде.

    // глобальное пространство имен
    var g = 'global'

    function globalFunc() {
        function innerFunc() {
            console.log(g) // имеет доступ к переменной g, поскольку она является глобальной
        }
        innerFunc()
    }

  Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.

    function myFavouriteFunc(a) {
        if (true) {
            var b = 'Hello ' + a
        }
        return b
    }
    myFavouriteFunc('World')

    console.log(a) // Uncaught ReferenceError: a is not defined
    console.log(b) // не выполнится

  Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него. Блок кода не создает область для переменных var, в отличие от тела функции. 

    function testBlock() {
        if (true) {
            let z = 5
        }
        return z
    }

    testBlock() // Uncaught ReferenceError: z is not defined

  Модульная область видимости - ES2015 также создает область видимости для переменных, функций, классов.

    // "circle" module scope
    const pi = 3.14159;
    console.log(pi); // 3.14159
    // Usage of pi

  Переменная pi объявлена ​​в рамках модуля Circle. Также переменная pi не экспортируется из модуля.

  Затем импортируется модуль circle:

    import './circle';
    console.log(pi); // throws ReferenceError


  Лексическая область видимости -состоит из внешних областей видимости, определенных статически.

    function outerFunc() {
      // the outer scope
      let outerVar = 'I am from outside!';
      function innerFunc() {
        // the inner scope
        console.log(outerVar); // 'I am from outside!'
      }
      return innerFunc;
    }
    const inner = outerFunc();
    inner();

  Посмотрите на последнюю строку фрагмента inner(): вызов innerFunc() происходит за пределами области externalFunc(). Тем не менее, как JavaScript понимает, что значение externalVar внутри innerFunc() соответствует переменной externalVar функции externalFunc()?

  Ответ: благодаря лексической области.

  <b>Лексическая область видимости означает, что доступность переменных определяется статически положением переменных во вложенных областях действия функции: внутренняя область действия функции может получить доступ к переменным из области действия внешней функции.</b>

  В примере лексическая область видимости innerFunc() состоит из области видимости externalFunc().

  Кроме того, innerFunc() является замыканием, поскольку захватывает переменную externalVar из лексической области видимости.


  <b>Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain).</b>

    // цепочка областей видимости
    // внутренняя область видимости -> внешняя область видимости -> глобальная область видимости

    // глобальная область видимости
    var variable1 = 'Comrades'
    var variable2 = 'Sayonara'

    function outer() {
        // внешняя область видимости
        var variable1 = 'World'

        function inner() {
            // внутренняя область видимости
            var variable2 = 'Hello'
            console.log(variable2 + ' ' + variable1)
        }
        inner()
    }
    outer()
    // в консоль выводится 'Hello World',
    // потому что variable2 = 'Hello' и variable1 = 'World' являются ближайшими
    // к внутренней области видимости переменными
  <img src="https://habrastorage.org/r/w1560/webt/r6/07/q7/r607q7hehfjmuicf0_icntddk2s.png" />
</details> 



<details>
<summary>4. var VS let VS const?</summary>
<div>
  Сперва сравним var и let. Главное отличие let в том, что область видимости переменной ограничивается блоком, а не функцией. Другими словами, переменная, созданная с помощью оператора let, доступна внутри блока, в котором она была создана и в любом вложенном блоке. Говоря «блок», я имею ввиду всё что вложено между фигурными скобками {}, как например в цикле for или условии if.

  Var выходит за пределы блоков if, for и подобных. Это происходит потому, что на заре развития JavaScript блоки кода не имели лексического окружения. Поэтому можно сказать, что var – это пережиток прошлого.  Но var не может выйти за пределы блока функции.

  <h2>«var» допускает повторное объявление</h2>

  Если в блоке кода дважды объявить одну и ту же переменную let, будет ошибка:

    let user;
    let user; // SyntaxError: 'user' has already been declared
    Используя var, можно переобъявлять переменную сколько угодно раз. Повторные var игнорируются:

    var user = "Pete";

    var user; // ничего не делает, переменная объявлена раньше
    // ...нет ошибки

    alert(user); // Pete
    Если дополнительно присвоить значение, то переменная примет новое значение:

    var user = "Pete";

    var user = "John";

    alert(user); // John

  <h2>«var» обрабатываются в начале запуска функции</h2>

  Объявления переменных var обрабатываются в начале выполнения функции (или запуска скрипта, если переменная является глобальной).

  Другими словами, переменные var считаются объявленными с самого начала исполнения функции вне зависимости от того, в каком месте функции реально находятся их объявления (при условии, что они не находятся во вложенной функции).


    function sayHi() {
      phrase = "Привет";

      alert(phrase);

      var phrase;
    }
    sayHi();

  Поскольку все объявления переменных var обрабатываются в начале функции, мы можем ссылаться на них в любом месте. Однако, переменные имеют значение undefined до строки с присвоением значения.

  <h2>Итого</h2>

  Существует 2 основных отличия var от let/const:

  Переменные var не имеют блочной области видимости, они ограничены, как минимум, телом функции.
  Объявления (инициализация) переменных var производится в начале исполнения функции (или скрипта для глобальных переменных).

  Эти особенности, как правило, не очень хорошо влияют на код. Блочная область видимости – это удобно. Поэтому много лет назад let и const были введены в стандарт и сейчас являются основным способом объявления переменных.
</div>
</details>

<details>
<summary>5. Какие типы данных существуют в JavaScript?</summary>
<div>
  <h2>Примитивные типы:</h2>
  <p>Все типы данных в JavaScript, кроме объектов, являются иммутабельными (значения не могут быть модифицированы, а только перезаписаны новым полным значением). Например, в отличии от C, где строку можно посимвольно корректировать, в JavaScript строки пересоздаются только полностью. Значения таких типов называются «примитивными значениями».</p>
  <ul>
    <li>
      <b>«number» - </b> - Единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений). Например, бесконечность Infinity получается при делении на ноль. Ошибка вычислений NaN будет результатом некорректной математической операции. 
      Значения ограничены диапазоном ±(253-1).
    </li>
    <li>
      <b>«bigint» - </b>  это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины.
    </li>
    <li>
      <b>«string»</b> - Строка может содержать ноль или больше символов, нет отдельного символьного типа.
    </li>
    <li>
      <b>«boolean» - </b>Булевый (логический) тип <b>«boolean»</b>
    </li>
    <li>
       <b>«undefined» - </b> Специальное значение  Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.
    </li>
    <li><b>«symbol» - </b> для уникальных идентификаторов. Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа. Варианты использования: 1) «Скрытые» свойства объектов (Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны),  2) Существует множество системных символов, используемых внутри JavaScript, доступных как Symbol.*. Мы можем использовать их, чтобы изменять встроенное поведение ряда объектов. Например, в дальнейших главах мы будем использовать Symbol.iterator для итераторов, Symbol.toPrimitive для настройки преобразования объектов в примитивы и так далее. 
    <p>Символ — это уникальное примитивное значение. Если подходить к символам с этой позиции, то можно заметить, что символы в этом плане похожи на объекты, так как создание нескольких экземпляров символов приведёт к созданию разных значений. Но символы, кроме того, являются иммутабельными примитивными значениями.</p>
    <p>Symbol не попадает в Object.keys.</p></li>
  </ul>
  <h2>Отдельные типы:</h2>
  <ul>
    <li>
      <b>«object» - </b> Первые 6 типов называют «примитивными». Особняком стоит шестой тип: «объекты». Он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок {...}
    </li>
    <li>
      <b>«null» - </b> Специальное значение В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».  Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в Цепочке Прототипов;
    </li>
  </ul>
  <p>Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной Имеет две формы: typeof x или typeof(x). Возвращает строку с именем типа. Например, "string". Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.</p>
</div>
</details>

<details>
<summary>6. Расскажите про преобразование типов в JavaScript?</summary>

Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.

Строковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает очевидным образом.

Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).

Преобразование подчиняется правилам:

| Значение |	Становится… |
| ---------|--------------|
|undefined	| NaN|
|null |	0|
|true / false |	1 / 0|
|string |	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.

Логическое – Происходит в логических операциях. Может быть вызвано с помощью Boolean(value).|

Подчиняется правилам:

|Значение |	Становится…|
|---------|-----------|
|0, null, undefined, NaN, "" |	false|
|любое другое значение	|true|

Большую часть из этих правил легко понять и запомнить. Особые случаи, в которых часто допускаются ошибки:

undefined при численном преобразовании становится NaN, не 0.

"0" и строки из одних пробелов типа " " при логическом преобразовании всегда true.
</details>

<details>
<summary>7. В чем разница между явным и неявным преобразованием или приведением к типу (Implicit and Explicit Coercion)?</summary>
  
  Неявное преобразование — это способ приведения значения к другому типу без нашего ведома (участия).

  Предположим, у нас есть следующее:

    console.log(1 + '6')
    console.log(false + true)
    console.log(6 * '2')

  Результатом первого console.log будет 16. В других языках это привело бы к ошибке, но в JS 1 конвертируется в строку и конкатенируется (присоединяется) c 6. Мы ничего не делали, преобразование произошло автоматически.

  Результатом второго console.log будет 1. False было преобразовано в 0, true — в 1. 0 + 1 = 1.

  Результатом третьего console.log будет 12. Строка 2 была преобразована в число перед умножением на 6.

  Явное преобразование предполагает наше участие в приведении значения к другому типу:

    console.log(1 + parseInt('6'))

  В этом примере мы используем parseInt для приведения строки 6 к числу, затем складываем два числа и получаем 7.
</details>


<details>
<summary>8. Какие значения в JS являются ложными?</summary>
  
  const falsyValues = ['', 0, null, undefined, NaN, false]

  Ложными являются значения, результатом преобразования которых в логическое значение является false.
  Как проверить, является ли значение ложным?

  Следует использовать функцию Boolean или оператор "!!"    (двойное отрицание).
</details>


<details>
<summary>9. В чем разница между undefined и is not defined?</summary>
undefined - это значение, присваемое объявленной, но не проинициализированной переменной.
Мы получаем undefined, обращаясь к существующей переменной. А в случае обращения к несуществующей (необъявленной) переменной, мы получим ошибку is not defined.
</details>

<details>
<summary>10. Что такое this?</summary>
<p>This это контекст вызова функции. В JavaScript 4 типа вызова функции:

<ul>
  <li>function invocation: alert('Hello World!') (Optional: with strict mode)</li>
  <li>method invocation: console.log('Hello World!')</li>
  <li>constructor invocation: new RegExp('\\d')</li>
  <li>indirect invocation: alert.call(undefined, 'Hello World!')/ .apply</li>
</ul>
<p>Отдельно от них можно отметить: </p>
<ul>
   <li>bound function invocation: multiply.bind(2)</li>
  <li>arrow function invocation: () => {}</li>
</ul>

<h2>function invocation:</h2>

<p>This это глобальная область в function invocation. Глобальный обьект определяется средой исполнения. В браузере глобальный обьект это window.</p>
<img src="https://dmitripavlutin.com/static/7035b35b8d8dce31376d9839065e58f7/19891/2-1.png" />

    function sum(a, b) {
      console.log(this === window); // => true
      this.myNumber = 20; // add 'myNumber' property to global object
      return a + b;
    }
    // sum() is invoked as a function
    // this in sum() is a global object (window)
    sum(15, 16);     // => 31
    window.myNumber; // => 20

<h3>function invocation strict mode:</h3>
<p>This = undefined при вызове функции в строгом режиме</p>

<h3>function invocation распространенные ошибки:</h3>
<p>Обычная ловушка с вызовом функции состоит в том, что вы думаете, что this то же самое во внутренней функции, что и во внешней функции.

Контекст внутренней функции (кроме стрелочной функции) зависит только от ее собственного типа вызова, но не от контекста внешней функции.</p>
Ошибка:

    const numbers = {
      numberA: 5,
      numberB: 10,
      sum: function() {
        console.log(this === numbers); // => true
        function calculate() {
          // this is window or undefined in strict mode
          console.log(this === numbers); // => false
          return this.numberA + this.numberB;
        }
        return calculate();
      }
    };
    numbers.sum(); // => NaN or throws TypeError in strict mode

Корректно:

    const numbers = {
      numberA: 5,
      numberB: 10,
      sum: function() {
        console.log(this === numbers); // => true
        const calculate = () => {
          console.log(this === numbers); // => true
          return this.numberA + this.numberB;
        }
        return calculate();
      }
    };
    numbers.sum(); // => 15



<h2>method invocation:</h2>
<p>This это объект, которому принадлежит метод в вызове метода</p>
<img src="https://dmitripavlutin.com/static/baf7c3a9ba2fa5c631ea32b940d95f95/1c68e/4-1.png" />

<p>В синтаксисе класса ECMAScript 2015 контекст вызова метода также является самим экземпляром</p>

    class Planet {
      constructor(name) {
        this.name = name;
      }
      getName() {
        console.log(this === earth); // => true
        return this.name;
      }
    }
    const earth = new Planet('Earth');
    // method invocation. the context is earth
    earth.getName(); // => 'Earth'

<h3>method invocation распространенные ошибки:</h3>
<p>Разделение метода и обьекта: Метод можно извлечь из объекта в отдельную переменную const alone = myObj.myMethod. Когда метод вызывается только один alone() , отделенный от исходного объекта, вы можете подумать, что this объект myObject, для которого был определен метод.</p>
<p>Правильно сказать, если метод вызывается без объекта, то происходит вызов функции, где this глобальный объект window или undefined в строгом режиме</p>

    function Pet(type, legs) {
      this.type = type;
      this.legs = legs;
      this.logInfo = function() {
        console.log(this === myCat); // => false
        console.log(`The ${this.type} has ${this.legs} legs`);
      }
    }
    const myCat = new Pet('Cat', 4);
    // logs "The undefined has undefined legs"
    // or throws a TypeError in strict mode
    setTimeout(myCat.logInfo, 1000);

<p>Метод отделяется от своего объекта при передаче в качестве параметра: setTimeout(my Cat.logInfo). Следующие случаи эквивалентны:  </p>

    setTimout(myCat.logInfo);
    // is equivalent to:
    const extractedLogInfo = myCat.logInfo;
    setTimout(extractedLogInfo);

<p>Когда разделенный logInfo вызывается как функция, this глобальный объект или неопределенный в строгом режиме (но не объект myCat). Таким образом, информация об объекте записывается неправильно.

👍 Функция связывается с объектом с помощью метода .bind() Если отдельный метод связан с объектом myCat, проблема контекста решается:</p>

    // Create a bound function
    const boundLogInfo = myCat.logInfo.bind(myCat);
    // logs "The Cat has 4 legs"
    setTimeout(boundLogInfo, 1000);

<h2>Constructor invocation:</h2>    
<p>This это вновь созданный объект в вызове конструктора</p>
<img src="https://dmitripavlutin.com/static/a0f6062c2d9848de7c0b569aff17195b/27257/5-1.png" />
<p>Контекст вызова конструктора — это вновь созданный объект. Конструктор инициализирует объект данными, поступающими из аргументов конструктора, устанавливает начальные значения свойств, прикрепляет обработчики событий и т. д.</p>

<h3>constructor invocation распространенные ошибки:</h3>
<p>Забыть про слово new. Использование вызова функции для создания объектов является потенциальной проблемой, поскольку некоторые конструкторы могут опускать логику для инициализации объекта, когда отсутствует ключевое слово new.</p>

    function Vehicle(type, wheelsCount) {
      this.type = type;
      this.wheelsCount = wheelsCount;
      return this;
    }
    // Function invocation
    const car = Vehicle('Car', 4);
    car.type; // => 'Car'
    car.wheelsCount // => 4
    car === window // => true

<p>Вы можете подумать, что это хорошо работает для создания и инициализации новых объектов.

Однако this это объект window в вызове функции, поэтому Vehicle('Car', 4) задает свойства объекта window. Это ошибка. Новый объект не создается.</p>

<h2>Indirect invocation:</h2>  
<p>Indirect вызов выполняется, когда функция вызывается с использованием методов myFun.call() или myFun.apply().</p>
<p>This это первый аргумент .call() или .apply() в косвенном вызове</p>

<p>Функции в JavaScript являются объектами первого класса, что означает, что функция является объектом. Тип функционального объекта — Function.

Из списка методов, которые есть у функционального объекта, .call() и .apply() используются для вызова функции с настраиваемым контекстом.</p>

<h2>Bound function:</h2>

<p>Bound function это функция  чей контекст и/или аргументы  привязаны к определенным значениям. Связанная функция создается с помощью метода .bind(). Исходная и связанная функции имеют один и тот же код и область действия, но разные контексты и аргументы при выполнении.</p>
<img src="https://dmitripavlutin.com/static/96be8894060c323082745bb09e3ba854/b4774/7-1.webp" />

    function multiply(number) {
      'use strict';
      return this * number;
    }
    // create a bound function with context
    const double = multiply.bind(2);
    // invoke the bound function
    double(3); // => 6
    double(10); // => 20

<p>This это первый аргумент функции .bind()</p>
<p>.bind() создает постоянную контекстную ссылку и всегда будет ее сохранять. Связанная функция не может изменить свой связанный контекст при использовании .call() или .apply() с другим контекстом, или даже bind() не имеет никакого эффекта.</p>

<h2>Arrow function:</h2>

<p>Стрелочная функция предназначена для объявления функции в более короткой форме и лексической привязки контекста.</p>
<img src="https://dmitripavlutin.com/static/898df438becd3f7c1ad1193806d8dbc6/7abe2/8-1.png" />
<p>This это билжайший контекст в том месте где определена стрелочная функция.</p>
<p>Стрелочная функция не создает свой собственный контекст выполнения, а берет его из внешней функции, в которой она определена. Другими словами, стрелочная функция разрешает это лексически.</p>

    class Point {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      log() {
        console.log(this === myPoint); // => true
        setTimeout(() => {
          console.log(this === myPoint);      // => true
          console.log(this.x + ':' + this.y); // => '95:165'
        }, 1000);
      }
    }
    const myPoint = new Point(95, 165);
    myPoint.log();

<p>Стрелочная функция связана с лексикой this раз и навсегда. This нельзя изменить даже при использовании методов модификации контекста.</p>

<b>Стрелочная функция распространенные ошибки:</b>
<p>Возможно, вы захотите использовать стрелочные функции для объявления методов объекта. Достаточно справедливо: их объявление довольно короткое по сравнению с функциональным выражением: (param) => {...} вместо function(param) {..}.
</p>

    function Period (hours, minutes) { 
      this.hours = hours;
      this.minutes = minutes;
    }
    Period.prototype.format = () => {
      console.log(this === window); // => true
      return this.hours + ' hours and ' + this.minutes + ' minutes';
    };
    const walkPeriod = new Period(2, 30);
    walkPeriod.format(); // => 'undefined hours and undefined minutes'

<p>Поскольку format является стрелочной функцией и определяется в глобальном контексте (самая верхняя область видимости), он имеет this как объект window.

Даже если  format выполняется как метод объекта walkPeriod.format(), window сохраняется как контекст вызова. Это происходит потому, что стрелочная функция имеет статический контекст, который не меняется при различных типах вызовов.</p>

<p>Function expression решает проблему, потому что обычная функция меняет свой контекст в зависимости от вызова

<b>Итог:</b>
<p>Поскольку наибольшее влияние на this оказывает вызов функции, впредь не спрашивайте себя:</p>

<a>Откуда берется this?</a>

<p>но спросите себя:</p>

<a>Как *`функция вызывается*?</a>

<p>Для стрелочной функции задайте вопрос?</p>

<a>Чем является this внутри внешней функции, в которой определена стрелочная функция?</a>


</details>

<details>
<summary>11. Опишите разницу между == и === в JS ?</summary>

Оба оператора сравнения проверяют тождественность. Различие заключается в том, что двойное равно при сравнении значений неявно приводит (преобразует) типы значений к единому, так строка “1” и цифра 1 при таком сравнении будут равны. Тройное равно не выполняет никаких неявных трансформаций, а значит исходные типы будут иметь значения. Таким образом строка не будет равна числу и не важно что в обоих операндах фигурирует единица.

Строки сравниваются посимвольно в лексикографическом порядке.
Значения разных типов при сравнении приводятся к числу. 

Исключением является сравнение с помощью операторов строгого равенства/неравенства.

Значения null и undefined равны == друг другу и не равны любому другому значению. (при === они не равны)

Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined. Хорошей идеей будет сделать отдельную проверку на null/undefined.

    alert( null >= 0 ); // (3) true
    console.log(1550 >= null) // true
    console.log(1550 >= undefined)  // false
    console.log(2 <= null) // false
    console.log(null <= 2) //true
</details>

<details>
<summary>12. Что такое цикл событий (event loop) и как он работает?</summary>
<div>
  <p>Event loop - это бесконечный цикл в котором движок JavaScript ожидает задачи и исполняет их. </p>

  <h2>JavaScript main thread:</h2>

  <p>Код, написанный на Javascript, выполняется синхронно – одна команда в один момент времени. Код работает в браузере, в котором множество процессов работают параллельно и для взаимодействия с этими процессами придумали следующее:</p>
  <ul>
    <li>Для каждой html страницы в браузере Javascript выполняется в своем отдельном потоке (Main Thread).</li>
    <li>Содержимое тега <script>…</script> или содержимое файла переданного в свойстве тега <script src=”file.js”>…</script> начнёт исполняться в процессе загрузки документа в браузер. Причём подгрузиться он может раньше, чем HTML-элементы</li>
    <li>Для того чтобы взаимодействовать с Web формой в HTML можно назначить функцию обработки на какое-либо событие:
        В HTML: onclick = ‘myFunc()’
        В Javascript: element.addEventListener("click", myFunc(), false);
    </li>
    <li>Для взаимодействия с другими процессами браузера существует набор интерфейсов Web API. При вызове функций этих интерфейсов нужно обязательно в качестве параметра передать функцию обратного вызова (callback function), которой будет передано управление после того, как Web API функция отработает. Эти интерфейсы не ограниченны одним потоком и могут работать параллельно. Кстати, setTimeout() так же является частью Web API.</li>
  </ul>
  <p>Далее при наступлении события или по окончанию работы функции Web API, функции обработки события и функции обратного вызова попадают в очередь - Event Queue. Откуда их извлекает и передаёт на исполнение Event Loop.</p>

  <img src="https://miro.medium.com/max/1400/1*PiFyb7IV8vTDCGEeUOWLVQ.jpeg" />
    <p>Main Thread - основной поток, где браузер выполняет JS.</p>
   <img src="https://habrastorage.org/r/w1560/webt/l0/z9/q2/l0z9q2s-zdltplomxlim269pu7k.png"/>
      <p>На основе этой схемы строится работа всего Event Loop.</p>
   <img src="https://habrastorage.org/r/w1560/webt/zh/lq/ff/zhlqffco6t_lo1sxkql-hoqmlmq.png"/>

  <p><b>Call Stack (На исполнение): </b>это место, где выполняется ваш код (ваши функции загружаются и выполняются, движок V8 в Chrome и NodeJS). Это обычеый LIFO stack(last-in-first-out). Когда он пуст, тоесть выполнил все текущие задачи Tick, он становится готовым принять следующий Tick из цикла событий </p>

  <p><b>Browsers APIs: </b>связь между вашим кодом и внутренними компонентами браузера для планирования задач, взаимодействия с DOM и многого другого (setTimeout, AJAX, createElement, querySelector, append, click, etc.) В случае обратных вызовов они добавят ваш код обратного вызова в Event queue событий, вместо этого, в случае then (метод промиса), ваш then-код будет добавлен в Job queue.</p>

  <p><b>Event queue (Task queue, Callback Queue, Macrotask queue): </b> каждый раз, когда вы добавляете обратный вызов (например, через setTimeout или API AJAX), он добавляется в эту очередь</p>
  <p><b>Job queue (Microtask queue): </b>его очередь зарезервирована для promise then (Promise.prototype.then() и Promise.prototype.catch(), а так же код который выполнится внутри async функций после выполнения таски с ключевым словом await), это очередь с приоритетом, ее смысл примерно такой: «выполнить этот код позже (= асинхронно), но как можно скорее!» (= до следующего тика Event Loop)», и поэтому браузеры ввели эту новую очередь для выполнения спецификаций промисов. Микротаски выполняются сразу после завершения Таски, c которой они связанны. Таким образом это не совсем отдельная очередь. Просто это некий довесок к таске, который должен выполнится сразу после неё. Сюда так же входит код, который выполниться сразу после await, в функции с ключевым словом async.</p>
  <p><b>Next Tick: </b> это то, что будет выполняться дальше, в основном это состоит из ОДНОГО обратного вызова из Event queue, ПОЛНОЙ Job queue (этот момент важен, текущий тик завершится только после того, как очередь заданий будет пуста, поэтому вы можете непреднамеренно заблокировать его выполнение). до следующего тика, если вы постоянно добавляете новые задания в эту очередь), может выполняться повторный рендеринг (выполните необходимые шаги в очереди рендеринга для обновления экрана)</p>

  <p><b>Render Queue: </b> которая отслеживает все изменения DOM модели. На данный момент раз в 16.6 мс. (при 60FPS) происходит перерисовка Web страницы и обновляются все связанные с ней элементы DOM.  Задачи от Render оптимизируются браузером и, если он посчитает, что в этом цикле не нужно ничего перерисовывать, то Event Loop просто пойдет дальше. </p>

  <p>Event Loop работает с очередями в следующем приоритете:</p>
  <ul>
    <li>Render Queue</li>
    <li>Task Queue (или Callback Queue, Macrotask Queue, Event Queue)</li>
    <li>После каждой выполненной Таски выполняются связанные с ней Микротаски</li>
  </ul>

  <img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/9f6/6bd/1c9/9f66bd1c9b406e0026f7f0f74e4afe45.png" />


  <p><b>Next Tick:</b> Когда ваш код выполняется, он может вызывать API-интерфейсы браузера для взаимодействия с DOM или планирования какой-либо асинхронной задачи. Эти асинхронные задачи добавляются в Event queue или в приоритетную Job queue (при использовании промисов). Как только стек вызовов завершает обработку текущего тика (пуст), цикл событий передает ему новый тик (который состоит из ОДНОГО обратного вызова, ПОЛНОЙ очереди заданий и ВОЗМОЖНОСТИ вызова, полностью или только некоторые части, очередь рендеринга).</p>

  <h3>Что происходит в eventloop по шагам:</h3>
  <ul>
    <li>1. Выбирается самая старая  таска (task A) в Event queue</li>
    <li>2. Если task A = null (т е очередь из тасок пуста), переходим на шаг 6</li>
    <li>3. set "текущая запущенная таска"  для task A</li>
    <li>4. run task A (значит запуск ее callback функции)</li>
    <li>5. set "текущая запущенная таска"  = null , удалить task A</li>
    <li>6. Выполнение очереди job queue</li>
    <ul>
      <li>a. Выбирается самая старая  таска (task x) в Job queue</li>
      <li>b. Если task x = null (т е очередь из тасок пуста), переходим на шаг g</li>
      <li>c. set "текущая запущенная таска"  для task x</li>
      <li>d. run task x </li>
      <li>e. set "текущая запущенная таска"  = null , удалить task x</li>
      <li>f. select "следующая самая старая таска" в очереди job queue, переход на шан b</li>
      <li>g. окончание работы с job queue</li>
    </ul>
  </ul>

  <h3>Примеры тасок:</h3>
  <p>macrotasks: setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering
microtasks: process.nextTick, Promises, queueMicrotask, MutationObserver</p>
  <h3>Задача на event loop:</h3>
  <p>Код задачи: </p>

      console.log(1)

      setTimeout( () => {
        console.log(2)
      })

      const promise1 = new Promise( resolve => {
        console.log(3)
        resolve(4)
      })
      
      const promise2 = new Promise( resolve => {
        console.log(5)
        resolve(6)
      })

      promise1.then(console.log)
      promise2.then(console.log)

      console.log(7)

  <p>Решение:  Алгоритм решения. Делим код на "Основной поток кода", "Очередь микрозадач" и "Очередь макрозадач".  </p>

  | Main |	Micro | Macro |
  |--------|-------|------|
  | 1    |   4     |   2  |
  | 3    |   6     |      |
  | 5    |         |      |
  | 7    |         |      |

  <p>Сначала исполняется основной код. Потом очередь Micro, потом очередь Macro.</p>

</div>
</details>


<details>
<summary>13. Что такое web workers, service workers и worklets? В чем разница?</summary>
<div>
  <p>Веб-воркеры, сервис-воркеры и ворклеты все это скрипты которые выполняются в отдельном потоке. </p> 

  <h2>Веб-воркеры:</h2>
  <p>Веб-воркеры являются воркерами общего типа. В отличие от сервис-воркеров и ворклетов как мы увидим ниже, они не имеют конкретных вариантов использования, кроме возможности выполнения в отдельном потоке. Как результат веб-воркеры можно использовать для выгрузки почти любой тяжелой работы из основного потока.</p>

  <p>Данные отправляются между потоком воркера и основным потоком через систему сообщений - обе стороны отправляют свои сообщения с помощью метода postMessage () и отвечают на сообщения через обработчик события onmessage (сообщение содержится в атрибуте данных события  Message. Данные копируются, а не используются совместно.</p>

  <img src="https://miro.medium.com/max/1132/1*196hpA64Umf1vZMjBMGCBg.jpeg" />

      /* main.js */
      const myWorker = new Worker('worker.js');
      // Send message to worker
      myWorker.postMessage('Hello!');
      // Receive message from worker
      myWorker.onmessage = function(e) {
        console.log(e.data);
      }

      /* worker.js */
      // Receive message from main file
      self.onmessage = function(e) {
        console.log(e.data);
      // Send message to main file
        self.postMessage(workerResult);
}

  <h3>useCases:</h3>    
  <p>Хороший пример веб-приложение обработки изображений, Squoosh, который использует веб-воркеры для обработки задач по преобразованию изображений, оставляя основной поток для взаимодействия пользователя с приложением.</p>



  <h2>Сервис-воркеры:</h2>
  <p>Сервис-воркеры — это тип воркеров, которые служат определенной цели, быть прокси между браузером и сетью и/или кэшем. Это прокси между браузером и сетью. Перехватывая запросы, сделанные документом, сервис-воркеры могут перенаправлять запросы, позволяя работать автономно.</p>
  <img src="https://miro.medium.com/max/1400/1*xtvK2OPUXuqHkCYABg1uxw.jpeg" />
  <p>Service worker — это сценарий, который ваш браузер запускает в фоновом режиме отдельно от веб-страницы, открывая доступ к функциям, которым не требуется веб-страница или взаимодействие с пользователем. Сегодня они уже включают такие функции, как push-уведомления и фоновая синхронизация, а также могут перехватывать и обрабатывать сетевые запросы, включая программное управление кешем ответов.</p>

    /* main.js */
    navigator.serviceWorker.register('/service-worker.js');

    /* service-worker.js */
    // Install 
    self.addEventListener('install', function(event) {
        // ...
    });
    // Activate 
    self.addEventListener('activate', function(event) {
        // ...
    });
    // Listen for network requests from the main document
    self.addEventListener('fetch', function(event) {
        // ...
    });

  <p>После перехвата сервис-воркеры могут, например, ответить, вернув документ из кэша вместо того чтобы идти за ним в сеть, тем самым позволяя веб-приложению работать автономно!</p>

    /* service-worker.js */
    self.addEventListener('fetch', function(event) {
        // Return data from cache
        event.respondWith(
            caches.match(event.request);
        );
    });

  <h2>Ворклеты:</h2>
  <p>Ворклеты — это очень легкие и специфичные воркеры. Они позволяют нам как разработчикам подключаться к различным частям процесса рендеринга браузера. Ворклеты это хуки внутри rendering pipeline браузера, позволяющий нам иметь низкоуровневый доступ к процессу рендеринга браузера, таким как вычисление стилей и расчет макета.</p>

  <h3>Типы ворклетов</h3>

  <p>Ворклеты ограничены конкретными вариантами использования; их нельзя использовать для произвольных вычислений, таких как Web Workers. Интерфейс Worklet абстрагирует свойства и методы, общие для всех видов worklet, и не может быть создан напрямую. Вместо этого вы можете использовать один из следующих классов:</p>

  <p><b>PaintWorklet - </b>Для программного создания изображения, где свойство CSS ожидает файл. Получите доступ к этому интерфейсу через CSS.paintWorklet.</p>

  <p><b>AudioWorklet - </b>Для обработки звука с помощью пользовательских AudioNodes.</p>

  <p><b>AnimationWorklet - </b>Для создания связанных с прокруткой и других высокопроизводительных процедурных анимаций.</p>

  <p><b>LayoutWorklet - </b>Для определения положения и размеров пользовательских элементов.</p>


</div>
</details>


<details>
<summary>14. Расскажите про requestAnimationFrame?</summary>
<div>
  <h3>requestAnimationFrame</h3>
  <p>  Указывает браузеру на то, что вы хотите произвести анимацию, и просит его запланировать перерисовку на следующем кадре анимации. В качестве параметра метод получает функцию, которая будет вызвана перед перерисовкой.
  Вы должны вызывать этот метод всякий раз, когда готовы обновить анимацию на экране, чтобы запросить планирование анимации. Обычно запросы происходят 60 раз в секунду, но чаще всего совпадают с частотой обновления экрана. В большинстве браузеров в фоновых вкладках или скрытых <'iframe>, вызовы requestAnimationFrame() приостанавливаются, для того, чтобы повысить производительность и время работы батареи.</p>


    let pos = 0;

    function myAnimation() {
      pos++;
      elem.style.top = pos + "px";
      elem.style.left = pos + "px";

      if (pos < 300) {
        requestAnimationFrame(myAnimation);
      }
    }


    let id = requestAnimationFrame(myAnimation);
    cancelAnimationFrame(id);


  <p>Метод requestAnimationFrame предоставляет разработчикам доступ к жизненному циклу фрейма, позволяя выполнять операции перед вычислением стилей и формированием макета (layout) документа браузером. Вот почему данный метод отлично подходит для реализации анимации. Собственно, для этого он и предназначен.</p> 
  <ul>
    <li>Во-первых, он вызывается не чаще и не реже, чем браузер вычисляет макет (правильная частота). </li>
    <li>Во-вторых, он вызывается перед формированием макета (правильное время). Поэтому rAF также отлично подходит для внесения изменений в DOM или CSSOM. Он синхронизирован с vsync, как и любой другой механизм рендеринга, используемый браузером.</li>
  </ul>
  
  <p>requestAnimationFrame вернет айди для возможности остановки анимации</p>
      var start = null;
      var element = document.getElementById('SomeElementYouWantToAnimate');

      function step(timestamp) {
        if (!start) start = timestamp;
        var progress = timestamp - start;
        element.style.transform = 'translateX(' + Math.min(progress / 10, 200) + 'px)';
        if (progress < 2000) {
          window.requestAnimationFrame(step);
        }
      }

      window.requestAnimationFrame(step);

  
  <h3>Недостатки setTimeout, setInterval.</h3>
  <p>При написании кода, мы вручную устанавливаем, как именно будет происходить анимация покадрово. Частота кадров на мониторе и частота перерисовки браузером контента может быть не постоянной, это зависит от нагрузки, сколько одновременно запущено программ на компьютере клиента. В таких случаях можно наблюдать, как какие-то кадры замирают. Вдобавок частота кадров стремится к какому-то значению. Вот тогда и происходит рассинхронизация: setTimeout принуждает перерисовывать кадры, не синхронно со сменой кадров у компьютера. Однако самая большая проблема состоит в том, что если открыто несколько вкладок браузера, и на одной из них есть анимация, то она все равно работает, активна эта вкладка или нет. В результате, все это ведет к избыточной нагрузке на компьютер.</p>

  <h3>Пример:</h3>

      // HTML разметка
        <button class="btn">Запуск анимации</button>
    <div class="wrapper">
        <div class="box"></div>
    </div>    

  Найдем оба элемента по селектору и поместим их в переменные для наших манипуляций.

    const btn = document.querySelector('.btn'),
        elem = document.querySelector('.box');
    // Изначальная позиция квадрата
          let pos = 0;    

  requestAnimationFrame запускает функцию myAnimation() в виде коллбэка. Когда позиция элемента станет меньше 300, то нужно запустить анимацию, а если больше, то остановить анимацию. За запуск анимации отвечает requestAnimationFrame, таким образом происходит зацикливание анимации. И когда анимация выполнится 300 раз, то перестанет запускаться.

    function myAnimation() {
        pos++; // Увеличиваем позицию квадрата на единицу
        elem.style.top = pos + "px"; // Устанавливаем значение top для инлайн стилей у квадрата
          elem.style.left = pos + 'px'; // // Устанавливаем значение left для инлайн стилей у квадрата

        if (pos < 300) {
            requestAnimationFrame(myAnimation); // Запуск анимации
        }
    }

  Для запуска анимации в первый раз, отслеживаем клик по кнопке btn и вызываем requestAnimationFrame. Для отмены анимации, нужно вызвать метод cancelAnimationFrame с уникальным идентификатором.

    btn.addEventListener('click', () => requestAnimationFrame(myAnimation));

    let id = requestAnimationFrame(myAnimation);
    cancelAnimationFrame(id);    

  <h3>Жизненный цикл фрейма:</h3>
  <img src="https://miro.medium.com/max/1400/1*ad-k5hYKQnRQJF8tv8BIqg.png"/>
  <img src="https://miro.medium.com/max/1400/1*atEwskfs0gtIryRrgnAPkw.png"/>

  <p>rAF не регулируются автоматически, если их выполнение занимает слишком много времени.</p>
  <p>Допустим, в очереди 5 обратных вызовов, и каждый из них займет ~ 100 мс. Браузер не будет распределять их по множеству фреймов. Он попытается запустить их все в заданном кадре, даже если это займет 500 мс. Это означает довольно значительный рывок (притормаживание).</p>
  <p>Вы можете спросить: «Почему внутри одного кадра запрашивается ПЯТЬ обратных вызовов animationFrame?» Это может случайно произойти, если вы сделаете 2 очень разумные вещи. 1) Вы запрашиваете новый обратный вызов в конце rAF. 2) Вы запрашиваете обратные вызовы rAF от обработчиков ввода. В результате вы удваиваете/утроите свою работу в каждом кадре. </p>
  <p>Вы сами должны объединить RAF. Итак: если есть вероятность того, что в одном кадре сработает несколько «одних и тех же» обратных вызовов, вы должны управлять планированием/объединением.</p>
  <p>Тем не менее, Chrome (по крайней мере) попытается кому-то помочь. Если rAF перегружают основной поток, браузер начнет блокировать события ввода, так что, будем надеяться, конфликт будет устранен.</p>
</div>
</details>

<details>
<summary>15. Что такое requestIdleCallback?</summary>
<div>
<h3>requestIdleCallback</h3>
  <p>Метод requestIdleCallback позволяет выполнять низкоприоритетные операции в период простоя браузера (отсюда idle) внутри фрейма (обычно, это происходит после вычисления браузером макета и его перерисовки, когда осталось какое-то время перед синхронизацией) или во время бездействия пользователя.</p>
  <img src="https://w3c.github.io/requestidlecallback/images/image00.png"/>
  <p> Даже если с точки зрения пользователя страница "подвисает", могут быть периоды, когда браузер находится в режиме ожидания. Максимальная продолжительность времени, формально предоставляемая rIC для выполнения задачи, составляет 50 мс. Фактически же в нашем распоряжении имеется всего 0.5-10 мс. Поэтому, если внутри rIC вызывается функция для изменения DOM, ее следует вызывать с помощью rAF. Это объясняется тем, что модификация DOM — это потенциально продолжительная операция, на выполнение которой в rIC может не хватить времени.</p>

  <h3>Зачем использовать requestIdleCallback?</h3>
  <p>Браузер точно знает, сколько времени доступно в конце кадра и взаимодействует ли пользователь со  страницей, поэтому с помощью requestIdleCallback мы получаем API, который позволяет нам максимально использовать любое свободное время, максимально возможным эффективным способом.</p>

  <h3>Проверка для requestIdleCallback</h3>
  <p>Это первые дни для requestIdleCallback, поэтому перед его использованием вы должны убедиться, что он доступен для использования:</p>

    if ('requestIdleCallback' in window) {
        // Use requestIdleCallback to schedule work.
    } else {
        // Do what you’d do today.
    }


  <h3>Использование requestIdleCallback()</h3>
  <p>Вызов requestIdleCallback очень похож на requestAnimationFrame тем, что он принимает функцию обратного вызова в качестве первого параметра:</p>

    requestIdleCallback(myNonEssentialWork);

  <p>При вызове myNonEssentialWork ему будет предоставлен объект deadline, который содержит функцию, возвращающую число, указывающее, сколько времени осталось для вашей работы:</p>

    function myNonEssentialWork (deadline) {
      while (deadline.timeRemaining() > 0)
      doWorkIfNeeded();
    }

  <p>Функцию timeRemaining можно вызвать для получения последнего значения. Когда timeRemaining() возвращает ноль, вы можете запланировать еще один requestIdleCallback, если у вас еще есть работа:</p>


  <p>Вы можете вызвать requestIdleCallback() в функции обратного вызова бездействия, чтобы запланировать другой обратный вызов не раньше, чем следующий проход через event loop.</p>

    function myNonEssentialWork (deadline) {
      while (deadline.timeRemaining() > 0 && tasks.length > 0)
       doWorkIfNeeded();

      if (tasks.length > 0)
      requestIdleCallback(myNonEssentialWork);
    }

  <h3>Гарантированный запуск функции:</h3>
  <p>Что делать, если браузер все время заняты? Вы можете быть обеспокоены тем, что ваш обратный вызов никогда не будет вызван. Что ж, хотя requestIdleCallback похож на requestAnimationFrame, есть и отличия. Он принимает необязательный второй параметр: объект параметров со свойством тайм-аута. Этот тайм-аут, если он установлен, дает браузеру время в миллисекундах, в течение которого он должен выполнить обратный вызов:</p>

    // Подождите не более двух секунд перед обработкой событий.
    requestIdleCallback(processPendingAnalyticsEvents, { timeout: 2000 });

  <p>Если ваш обратный вызов выполняется из-за срабатывания тайм-аута, вы заметите две вещи:</p>
  <ul>
    <li>timeRemaining() вернет ноль.</li>
    <li>Свойство didTimeout объекта крайнего срока будет иметь значение true.</li>
  </ul>

  <p>Если вы видите, что didTimeout имеет значение true, вы, скорее всего, просто захотите запустить работу и покончить с ней:</p>
  
    function myNonEssentialWork (deadline) {
      // Use any remaining time, or, if timed out, just run through the tasks.
      while ((deadline.timeRemaining() > 0 || deadline.didTimeout) &&
              tasks.length > 0)
      doWorkIfNeeded();

      if (tasks.length > 0)
      requestIdleCallback(myNonEssentialWork);
    }

  <p>Из-за потенциального сбоя, который этот тайм-аут может вызвать у ваших пользователей (работа может привести к тому, что ваше приложение перестанет отвечать или зависать), будьте осторожны с настройкой этого параметра. Там, где вы можете, пусть браузер решает, когда вызывать обратный вызов.</p>

  <h3>use cases:</h3>
  <p>1. Можно использовать requestIdleCallback для отправки аналитических данных. В этом случае мы, вероятно, хотели бы отслеживать событие, например, касание меню навигации. Однако, поскольку они обычно анимируются на экране, нам следует избегать немедленной отправки этого события в Google Analytics. Мы создадим массив событий для отправки и запросим их отправку в какой-то момент в будущем.</p>


  <p>2. Использование requestIdleCallback для внесения изменений в DOM. Нужно внести несущественные изменения DOM, например добавить элементы в конец постоянно растущего списка с ленивой загрузкой. Давайте посмотрим, как requestIdleCallback на самом деле вписывается в типичный фрейм.</p>
  <img src="https://wd.imgix.net/image/T4FyVKpzu4WKF1kBNvXepbi08t52/i5IYAvSfMB8JIAelSAze.jpg?auto=format&w=1434"/>


  <a href="https://developer.chrome.com/blog/using-requestidlecallback">Using requestIdleCallback</a>
</div>
</details>

<details>
<summary>16. Что такое замыкание?</summary>
<div>
  <h2>Набор терминов для понимания замыканий:</h2>
  <h3>Scope(Область видимости):</h3>
  <p>Область видимости — это политика пространства, которая управляет доступностью переменных.
  Область видимости изолирует переменные. </p>
  <p>Области видимости могут быть вложенными, внешняя область доступна из внутренней.</p>

  <h3>Lexical scope(Лексическое окружение):</h3>
  <p>Лексическая область видимости состоит из внешних областей видимости, определенных статически.</p>

  <h3>Closure(Замыкание):</h3>
  <img src="https://dmitripavlutin.com/abb81d8f5ca936ad83074e72cabf1d19/javascript-closure-6.svg" />
  <p>Замыкание — это функция, которая обращается к своей лексической области видимости, даже если она выполняется вне ее лексической области видимости.</p>
  <p>Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания.</p> 
  <p>Простыми словами, замыкание запоминает переменные из того места где оно было обьявлено и не важно где оно было запущено.</p>
  
  <h3>useCases:</h3>
  <p>Event handlers - Когда кнопка нажата, handleClick() выполняется где-то внутри кода DOM. Исполнение происходит далеко от места определения. </p>

  <p>Functional programming - carrying.  Каррирование происходит, когда функция возвращает другую функцию до тех пор, пока аргументы не будут предоставлены полностью.</p>
    
      function multiply(a) {
        return function executeMultiply(b) {
          return a * b;
        }
      }
      const double = multiply(2);
      double(3); // => 6
      double(5); // => 10
      const triple = multiply(3);
      triple(4); // => 12
 
</div>
</details>

<details>
<summary>17. Что такое прототип объекта в JavaScript?</summary>
<div>
  <p>В JavaScript объект может наследовать свойства другого объекта. Объект, от которого наследуются свойства, называется прототипом.</p>

  <p>Прототип даёт нам немного «магии». Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. В программировании такой механизм называется «прототипным наследованием». Многие интересные возможности языка и техники программирования основываются на нём.</p>
  <p>JavaScript ищет унаследованные свойства в прототипе объекта, а также в прототипе прототипа и так далее в цепочке прототипов.</p>
  <p>Суть прототипного наследования в JavaScript: объекты могут наследовать свойства от других объектов - прототипов. Связующим звеном выступает специальное свойство __proto__</p>
  <p>Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__. Недостаток этого подхода – он не работает в IE10-.</p>
  <p>К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ. Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.</p>
  <p>Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.</p>
  <p>При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.</p>
  
    var animal = {
      eats: true
    };

    function Rabbit(name) {
      this.name = name;
    }

    Rabbit.prototype = animal;

    var rabbit = new Rabbit("Кроль"); //  rabbit.__proto__ == animal

    alert( rabbit.eats ); // true

  <p>Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее: "При создании объекта через new Rabbit запиши ему __proto__ = animal".</p>

  <p>Значением Person.prototype по умолчанию является объект с единственным свойством constructor, содержащим ссылку на Person.</p>
  <p>Null это самый верхний прототип, у нуля уже нет прототипов.</p>
  <p>Свойство __proto__ — исторически обусловленный геттер/сеттер для [[Prototype]]
  Обратите внимание, что __proto__ — не то же самое, что [[Prototype]]. Это геттер/сеттер для него.</p>
  <p>Есть только два ограничения прототипирования:</p>
  <ul>
    <li>Ссылки не могут идти по кругу. JavaScript выдаст ошибку, если мы попытаемся назначить __proto__ по кругу.</li>
    <li>Значение __proto__ может быть объектом или null. Другие типы игнорируются.</li>
  </ul>
  <p>прототипы никак не влияют на this.
  Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой. Это на самом деле очень важная деталь, потому что у нас может быть большой объект со множеством методов, от которого можно наследовать. Затем наследующие объекты могут вызывать его методы, но они будут изменять своё состояние, а не состояние объекта-родителя.</p>

  <p>Собственные и унаследованные свойства обьекта.</p>

    let animal = {
      eats: true
    };

    let rabbit = {
      jumps: true,
      __proto__: animal
    };

    // Object.keys возвращает только собственные ключи
    alert(Object.keys(rabbit)); // jumps

    // for..in проходит и по своим, и по унаследованным ключам
    for(let prop in rabbit) alert(prop); // jumps, затем eats

  <p>Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key. Но почему hasOwnProperty не появляется в цикле for..in в отличие от eats и jumps? Он ведь перечисляет все унаследованные свойства.

  Ответ простой: оно не перечислимо. То есть, у него внутренний флаг enumerable стоит false, как и у других свойств Object.prototype. Поэтому оно и не появляется в цикле.</p>
  
  <ul>
    <li>  В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.</li>
    <li> Мы можем использовать obj.__proto__ для доступа к нему (исторически обусловленный геттер/сеттер, есть другие способы, которые скоро будут рассмотрены).</li>
    <li>  Объект, на который ссылается [[Prototype]], называется «прототипом».</li>
    <li>  Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.</li>
    <li>Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).</li>
    <li>Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.</li>
    <li>Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.</li>
  </ul>
  <img src="https://learn.javascript.ru/article/native-prototypes/native-prototypes-classes.svg"/>

   <p>use cases:</p>
   <p>Одной из причин использования встроенного объекта-прототипа является многократное дублирование объекта, который будет иметь общую функциональность. Прикрепляя методы к прототипу, вы можете сэкономить на дублировании методов, создаваемых для каждого нового экземпляра. Но когда вы присоединяете метод к прототипу, все экземпляры будут иметь доступ к этим методам.</p>
</div>
</details>

<details>
<summary>18. Расскажите про классы в JavaScript?</summary>
  <h2>Класс и конструктор класса:</h2>
  <p>В JavaScript класс – это разновидность функции.</p>

    class User {
      constructor(name) { this.name = name; }
      sayHi() { alert(this.name); }
    }

    // доказательство: User - это функция
    alert(typeof User); // function
  
  <p>Вот что на самом деле делает конструкция class User {...}:</p>
  <ul>
    <li>Создаёт функцию с именем User, которая становится результатом объявления класса. Код функции берётся из метода constructor (она будет пустой, если такого метода нет).</li>
    <li>Сохраняет все методы, такие как sayHi, в User.prototype.
  При вызове метода объекта new User он будет взят из прототипа. Таким образом, объекты new User имеют доступ к методам класса.</li>
  </ul>

  <p>Можно проверить вышесказанное и при помощи кода:</p>

    class User {
      constructor(name) { this.name = name; }
      sayHi() { alert(this.name); }
    }

    // класс - это функция
    alert(typeof User); // function

    // ...или, если точнее, это метод constructor
    alert(User === User.prototype.constructor); // true

    // Методы находятся в User.prototype, например:
    alert(User.prototype.sayHi); // alert(this.name);

    // в прототипе ровно 2 метода
    alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi

  <p>Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме.</p>
  <h3>Поля класса:</h3>
  <p>Поля класса — это переменные, содержащие информацию. Поля могут быть прикреплены к 2 объектам:</p>

  <ul>
    <li>Поля экземпляра класса</li>
    <li>Поля в самом классе (static)</li>
  </ul>



  <p>Поля также имеют 2 уровня доступности:</p>

  <ul>
    <li>Public: поле доступно в любом месте</li>
    <li>Private: поле доступно только внутри тела класса</li>
  </ul>

  <h3>Private fields</h3>
  <p>Приватные поля доступны только внутри тела класса.</p>

    class User {
      #name;
      constructor(name) {
        this.#name = name;
      }
      getName() {
        return this.#name;
      }
    }
    const user = new User('Jon Snow');
    user.getName(); // => 'Jon Snow'
    user.#name;     // SyntaxError is thrown

  <h3>Public static</h3>
  <p>Вы также можете определить поля в самом классе: статические поля. Они полезны для определения констант класса или хранения информации, относящейся к классу.</p>

    class User {
      static TYPE_ADMIN = 'admin';
      static TYPE_REGULAR = 'regular';
      name;
      type;
      constructor(name, type) {
        this.name = name;
        this.type = type;
      }
    }
    const admin = new User('Site Admin', User.TYPE_ADMIN);
    admin.type === User.TYPE_ADMIN; // => true

  <h3>Private static</h3>
  <p>Чтобы сделать статическое поле приватным, поставьте перед именем поля специальный символ #: static #myPrivateStaticField.

  Допустим, вы хотите ограничить количество экземпляров класса User. Чтобы скрыть детали лимитов экземпляров, вы можете создать приватные статические поля pattern singleton:</p>

    class User {
      static #MAX_INSTANCES = 1;
      static #instances = 0;
      
      name;
      constructor(name) {
        User.#instances++;
        if (User.#instances > User.#MAX_INSTANCES) {
          throw new Error('Unable to create User instance');
        }
        this.name = name;
      }
    }
    new User('Jon Snow');
    new User('Sansa Stark'); // throws Error

  <p>Эти закрытые статические поля доступны только в классе User. Ничто из внешнего мира не может помешать механизму ограничений: в этом преимущество инкапсуляции.</p>

  <h3>Static methods</h3>
  <p>Статические методы — это функции, прикрепленные непосредственно к классу. Они содержат логику, связанную с классом, а не с экземпляром класса.

      static myStaticMethod() { ... }.

  При работе со статическими методами следует помнить 2 простых правила:</p>

  <ul>
    <li>Статический метод может обращаться к статическим полям</li>
    <li>Статический метод не может получить доступ к полям экземпляра.</li>
  </ul>

    class User {
      static #takenNames = [];
      static isNameTaken(name) {
        return User.#takenNames.includes(name);
      }
      name = 'Unknown';
      constructor(name) {
        this.name = name;
        User.#takenNames.push(name);
      }
    }
    const user = new User('Jon Snow');
    User.isNameTaken('Jon Snow');   // => true
    User.isNameTaken('Arya Stark'); // => false

  <p>isNameTaken() — это статический метод, который использует статическое приватное поле User.#takenNames для проверки занятых имен.

  Статические методы могут быть приватными: static #staticFunction() {...}. Опять же, они соблюдают правила приватности: вы можете вызывать приватный статический метод только внутри тела класса.</p>

  <h3>Inheritance: extends</h3>
  <p>Классы в JavaScript поддерживают одиночное наследование с использованием ключевого слова extends.

  В выражении class Child extends Parent { } класс Child наследует от Parent конструктор, поля и методы.</p>

    class User {
      name;
      constructor(name) {
        this.name = name;
      }
      getName() {
        return this.name;
      }
    }
    class ContentWriter extends User {
      posts = [];
    }
    const writer = new ContentWriter('John Smith');
    writer.name;      // => 'John Smith'
    writer.getName(); // => 'John Smith'
    writer.posts;     // => []

  <p>ContentWriter наследует от пользователя конструктор, метод getName() и имя поля. Кроме того, класс ContentWriter объявляет новое поле posts.

  Обратите внимание, что частные члены родительского класса не наследуются дочерним классом.</p>

  <h3>Parent constructor: super() in constructor()</h3>
  <p>Если вы хотите вызвать родительский конструктор в дочернем классе, вам нужно использовать специальную функцию super(), доступную в дочернем конструкторе.

  Например, сделаем так, чтобы конструктор ContentWriter вызывал родительский конструктор User, а также инициализировал поле posts:</p>

    class User {
      name;
      constructor(name) {
        this.name = name;
      }
      getName() {
        return this.name;
      }
    }
    class ContentWriter extends User {
      posts = [];
      constructor(name, posts) {
        super(name);
        this.posts = posts;
      }
    }
    const writer = new ContentWriter('John Smith', ['Why I like JS']);
    writer.name; // => 'John Smith'
    writer.posts // => ['Why I like JS']

  <p>super(name) inside the child class ContentWriter executes the constructor of the parent class User</p>

  <h3>Parent instance: super в методах</h3>
  <p>Если вы хотите получить доступ к родительскому методу внутри дочернего метода, вы можете использовать специальный ярлык super.</p>

    class User {
      name;
      constructor(name) {
        this.name = name;
      }
      getName() {
        return this.name;
      }
    }
    class ContentWriter extends User {
      posts = [];
      constructor(name, posts) {
        super(name);
        this.posts = posts;
      }
      getName() {
        const name = super.getName();
        if (name === '') {
          return 'Unknwon';
        }
        return name;
      }
    }
    const writer = new ContentWriter('', ['Why I like JS']);
    writer.getName(); // => 'Unknwon'

  <p>getName() дочернего класса ContentWriter обращается к методу super.getName() непосредственно из родительского класса User.

  Эта функция называется переопределением метода.

  Обратите внимание, что вы также можете использовать super со статическими методами, чтобы получить доступ к статическим методам родителя.</p>

  

  <p>Итого:</p>

    class MyClass {
      prop = value; // свойство
      constructor(...) { // конструктор
        // ...
      }
      method(...) {} // метод
      get something(...) {} // геттер
      set something(...) {} // сеттер
      [Symbol.iterator]() {} // метод с вычисляемым именем (здесь - символом)
      // ...
    }

  
  <p>MyClass технически является функцией (той, которую мы определяем как constructor), в то время как методы, геттеры и сеттеры записываются в MyClass.prototype.</p>

  <p>Давайте обобщим, какие методы для проверки типа мы знаем:</p>

  | работает | для | возвращает |
  | -------- | --- | ---------- | 
  | typeof   |	примитивов |	строка |
  | {}.toString |	примитивов, встроенных объектов, объектов с Symbol.toStringTag | строка |
  | instanceof	| объектов	| true/false |

  <p>Как мы можем видеть, технически {}.toString «более продвинут», чем typeof.

  А оператор instanceof – отличный выбор, когда мы работаем с иерархией классов и хотим делать проверки с учётом наследования. 
  instanceof является полиморфным: оператор определяет дочерний элемент как экземпляр родительского класса. </p>

  <p>Классы JavaScript инициализируют экземпляры с помощью конструкторов, определяют поля и методы. Вы можете присоединять поля и методы даже к самому классу, используя ключевое слово static.

  Наследование достигается с помощью ключевого слова extends: вы можете легко создать дочерний класс из родительского. ключевое слово super используется для доступа к родительскому классу из дочернего класса.

  Чтобы воспользоваться преимуществами инкапсуляции, сделайте поля и методы закрытыми, чтобы скрыть внутренние детали ваших классов. Имена приватных полей и методов должны начинаться с #.</p>
</details>



<details>
<summary>19. Как работают методы apply(), call() и bind()?</summary>
<div>
  <p>Функции в JavaScript никак не привязаны к своему контексту this, с одной стороны, здорово – это позволяет быть максимально гибкими, одалживать методы и так далее.</p>
  <p>Но с другой стороны – в некоторых случаях контекст может быть потерян. Способы явно указать this  - методы bind, call и apply.</p>
  <ul>
    <li>
      <p>Синтаксис метода call: func.call(context, arg1, arg2, ...)</p>
      <p>При этом вызывается функция func, первый аргумент call становится её this, а остальные передаются «как есть». Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context).</p>
    </li>
    <li>
      <p>Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply. Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.</p>
      <p>
        func.call(context, arg1, arg2) идентичен вызову func.apply(context, [arg1, arg2]);
      </p>
    </li>
    <li>
      <p>Синтаксис встроенного bind: var wrapper = func.bind(context[, arg1, arg2...])</p>
      <p>Методы bind и call/apply близки по синтаксису, но есть важнейшее отличие. Методы call/apply вызывают функцию с заданным контекстом и аргументами. А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.</p>
    </li>
  </ul>
  <p>
    <i>Источник:
      <br/>
      <a href ="https://learn.javascript.ru/call-apply#metod-apply">javascript.ru - call и apply</a>
      <br/>
      <a href ="https://learn.javascript.ru/bind#bind">javascript.ru - bind</a>
    </i>
  </p>
</div>
</details>

<details>
<summary>20. Что такое Promise (Промис)?</summary>
<div>
  <br/>
  <h1>Promise</h1>
  <p>Promise – это специальный объект, который содержит состояние выполнения асинхронной функции. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).</p>
  <p>Промисы, оборачивающие результат асинхронной операции, могут быть возвращены синхронно из функции, присвоены переменным или использованы в качестве аргументов. В этом и заключается идея промисов: инкапсулировать асинхронность и позволить функциям, обрабатывающим асинхронные операции, по-прежнему выглядеть синхронно.</p>
  <p>
    Синтаксис создания Promise:

    var promise = new Promise(function(resolve, reject) {
      // Эта функция будет вызвана автоматически

      // В ней можно делать любые асинхронные операции,
      // А когда они завершатся — нужно вызвать одно из:
      // resolve(результат) при успешном выполнении
      // reject(ошибка) при ошибке
       if (asyncOperationSuccess) {
        resolve(value); // async operation successful
      } else {
        reject(error);  // async operation error
      }
    })
  </p>
  <p>Большинство асинхронных функций популярных библиотек (например, axios) или веб-API (например, fetch()) возвращают уже созданные промисы.</p>
  <p>
    Универсальный метод для навешивания обработчиков:
    
    promise.then(onFulfilled, onRejected)
    
  <ul>
    <li>onFulfilled – функция, которая будет вызвана с результатом при resolve.</li>
    <li>onRejected – функция, которая будет вызвана с ошибкой при reject.</li>
  </ul>
    Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) – это то же самое.
  </p>
  <p>
    Возьмём setTimeout в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»:
  
    // Создаётся объект promise
    let promise = new Promise((resolve, reject) => {

      setTimeout(() => {
        // переведёт промис в состояние fulfilled с результатом "result"
        resolve("result");
      }, 1000);

    });

    // promise.then навешивает обработчики на успешный результат или ошибку
    promise
      .then(
        result => {
          // первая функция-обработчик - запустится при вызове resolve
          alert("Fulfilled: " + result); // result - аргумент resolve
        },
        error => {
          // вторая функция - запустится при вызове reject
          alert("Rejected: " + error); // error - аргумент reject
        }
      );
   В результате запуска кода выше – через 1 секунду выведется «Fulfilled: result».
  </p>
  <h1>Promise chain</h1>
  <p>Второе большое преимущество заключается в том, что промисы могут создавать цепочки для обработки нескольких зависимых асинхронных операций.

  Техническая сторона цепочки состоит в том, что методы promise.then(successCallback) и даже promise.catch(errorCallback) сами по себе возвращают промис, к которому можно присоединить методы .then() или .catch(), и т.д. на.</p>

  <h1>Методы Promise</h1>

  <p>
  <h3>Promise.all(iterable)</h3>
  Ожидает исполнения всех промисов или отклонения любого из них.
  Возвращает промис, который исполнится после исполнения всех промисов в iterable. В случае, если любой из промисов будет отклонён, Promise.all будет также отклонён.

  <br/>
  
  <h3>Promise.allSettled(iterable)</h3>
  Ожидает завершения всех полученных промисов (как исполнения так и отклонения).
  Возвращает промис, который исполняется когда все полученные промисы завершены (исполнены или отклонены), содержащий массив результатов исполнения полученных промисов.

      const statusesPromise = Promise.allSettled([
        resolveTimeout(['potatoes', 'tomatoes'], 1000),
        resolveTimeout(['oranges', 'apples'], 1000)
      ]);
      // wait...
      const statuses = await statusesPromise;
      // after 1 second
      console.log(statuses); 
      // [
      //   { status: 'fulfilled', value: ['potatoes', 'tomatoes'] },
      //   { status: 'fulfilled', value: ['oranges', 'apples'] }
      // ]

  <br/>
  
  <h3>Promise.race(iterable)</h3>
  Ожидает исполнения или отклонения любого из полученных промисов.
  Возвращает промис, который будет исполнен или отклонён с результатом исполнения первого исполненного или отклонённого промиса из .iterable.
  Promise.race устанавливается, как только выполняется любое из promise, которые вы ему передаете, независимо от того, выполнены они или отклонены.

  <h3>Promise.any(iterable)</h3>
  Promise.any(promises) — это вспомогательная функция, которая выполняет промисы параллельно и разрешает значение первого успешно разрешенного промиса из списка промисов.Полезно выполнять независимые асинхронные операции параллельно и в режиме гонки, чтобы получить значение любого первого выполненного обещания.
  Promise, возвращаемый Promise.any(), выполняется с любым первым выполненным promise. Даже если некоторые promise будут rejected, эти reject будут проигнорированы.

  <h3>Разница promse.race VS promise.any</h3>
  Promise.any решится, как только любое из переданных вами promise выполнено или все они отклонены, и в этом случае они отклоняются с AggregateError.

  <h3>Основные отличия:</h3>

  Promise.race реджектится, когда реджектиться первый promise, который вы ей даете; c any процесс происходит по другому, она обработает promise до первого успешного или пока все не отклонятся

  причиной отклонения promise.any может быть только AggregateError, но причиной отклонения promise.race может быть отклонение любого promise.

  Объект AggregateError представляет ошибку, когда несколько ошибок необходимо обернуть одной ошибкой. Он вызывается, когда операция должна сообщить о нескольких ошибках, например, Promise.any(), когда все промисы, переданные ему, отклоняются.
  <br/>

  <h3>Promise.reject(reason)</h3>
  Возвращает промис, отклонённый из-за reason.

  <br/>

  <h3>Promise.resolve(value)</h3>
  Возвращает промис, исполненный с результатом value.
  </p>

  <h1>async/await преимущества</h1>
  <p>Использование промисов по-прежнему требует обратных вызовов и относительно большого количества шаблонного кода, такого как .then(), .catch().</p>

  <p> Синхронно вернуть результат из Promise не получится, promise всегда возвращает promise.</p>

  К счастью, JavaScript сделал еще один шаг вперед в улучшении асинхронного кода, предоставив синтаксис async/await — действительно полезный синтаксический сахар поверх промисов.

  Когда это возможно, я настоятельно рекомендую работать с    синтаксисом async/await, а не с необработанными промисами.

  Применение синтаксиса async/await поверх промисов относительно просто:
  <ul>
    <li>Отметьте функции, использующие промисы, ключевым словом async.</li>
    <li>Внутри тела асинхронной функции всякий раз, когда вы хотите дождаться разрешения промиса, используйте синтаксис await promiseExpression</li>
    <li>Асинхронная функция всегда возвращает обещание, что позволяет вызывать асинхронные функции внутри асинхронных функций.</li>
  </ul>

      const address = fetch("https://jsonplaceholder.typicode.com/users/1")
        .then((response) => response.json())
        .then((user) => {
          return user.address;
        });

      const printAddress = async () => {
        const a = await address;
        console.log(a);
      };

      printAddress();
</div>
</details>

<details>
  <summary>21. Promise.all?</summary>
  <div>
  Допустим, нам нужно запустить множество промисов параллельно и дождаться, пока все они выполнятся.

  Например, параллельно загрузить несколько файлов и обработать результат, когда он готов.

  Для этого как раз и пригодится Promise.all.

  Синтаксис:

  let promise = Promise.all([...промисы...]);
  Метод Promise.all принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив) и возвращает новый промис.

  Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.
  Часто применяемый трюк – пропустить массив данных через map-функцию, которая для каждого элемента создаст задачу-промис, и затем обернёт получившийся массив в Promise.all.

  Например, если у нас есть массив ссылок, то мы можем загрузить их вот так:

   
    let urls = [
      'https://api.github.com/users/iliakan',
      'https://api.github.com/users/remy',
      'https://api.github.com/users/jeresig'
    ];

    // Преобразуем каждый URL в промис, возвращённый fetch
    let requests = urls.map(url => fetch(url));

    // Promise.all будет ожидать выполнения всех промисов
    Promise.all(requests)
      .then(responses => responses.forEach(
        response => alert(`${response.url}: ${response.status}`)
      
      ));

  В случае ошибки, остальные результаты игнорируются
  Если один промис завершается с ошибкой, то весь Promise.all завершается с ней, полностью забывая про остальные промисы в списке. Их результаты игнорируются.

  Например, если сделано несколько вызовов fetch, как в примере выше, и один не прошёл, то остальные будут всё ещё выполняться, но Promise.all за ними уже не смотрит. Скорее всего, они так или иначе завершатся, но их результаты будут проигнорированы.

  Promise.all ничего не делает для их отмены, так как в промисах вообще нет концепции «отмены». 
  </div>
</details>

<details>
  <summary>22. Async/await?</summary>
  <div>
  Функции, объявленные с использованием ключевого слова async (асинхронные функции), дают нам возможность писать аккуратный и не перегруженный служебными конструкциями код, позволяющий получить тот же результат, который мы получали с использованием промисов. Надо отметить, что ключевое слово async — это, в сущности, лишь «синтаксический сахар» для промисов.

  Внутри функции используется ключевое слово await, которое ставится перед вызовом функций, которые, в свою очередь, тоже возвращают промисы. Если результат этого вызова присваивается переменной или константе, то в них записывается результат вызова. Если присвоения нет, как в последнем вызове await, то происходит ожидание выполнения операции без использования её результата.

  Асинхронность в данном случае (как и в промисах) гарантирует нам, что программа не блокируется ожидая завершения вызовов, она может продолжать делать что-то еще (но не в этой функции). Но она не гарантирует параллельности. Более того, подряд идущие await в рамках одной функции всегда выполняются строго друг за другом.

  Асинхронные функции создают, пользуясь при объявлении функции ключевым словом async. Выглядит это так:

    const asyncFunction = async () => {
      // Код
    }

  Выполнение асинхронной функции можно приостановить с использованием ключевого слова await. Его можно использовать только в асинхронных функциях. Оно позволяет возвратить результат работы асинхронной функции, который будет доступен после того, как такая функция завершит выполнение некоей задачи.

  Сравним работу асинхронной функции и промиса, которые возвращают строку:

      // Асинхронная функция
      const asyncGreeting = async () => 'Greetings';
      // Промис
      const promiseGreeting = () => new Promise(((resolve) => {
        resolve('Greetings'); 
      }));
      asyncGreeting().then(result => console.log(result));
      promiseGreeting().then(result => console.log(result));

  Несложно заметить, что использование ключевого слова async позволяет писать асинхронный код, который выглядит как синхронный. С таким кодом гораздо легче работать.

  <h2>Итог: </h2>
  <p>async/await имеет 4 простых правила:</p>
  <ul>
    <li>Функция, обрабатывающая асинхронную задачу, должна быть помечена ключевым словом async.</li>
    <li>Оператор await promise приостанавливает выполнение функции до тех пор, пока обещание не будет успешно разрешено или отклонено.</li>
    <li>Если обещание разрешается успешно, оператор await возвращает разрешенное значение: const resolveValue = await обещание. В противном случае вы можете поймать отклоненное обещание внутри try/catch.</li>
    <li>Асинхронная функция всегда возвращает обещание, что дает возможность вкладывать асинхронные функции.</li>
  </ul>
  </div>
</details>


<details>
<summary>23. Что такое Set, Map, WeakSet и WeakMap?</summary>
<div>
  <br/>
  <p>В ES-2015 появились новые типы коллекций в JavaScript: Set, Map, WeakSet и WeakMap.</p>
  <p>Map – коллекция для хранения записей вида ключ:значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение.</p>
  <p>Использование объектов в качестве ключей – это одна из известных и часто применяемых возможностей объекта Map. При строковых ключах обычный объект Object может подойти, но для ключей-объектов – уже нет.</p>
  <p>
    
    Методы и свойства:

    new Map([iterable]) – создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар [ключ,значение] для инициализации.
    map.set(key, value) – записывает по ключу key значение value.
    map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
    map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
    map.delete(key) – удаляет элемент по ключу key.
    map.clear() – очищает коллекцию от всех элементов.
    map.size – возвращает текущее количество элементов.
    Отличия от обычного объекта Object:

    Что угодно может быть ключом, в том числе и объекты.
    Есть дополнительные методы, свойство size.
  </p>
  <p>
    Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. Set для этого отлично подходит:
  </p>
  <p>
    
    Методы и свойства:

    new Set([iterable]) – создаёт Set, можно указать перебираемый объект со значениями для инициализации.
    set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
    set.delete(value) – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false.
    set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
    set.clear() – удаляет все имеющиеся значения.
    set.size – возвращает количество элементов в множестве.
    Перебор Map и Set всегда осуществляется в порядке добавления элементов, так что нельзя сказать, что это – неупорядоченные коллекции, но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.
  </p>


  <p>WeakMap - принципиально другая структура в этом аспекте. Она не предотвращает удаление объектов сборщиком мусора, когда эти объекты выступают в качестве ключей.</p>
  <p>Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями. Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта WeakMap) автоматически.  Количество элементов в коллекции WeakMap неизвестно. Движок может произвести очистку сразу или потом, или сделать это частично. По этой причине методы для доступа ко всем сразу ключам/значениям недоступны.</p>

  <p>Примеры использования weakMap: 
    Другая частая сфера применения – это кеширование, когда результат вызова функции должен где-то запоминаться («кешироваться») для того, чтобы дальнейшие её вызовы на том же объекте могли просто брать уже готовый результат, повторно используя его. Многократные вызовы process(obj) с тем же самым объектом в качестве аргумента ведут к тому, что результат вычисляется только в первый раз, а затем последующие вызовы берут его из кеша. Недостатком является то, что необходимо вручную очищать cache от ставших ненужными объектов.

    Но если мы будем использовать WeakMap вместо Map, то эта проблема исчезнет: закешированные результаты будут автоматически удалены из памяти сборщиком мусора.
  </p>
    
    В WeakMap присутствуют только следующие методы:

    weakMap.get(key)
    weakMap.set(key, value)
    weakMap.delete(key)
    weakMap.has(key)

    // текущие активные пользователи
    let activeUsers = [
      {name: "Вася"},
      {name: "Петя"},
      {name: "Маша"}
    ];

    // вспомогательная информация о них,
    // которая напрямую не входит в объект юзера,
    // и потому хранится отдельно
    let weakMap = new WeakMap();

    weakMap.set(activeUsers[0], 1);
    weakMap.set(activeUsers[1], 2);
    weakMap.set(activeUsers[2], 3);
    weakMap.set('Katya', 4); //Будет ошибка TypeError: "Katya" is not a non-null object

    alert( weakMap.get(activeUsers[0]) ); // 1

    activeUsers.splice(0, 1); // Вася более не активный пользователь

    // weakMap теперь содержит только 2 элемента

    activeUsers.splice(0, 1); // Петя более не активный пользователь

    // weakMap теперь содержит только 1 элемент
  </p>
    <p>
    WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. 
    То же самое – WeakMap для Map.</p>

  <ul>
    <li>Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).</li>
    <li>Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.</li>
    <li>Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.</li>
  </ul>

  <p>Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа «да/нет». Присутствие во множестве WeakSet может что-то сказать нам об объекте.

  Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто посещал наш сайт</p>

  <p>Наиболее значительным ограничением WeakMap и WeakSet является то, что их нельзя перебрать или взять всё содержимое. Это может доставлять неудобства, но не мешает WeakMap/WeakSet выполнять их главную задачу – быть дополнительным хранилищем данных для объектов, управляемых из каких-то других мест в коде.</p>

  <h2>Итого:</h2>
  <p>WeakMaps позволяют расширять объекты извне, не мешая сборке мусора.</p>
</div>
</details>



<details>
<summary>24. Что делает строчка “use strict”;? Какие достоинства и недостатки от ее использования?</summary>
<div>
  <p>ECMAScript 5 (ES5) добавил новые возможности в язык и изменил некоторые из существующих. Чтобы устаревший код работал, как и раньше, по умолчанию подобные изменения не применяются. Поэтому нам нужно явно их активировать с помощью специальной директивы: "use strict".</p>

  <p>
  ‘use strict’ это директива, используемая для включения строгого режима во всем скрипте или отдельных функциях.</p>
  <h2>Преимущества:</h2>
  <p>Не позволяет случайно создавать глобальные переменные.</p>
  <p>Любое присваивание, которое в обычном режиме завершается неудачей, в строгом режиме выдаст исключение.</p>
  <p>При попытке удалить неудаляемые свойства, выдаст исключение (в то время как в нестрогом режиме никакого действия бы не произошло).</p>
  <p>Требует, чтобы имена параметров функции были уникальными.</p>
  <p>this в глобальной области видимости равно undefined.</p>
  <p>Перехватывает распространенные ошибки, выдавая исключения.</p>
  <h2>Недостатки:</h2>
  <p>Нельзя использовать некоторые особенности языка, к которым привыкли некоторые разработчики.</p>
  <p>Нет доступа к function.caller и function.arguments.</p>
  <p>Объединение скриптов, написанных в строгом режиме может вызвать проблемы.</p>
  <p>В целом, я думаю, что преимущества перевешивают недостатки, и мне никогда не приходилось полагаться на функции, которые заблокированы в строгом режиме. Я бы порекомендовал использовать строгий режим.</p>
</div>
</details>

<details>
<summary>25. Расскажите про методы массивов forEach, filter, map, reduce?</summary>
<div>
  <p>forEach ни чего не возвращает. Прервать итерирование по массиву не возможно.</p>

    items.forEach((elem, index, array) => {
      // console.log(elem, index , array)
    })

  <p>filer - возвращает ту часть массива которая прошла по какому то критерию</p>

    let check = array.filter( 
      function(elem, index, array) {
        return index > 1
      })

  <p> map - проходимся по всем элементам нашего массива и точно так же вызываем функцию callback, вернет массив, каждый элемент массива будет содержать новое значение которое вернула функция callback.</p>

    let result = array.map(function(elem){
      return elem*2
    })

  <p>reduce - выполняет функцию callback на каждом элементе массива передавая результат выполнения на следующую итерацию. Из массива в итоге получиться 1 значение. Внутри acc аккамулируется сумма которую мы считаем в примере.</p>

    let total = array.reduce(function(acc, elem) {
      return acc + elem
    }, initValue)

    const array2 = ['apple', 'banana', 'peach', 'orange']

    let fruits = array2.reduce((acc, elem) => {
      acc[elem] = 1
      return acc
    }, {})

</div>
</details>



<details>
<summary>26. Что такое "чистая функция"?</summary>
<div>
  <p>
   Чистые функции — строительные блоки в функциональном программировании. Их обожают за простоту и тестируемость.  Функция должна удовлетворять двум условиям, чтобы считаться «чистой»:

  — Каждый раз функция возвращает одинаковый результат, когда она вызывается с тем же набором аргументов

  — Нет побочных эффектов
   </p> 

   <p> 1. Нечистые функции = непостоянные результаты </p>
   <p> 2. Нет побочных эффектов </p>
   <p>Примеры побочных эффектов:

    Видоизменение входных параметров
    console.log
    HTTP вызовы (AJAX/fetch)
    Изменение в файловой системе
    Запросы DOM

    
  </p> 
  <p>По сути, любая работа, выполняемая функцией, не связана с вычислением конечного результата. </p>
</div>
</details>

<details>
<summary>27. Что такое лямбда- или стрелочные функции?</summary>
<div>

  Стрелочные функции — это сокращенный способ записи функциональных выражений. Они не имеют собственных this, arguments, super и new.target. Эти функции служат хорошей альтернативой функциям, не имеющим методов, но не могут использоваться как конструкторы.
</div>
</details>


<details>
<summary>28. Что такое запоминание или мемоизация?</summary>
<div>
  Мемоизация — это способ повышения производительности функции за счет сохранения в кэше ранее полученных результатов выполнения этой функции. При каждом вызове функции переданный ей аргумент становится индексом кэша. Если данные имеются в кэше, они возвращаются без повторного выполнения функции. В противном случае, функция выполняется, а результат записывается в кэш:

    const memoizAddition = () => {
        let cache = {}
        return value => {
            if (value in cache) {
                console.log('Получение данных из кэша')
                return cache[value] // в данном случае, cache.value не может быть использовано в качестве названия свойства, поскольку названия свойств в JS не могут начинаться с числа. Поэтому используется скобочная нотация
            } else {
                console.log('Результат вычисляется')
                let result = value + 20
                cache[value] = result
                return result
            }
        }
    }
    // возвращаем функцию из memoizAddition
    const addition = memoizAddition()
    console.log(addition(20)) // Результат вычисляется 40
    console.log(addition(20)) // Получения данных из кэша 40


    const multiplayer = (x, y, str) =>{
    
      console.log(x , y, str + ' args in fn')
      return x*y
    }

    const memoize = (fn) => {
      const cache = {}

      return (...args) =>  {
        
        if(cache[args]){
          console.log('result from cache')
          return cache[args]
        } else {
          const results = fn(...args)
          cache[args] = results
          console.log('memoized')
          return results
        }
        
      }
      
      
    }

    const memFn = memoize(multiplayer)
    console.log(memFn(3, 4, 'vlad'))
    console.log(memFn(3, 4, 'vlad'))
</div>
</details>


<details>
<summary>29. Расскажите про сборку мусора в JavaScript?</summary>
<div>
  <h2>Достижимость:</h2>
  Основной концепцией управления памятью в JavaScript является принцип достижимости.

  Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.

  Существует базовое множество достижимых значений, которые не могут быть удалены.

  <a>Например:</a>
  <ul>
    <li>Локальные переменные и параметры текущей функции.</li>
    <li>Переменные и параметры других функций в текущей цепочке вложенных вызовов.</li>
    <li>Глобальные переменные.</li>
  <ul>

  <b>Эти значения мы будем называть корнями.</b>

  Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.

  Например, если в локальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым. И те, на которые он ссылается, тоже достижимы. 

  В интерпретаторе JavaScript есть фоновый процесс, который называется сборщик мусора. Он следит за всеми объектами и удаляет те, которые стали недостижимы.

  <h2>Внутренние алгоритмы:</h2>
  Основной алгоритм сборки мусора – «алгоритм пометок» (англ. «mark-and-sweep»).

  <a>Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:</a>
  <ul>
    <li>Сборщик мусора «помечает» (запоминает) все корневые объекты.</li>
    <li>Затем он идёт по их ссылкам и помечает все найденные объекты.</li>
    <li>Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них. Все объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.</li>
   <li> …И так далее, пока не будут посещены все ссылки (достижимые от корней).
    Все непомеченные объекты удаляются.</li>
  </ul>

  <a>Вот некоторые из оптимизаций:</a>
  <ul>
    <li>Сборка по поколениям (Generational collection) – объекты делятся на «новые» и «старые». Многие объекты появляются, выполняют свою задачу и быстро умирают, их можно удалять более агрессивно. Те, которые живут достаточно долго, становятся «старыми» и проверяются реже.
    </li>
    <li>Инкрементальная сборка (Incremental collection) – если объектов много, то обход всех ссылок и пометка достижимых объектов может занять значительное время и привести к видимым задержкам выполнения скрипта. Поэтому интерпретатор пытается организовать сборку мусора поэтапно. Этапы выполняются по отдельности один за другим. Это требует дополнительного учёта для отслеживания изменений между этапами, но зато теперь у нас есть много крошечных задержек вместо одной большой.</li>
    <li>Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.</li>
  </ul>
  <a>Главное из того, что мы узнали:</a>
  <ul>
    <li>Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.</li>
    <li>Объекты сохраняются в памяти, пока они достижимы.</li>
    <li>Наличие ссылки не гарантирует, что объект достижим (от корня): несколько взаимосвязанных объектов могут стать недостижимыми как единое целое.</li>
  </ul>
</div>
</details>

<details>
<summary>30. Как сравнивать обьекты в JavaScript?</summary>
  <p>JavaScript предоставляет 3 способа сравнения значений:</p>
  <ul>
    <li>1. Оператор строго равенства ===</li>
    <li>2. Оператор свободного равенста ==</li>
    <li>3. Object.is() функция</li>
  </ul>

  <p>Когда вы сравниваете обьекты одним из превиденных выше способов, сравнение выдаст true только в том случае если сравниваемые значения ссылаются на один и тот же экземпляр обьекта. </p>

      const hero1 = {
        name: 'Batman'
      };
      const hero2 = {
        name: 'Batman'
      };
      hero1 === hero1; // => true
      hero1 === hero2; // => false
      hero1 == hero1; // => true
      hero1 == hero2; // => false
      Object.is(hero1, hero1); // => true
      Object.is(hero1, hero2); // => false

  <p>Еще раз. Сравниваются ссылки, а не сами обьекты</p>

  <h2>Manual сравнение:</h2>
  <p>Очевидный способ сравнить объекты по содержимому — прочитать свойства и сравнить их вручную.</p>

    function isHeroEqual(object1, object2) {
      return object1.name === object2.name;
    }
    const hero1 = {
      name: 'Batman'
    };
    const hero2 = {
      name: 'Batman'
    };
    const hero3 = {
      name: 'Joker'
    };
    isHeroEqual(hero1, hero2); // => true
    isHeroEqual(hero1, hero3); // => false

  <p>Ручное сравнение требует ручного извлечения свойств — для простых объектов это не проблема. Но для сравнения больших объектов (или объектов с неизвестной структурой) ручное сравнение неудобно, так как требует большого количества шаблонного кода.</p>


  <h2>Shallow сравнение:</h2>
  <p>Во время поверхностной проверки на равенство объектов вы получаете список свойств (используя Object.keys()) обоих объектов, затем проверяете значения свойств на равенство</p>

      function shallowEqual(object1, object2) {
        const keys1 = Object.keys(object1);
        const keys2 = Object.keys(object2);
        if (keys1.length !== keys2.length) {
          return false;
        }
        for (let key of keys1) {
          if (object1[key] !== object2[key]) {
            return false;
          }
        }
        return true;
      }

  <p>Но объекты в JavaScript могут быть вложенными. В таком случае, к сожалению, поверхностное равенство не работает.</p>    

  <h2>Deep сравнение:</h2>
  <p>Глубокое равенство похоже на поверхностное равенство, но с одним отличием. Во время неглубокой проверки, если сравниваемые свойства являются объектами, для этих вложенных объектов выполняется рекурсивная неглубокая проверка на равенство.</p>

      function deepEqual(object1, object2) {
        const keys1 = Object.keys(object1);
        const keys2 = Object.keys(object2);
        if (keys1.length !== keys2.length) {
          return false;
        }
        for (const key of keys1) {
          const val1 = object1[key];
          const val2 = object2[key];
          const areObjects = isObject(val1) && isObject(val2);
          if (
            areObjects && !deepEqual(val1, val2) ||
            !areObjects && val1 !== val2
          ) {
            return false;
          }
        }
        return true;
      }
      function isObject(object) {
        return object != null && typeof object === 'object';
      }

  <p>Выделенная строка areObjects && !deepEqual(val1, val2) указывает на то, что, как только сравниваемые свойства становятся объектами, начинается рекурсивный вызов для проверки равенства вложенных объектов.</p>

  <p>Для глубокого сравнения рекомендуется использовать:</p>

      isDeepStrictEqual(object1, object2) of Node built-in util module
      or _.isEqual(object1, object2) of lodash library.


  <h2>Сравнение с помощью JSON.stringify()</h2>
  <p>Простой путь: </p>

    function deep_clone(a){
      return JSON.parse(JSON.stringify(a));
    };
    function is_equal(a,b){
        return JSON.stringify(a) === JSON.stringify(b);
    };

  <p>JavaScript не гарантирует порядок ключей. 
    Если они вводятся в одном и том же порядке, этот подход будет работать в большинстве случаев, но он не будет надежным.
    Кроме того, он вернет false для объектов, которые глубоко равны, но чьи ключи вводятся в другом порядке:
  </p>

    JSON.stringify({ a: 1, b: 2}) === "{"a":1,"b":2}"

    JSON.stringify({ b: 2, a: 1}) === "{"b":2,"a":1}"


  <p>Обьект с сортировкой: </p>

    JSON.stringify(sortMyObj, Object.keys(sortMyObj).sort());

  <p>Однако этот метод удаляет любые вложенные объекты, на которые нет ссылок, и не применяется к объектам внутри массивов. Вы также захотите сделать flat для объекта сортировки.</p>



  <h2>Итог:</h2>
  <ul>
    <li>Ссылочное равенство (с использованием ===, == или Object.is()) определяет, являются ли операнды одним и тем же экземпляром объекта.</li>
    <li>Ручная проверка на равенство требует ручного сравнения значений свойств. Хотя эта проверка требует написания свойств для сравнения вручную, я нахожу этот подход удобным из-за его простоты.</li>
    <li>Когда сравниваемые объекты имеют много свойств или структура объектов определяется во время выполнения, лучшим подходом является использование поверхностной проверки.</li>
    <li>Наконец, если у сравниваемых объектов есть вложенные объекты, лучше всего использовать глубокую проверку на равенство.</li>
  </ul>
</details>

<details>
<summary>31. Модули в JS?</summary>
<div>
  <p>Модуль – это просто файл. Один скрипт – это один модуль.</p>

  <p>Так как модули поддерживают ряд специальных ключевых слов, и у них есть ряд особенностей, то необходимо явно сказать браузеру, что скрипт является модулем, при помощи атрибута .</p>

    <script type="module">
  <p>Браузер автоматически загрузит и запустит импортированный модуль (и те, которые он импортирует, если надо), а затем запустит скрипт.</p>

  <h2>Основные особенности модулей:</h2>
  <h3>Всегда use strict</h3>
  <p>В модулях всегда используется режим use strict. Например, присваивание к необъявленной переменной вызовет ошибку.</p>
  <p>В модуле на верхнем уровне this не определён (undefined).</p>

    <script type="module">
      a = 5; // ошибка
    </script>
  
  <h3>Своя область видимости переменных:</h3>
  <p>Каждый модуль имеет свою собственную область видимости. Другими словами, переменные и функции, объявленные в модуле, не видны в других скриптах.</p>
  <p>Модули должны экспортировать функциональность, предназначенную для использования извне. А другие модули могут её импортировать.</p>
  <p>В браузере также существует независимая область видимости для каждого скрипта </p>


  <h3>Код в модуле выполняется только один раз при импорте:</h3>

  <p>Если один и тот же модуль используется в нескольких местах, то его код выполнится только один раз, после чего экспортируемая функциональность передаётся всем импортёрам.</p>

  <p>На практике, задача кода модуля – это обычно инициализация, создание внутренних структур данных, а если мы хотим, чтобы что-то можно было использовать много раз, то экспортируем это.</p>

  <p>Такое поведение позволяет конфигурировать модули при первом импорте. Мы можем установить его свойства один раз, и в дальнейших импортах он будет уже настроенным.</p>

  <h3>Модули являются отложенными (deffered):</h3>
  <p>Модули всегда выполняются в отложенном (deferred) режиме, точно так же, как скрипты с атрибутом defer</p>

  <ul>
    <li>загрузка внешних модулей, таких как <'script type="module" src="...">, не блокирует обработку HTML.</li>
    <li>модули, даже если загрузились быстро, ожидают полной загрузки HTML документа, и только затем выполняются.</li>
    <li>сохраняется относительный порядок скриптов: скрипты, которые идут раньше в документе, выполняются раньше.</li>
  </ul>

  <p>Как побочный эффект, модули всегда видят полностью загруженную HTML-страницу, включая элементы под ними.</p>

  <h3>Атрибут async работает во встроенных скрпитах:</h3>
  <p>Для не-модульных скриптов атрибут async работает только на внешних скриптах. Скрипты с ним запускаются сразу по готовности, они не ждут другие скрипты или HTML-документ.</p>

  <p>Для модулей атрибут async работает на любых скриптах.</p>

  <p>Например, в скрипте ниже есть async, поэтому он выполнится сразу после загрузки, не ожидая других скриптов.</p>

  <p>Скрипт выполнит импорт (загрузит ./analytics.js) и сразу запустится, когда будет готов, даже если HTML документ ещё не будет загружен, или если другие скрипты ещё загружаются.</p>

  <p>Это очень полезно, когда модуль ни с чем не связан, например для счётчиков, рекламы, обработчиков событий.</p>

    <!-- загружаются зависимости (analytics.js) и скрипт запускается -->
    <!-- модуль не ожидает загрузки документа или других тэгов <script> -->
    <script async type="module">
      import {counter} from './analytics.js';

      counter.count();
    </script>

  <h3>Внешние скрипты:</h3>
  <p>Внешние скрипты с атрибутом type="module" имеют два отличия:</p>

  <p>1. Внешние скрипты с одинаковым атрибутом src запускаются только один раз:</p>

    <!-- скрипт my.js загрузится и будет выполнен только один раз -->
    <script type="module" src="my.js"></script>
    <script type="module" src="my.js"></script>

  <p>2. Внешний скрипт, который загружается с другого домена, требует указания заголовков CORS. Другими словами, если модульный скрипт загружается с другого домена, то удалённый сервер должен установить заголовок Access-Control-Allow-Origin означающий, что загрузка скрипта разрешена.</p>

    <!-- another-site.com должен указать заголовок Access-Control-Allow-Origin -->
    <!-- иначе, скрипт не выполнится -->
    <script type="module" src="http://another-site.com/their.js"></script>

  <p>Это обеспечивает лучшую безопасность по умолчанию.</p>

  <h2>Инструменты сборки:</h2>
  <p>В реальной жизни модули в браузерах редко используются в «сыром» виде. Обычно, мы объединяем модули вместе, используя специальный инструмент, например Webpack и после выкладываем код на рабочий сервер.</p>

  <p>Одно из преимуществ использования сборщика – он предоставляет больший контроль над тем, как модули ищутся, позволяет использовать «голые» модули и многое другое «своё», например CSS/HTML-модули.</p>

  <p>Сборщик делает следующее:</p>
  <ul>
    <li>1. Берёт «основной» модуль, который мы собираемся поместить в <'script type="module"> в HTML.</li>
    <li>2. Анализирует зависимости (импорты, импорты импортов и так далее)</li>
    <li>3. Собирает один файл со всеми модулями (или несколько файлов, это можно настроить), перезаписывает встроенный import функцией импорта от сборщика, чтобы всё работало. «Специальные» типы модулей, такие как HTML/CSS тоже поддерживаются.</li>
    <li>В процессе могут происходить и другие трансформации и оптимизации кода:</li>
    <ul>
      <li>Недостижимый код удаляется.</li>
      <li>Неиспользуемые экспорты удаляются («tree-shaking»)</li>
      <li>Специфические операторы для разработки, такие как console и debugger, удаляются.</li>
      <li>Современный синтаксис JavaScript также может быть трансформирован в предыдущий стандарт, с похожей функциональностью, например, с помощью Babel.</li>
      <li>Полученный файл можно минимизировать (удалить пробелы, заменить названия переменных на более короткие и т.д.).</li>
    </ul>
  </ul>

  <p>Если мы используем инструменты сборки, то они объединяют модули вместе в один или несколько файлов, и заменяют import/export на свои вызовы. Поэтому итоговую сборку можно подключать и без атрибута type="module", как обычный скрипт:</p>

    <!-- Предположим, что мы собрали bundle.js, используя например утилиту Webpack -->
    <script src="bundle.js"></script>

  <p>Хотя и «как есть» модули тоже можно использовать, а сборщик настроить позже при необходимости.</p>

  <h2>Async/defer</h2>
  <h3>defer</h3>
  <p>Атрибут defer сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда DOM дерево будет полностью построено.</p>
  <ul>
    <li>Скрипты с defer никогда не блокируют страницу.</li>
    <li>Скрипты с defer всегда выполняются, когда дерево DOM готово, но до события DOMContentLoaded.</li>
  </ul>

  <h3>async</h3>
  <p>Атрибут async означает, что скрипт абсолютно независим:
    <ul>
      <li>Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.</li>
      <li>Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга:</li>
        <ul>
          <li>DOMContentLoaded может произойти как до асинхронного скрипта (если асинхронный скрипт завершит загрузку после того, как страница будет готова)</li>
          <li>…так и после асинхронного скрипта (если он короткий или уже содержится в HTTP-кеше)</li>
        </ul>
      <li>Остальные скрипты не ждут async, и скрипты casync не ждут другие скрипты.</li>
      <li>Так что если у нас есть несколько скриптов с async, они могут выполняться в любом порядке. То, что первое загрузится – запустится в первую очередь</li>
    </ul>
  </p>


  <p>У async и defer есть кое-что общее: они не блокируют отрисовку страницы. Так что пользователь может просмотреть содержимое страницы и ознакомиться с ней сразу же.

  Но есть и значимые различия:</p>
  | Тип   | Порядрк    | DOMContentLoaded |
  |-------|------------|-----------------------------------------------------------------------------------|
  | async | Порядок загрузки (кто загрузится первым, тот и сработает).	| Не имеет значения. Может загрузиться и выполниться до того, как страница полностью загрузится. Такое случается, если скрипты маленькие или хранятся в кеше, а документ достаточно большой. |
  | defer | Порядок документа (как расположены в документе). | Выполняется после того, как документ загружен и обработан (ждёт), непосредственно перед DOMContentLoaded. |
  <h2>Итого:</h2>
  <p></p>
  <img src="https://i.stack.imgur.com/uWj3S.png"/>
  <img src="https://www.drupal.org/files/project-images/Libraries%20delay%20load.png"/>
  <img src="https://res.cloudinary.com/practicaldev/image/fetch/s--5qrUxpJD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://www.jstar.mx/images/blog/how-a-browser-renders-a-web-page/step-2-1000.png"/>
  <ul>
    <li>1. Модуль – это файл. Чтобы работал import/export, нужно для браузеров указывать атрибут <'script type="module">. У модулей есть ряд особенностей:</li>
    <ul>
      <li>Отложенное (deferred) выполнение по умолчанию.</li>
      <li>Атрибут async работает во встроенных скриптах.</li>
      <li>Для загрузки внешних модулей с другого источника, он должен ставить заголовки CORS.</li>
      <li>Дублирующиеся внешние скрипты игнорируются.</li>
    </ul>
    <li>2. У модулей есть своя область видимости, обмениваться функциональностью можно через import/export.</li>
    <li>3. В модулях всегда включена директива use strict.</li>
    <li>4. Код в модулях выполняется только один раз. Экспортируемая функциональность создаётся один раз и передаётся всем импортёрам.</li>
  </ul>
  <p>Когда мы используем модули, каждый модуль реализует свою функциональность и экспортирует её. Затем мы используем import, чтобы напрямую импортировать её туда, куда необходимо. Браузер загружает и анализирует скрипты автоматически.</p>

  <p>В реальной жизни часто используется сборщик Webpack, чтобы объединить модули: для производительности и других «плюшек»</p>
  <a href="https://learn.javascript.ru/onload-ondomcontentloaded">DOM content loaded</a>
</div>
</details>




<details>
  <summary>32. OOP в JavaScript?</summary>
  <div>
  <h2>Инкапсуляция:</h2>
  <p>Инкапсуляция включает в себя идею о том, что данные объекта не должны быть напрямую доступны. Нужно вызывать методы вместо прямого доступа к данным. Инкапсуляция позволяет нам скрывать/показывать свойства функций.</p>
  <p>Инкапсуляция с использованием замыкания</p>

    const createCounter = () => {
      // Переменная, определенная в области действия фабрики или конструктора
      // является приватной для этой функции.
      let count = 0;

      return ({
        // Любые другие функции, определенные в той же области, являются привилегированными:
        // Они имеют доступ к закрытой переменной `count`
        // определенной в любом месте их цепочки областей видимости (содержащей области действия функции).
        click: () => count += 1,
        getCount: () => count.toLocaleString()
      });
    };

    const counter = createCounter();

    counter.click();  

  <h2>Абстракция: </h2>
  <p>Абстракция - это способ создания простой модели, которая содержит только важные свойства с точки зрения контекста приложения, из более сложной модели. Иными словами - это способ скрыть детали реализации и показать пользователям только функциональность. Абстракция игнорирует нерелевантные детали и показывает только необходимые. Важно помнить, что мы не можем создать экземпляр абстрактного класса.

  Всё программное обеспечение - это абстракция, скрывающая всю тяжелую работу и бездумные детали.
  
  Процесс декомпозиции - это процесс абстракции. Успешная абстракция подразумевает, что результатом является набор независимо полезных и перекомпонованных компонентов.
  </p>

  <h2>Полиморфизм:</h2>
  <p>Само слово означает много форм. Существует много толкований того, что именно оно означает, но идея заключается в способности вызывать один и тот же метод для разных объектов, и при этом каждый объект реагирует по-своему.

  Чтобы это произошло полиморфизм использует наследование</p>
  <p>Способность объекта принимать различные формы. Например, функция может быть перегружена с тем же именем, но разными параметрами. </p>

  <h2>Наследование: </h2>
  <p>Наследование - это механизм базирования объекта или class на другом объекте (наследование на основе прототипа) или class (наследование на основе класса). Мы избегаем необходимости переписывать один и тот же код, а также экономим пространство памяти, используя общие методы.</p>

  

  </div>

</details>




<details>
<summary>33. Разница между Prototypal Inheritance vs Classical Inheritance?</summary>
<div>
  <p>Экземпляры обычно создаются с помощью функций-конструкторов с ключевым словом `new`. Наследование классов может использовать или не использовать ключевое слово class из ES6. Классы, какими вы их знаете из таких языков, как Java, технически не существуют в JavaScript. Вместо этого используются функции конструктора. Ключевое слово `class` ES6 преобразует сахар в функцию-конструктор:</p>

    class Foo {}
    typeof Foo // 'function'



  <p>При наследовании классов экземпляры наследуются от схемы (класса) и создают отношения подклассов. Другими словами, вы не можете использовать класс так же, как экземпляр. Вы не можете вызывать методы экземпляра для самого определения класса. Вы должны сначала создать экземпляр, а затем вызывать методы для этого экземпляра.</p>

  <p>При прототипном наследовании экземпляры наследуются от других экземпляров. Использование prototype delegate (установка прототипа одного экземпляра для ссылки на другой объект) буквально означает «связывание объектов с другими объектами», или OLOO, как это называет Кайл Симпсон. Используя <b>concatenative inheritance</b>, вы просто копируете свойства объекта-экземпляра в новый экземпляр.</p>

  <p>Очень важно, чтобы вы понимали эти различия. Наследование классов благодаря своим механизмам создает иерархию классов как побочный эффект создания подклассов. Эти иерархии приводят к артритическому коду (трудно изменить) и хрупкости (легко сломать из-за побочных эффектов при изменении базовых классов).</p>

  <ul>
    <li>Класс — это "план" обьекта.</li>
    <li>Прототип — это экземпляр объекта.</li>
  </ul>


  <p>В JavaScript наследование классов реализовано поверх прототипного наследования, но это не значит, что оно делает то же самое:</p>


  <h3>Prototypal Inheritance</h3>
  <p>Программирование на основе прототипов - это стиль объектно-ориентированного программирования, в котором повторное использование поведения (известное как наследование) выполняется через процесс повторного использования существующих объектов посредством делегирования, которые служат как prototypes. Сторонники программирования на основе прототипов утверждают, что данный стиль поощряет программиста сосредоточиться на поведении некоторого набора примеров и лишь позднее, беспокоиться о классификации этих объектов в архетипические объекты, которые впоследствии используются аналогично классам.</p>
  <p>Экземпляры могут состоять из множества различных исходных объектов, что обеспечивает простое выборочное наследование и плоскую иерархию делегирования [[Prototype]].</p>


  <h3>Classical Inheritance</h3>
  <p>Наследование классов: класс подобен чертежу — описанию создаваемого объекта. Классы наследуются от классов и создают отношения подклассов</p>
  <p>Программирование на основе классов, или же, ориентация на классы, - это стиль объектно-ориентированного программирования (ООП), в котором наследование происходит через определение классов объектов, вместо наследования, которое происходит только через объекты.

  Tight Coupling (сильная связанность) относится к волновым эффектам, которые могут произойти с подклассами (дочерние классы), когда вносится изменение в суперкласс (родительский класс).</p>

  <p>Наследование классов JavaScript использует цепочку прототипов, чтобы связать дочерний `Constructor.prototype` с родительским `Constructor.prototype` для делегирования. Обычно также вызывается конструктор `super()`. Эти шаги формируют иерархию родитель/потомок с одним предком и создают самую тесную связь, доступную в объектно-ориентированном дизайне.</p>


  
      Object instanceOf function
      // class = function
      // class это function потому что обращаясь к классу мы обращаемся к конструктору

  <h3>Почему важно разлечать разные типы наследования?</h3>
  <p>Наследование — это, по сути, механизм повторного использования кода: способ для разных типов объектов совместно использовать код. То, как вы делитесь кодом, имеет значение, потому что если вы ошибетесь, это может создать много проблем, в частности:</p>

  <b>Наследование классов создает таксономии родительских/дочерних объектов в качестве побочного эффекта.</b>

  <p>Эти таксономии практически невозможно правильно подобрать для всех новых вариантов использования, а широкое использование базового класса приводит к проблеме хрупкого базового класса, из-за которой их трудно исправить, если вы ошибаетесь. На самом деле наследование классов вызывает много хорошо известных проблем в объектно-ориентированном проектировании:</p>


  <ul>
    <li>Проблема хрупкого базового класса. В двух словах, базовый класс — это класс, от которого вы наследуете, и его часто называют хрупким, потому что изменения в этом классе могут привести к неожиданным результатам в классах, которые от него наследуются.</li>
    <li>Проблема негибкой иерархии (в конце концов, все развивающиеся иерархии не годятся для новых целей)</li>
    <li>Проблема дублирования по необходимости (из-за негибкой иерархии новые варианты использования часто внедряются путем дублирования, а не адаптации существующего кода)</li>
    <li>Проблема гориллы с бананом. Суть в том что класс зависит от задач класса. Вы хотите использовать «Banana», но в конечном итоге импортируете Gorilla, а затем все вещи, от которых зависит Gorilla, такие как другие состояния объектов и окружающая среда, то есть джунгли.</li>
    <li>Классическое наследование требует превосходного предвидения, чтобы избежать проблем неправильного наследования.</li>
  </ul>
  <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9">Master the JavaScript Interview: What’s the Difference Between Class & Prototypal Inheritance?</a>
</div>
</details>

<details>
<summary>34. Проблемы наследования?</summary>
<div>
…проблема с объектно-ориентированными языками заключается в том, что у них есть вся эта неявная среда, которую они носят с собой. Вы хотели банан, но получили гориллу, держащую банан и все джунгли».


Проблема заключается в том, что при использовании наследования классов вы покупаете всю существующую таксономию классов.


Если вы хотите немного адаптироваться к новому варианту использования, вы либо дублируете части существующей таксономии (проблема дублирования по необходимости), либо реорганизуете все, что зависит от существующей таксономии, чтобы адаптировать таксономию к новому использованию. Это является случаем проблемы хрупкого базового класса.


Композиция невосприимчива к обоим.
<h2>Prototypes vs Class</h2>
<p>Наиболее важное различие между наследованием на основе классов и прототипов заключается в том, что класс определяет тип, экземпляр которого может быть создан во время выполнения, тогда как прототип сам по себе является экземпляром объекта.</p>
<p>Дочерний класс ES6 — это еще одно определение типа, которое расширяет родителя новыми свойствами и методами, которые, в свою очередь, могут быть созданы во время выполнения. Дочерний элемент прототипа — это другой экземпляр объекта, который делегирует родительскому элементу любые свойства, не реализованные в дочернем элементе.</p>
<p>Конструктор класса создает экземпляр класса. Конструктор в JavaScript — это обычная старая функция, которая возвращает объект. Единственная особенность конструктора JavaScript заключается в том, что при вызове с ключевым словом new он назначает свой прототип в качестве прототипа возвращаемого объекта. Если это звучит для вас немного запутанно, вы не одиноки — это так, и это большая часть того, почему прототипы плохо изучены.</p>
<p>Чтобы подчеркнуть это, дочерний элемент прототипа не является копией своего прототипа и не является объектом той же формы, что и его прототип. У дочернего элемента есть живая ссылка на прототип, и любое свойство прототипа, не существующее в дочернем элементе, является односторонней ссылкой на свойство прототипа с тем же именем.</p>

    let parent = { foo: 'foo' }
    let child = { }
    Object.setPrototypeOf(child, parent)

    console.log(child.foo) // 'foo'

    child.foo = 'bar'

    console.log(child.foo) // 'bar'

    console.log(parent.foo) // 'foo'

    delete child.foo

    console.log(child.foo) // 'foo'

    parent.foo = 'baz'

    console.log(child.foo) // 'baz'

<p>В предыдущем примере, хотя child.foo не был определен, он ссылался на parent.foo. Как только мы определили foo для дочернего элемента, child.foo имел значение 'bar', но parent.foo сохранил свое исходное значение. Как только мы удаляем child.foo, он снова ссылается на parent.foo, что означает, что когда мы меняем значение родителя, child.foo ссылается на новое значение.</p>

<img src="https://uploads.toptal.io/blog/image/127573/toptal-blog-image-1542708811909-a533d5549d057d9b766593a7f018a22a.png" />

<p>Ключевым выводом является то, что прототипы не определяют тип; они сами являются экземплярами и могут изменяться во время выполнения со всеми вытекающими последствиями.</p>

    // Пример функции конструктора с замыканием
    function SecretiveProto() {
      const secret = "The Class is a lie!"
      this.spillTheBeans = function() {
        console.log(secret)
      }
    }

    const blabbermouth = new SecretiveProto()
    try {
      console.log(blabbermouth.secret)
    }
    catch(e) {
      // TypeError: SecretiveClass.secret is not defined
    }

    blabbermouth.spillTheBeans() // "The Class is a lie!"

<p>Для сравнения то как это бы проблемно выглядело в классах:</p>

    class SecretiveClass {
      constructor() {
        const secret = "I am a lie!"
        this.spillTheBeans = function() {
          console.log(secret)
        }
      }

      looseLips() {
        console.log(secret)
      }
    }

    const liar = new SecretiveClass()
    try {
      console.log(liar.secret)
    }
    catch(e) {
      console.log(e) // TypeError: SecretiveClass.secret is not defined
    }
    liar.spillTheBeans() // "I am a lie!"

  <p>И еще одна проблема...</p>

      try {
        liar.looseLips()
      }
      catch(e) {
        // ReferenceError: secret is not defined
      }

  <h3>Что предпочитают опытные разработчики JavaScript — прототипы или классы?</h3>
  <p>Как вы уже догадались, это еще один вопрос с подвохом — опытные разработчики JavaScript стараются избегать и того, и другого, когда могут. Вот хороший способ сделать это с помощью идиоматического JavaScript:</p>

      function secretFactory() {
        const secret = "Favor composition over inheritance, `new` is considered harmful, and the end is near!"
        const spillTheBeans = () => console.log(secret)

        return {
          spillTheBeans
        }
      }

      const leaker = secretFactory()
      leaker.spillTheBeans()

  <p>Речь идет не только о том, чтобы избежать уродства, присущего наследованию, или о принудительной инкапсуляции. Подумайте, что еще вы могли бы сделать с помощью secretFactory и лейкера, чего не могли бы легко сделать с помощью прототипа или класса.</p>

  <p>Во-первых, вы можете деструктурировать его, потому что вам не нужно беспокоиться о контексте этого:</p>

      const { spillTheBeans } = secretFactory()

      spillTheBeans() // Favor composition over inheritance, (...)

  <p>Обьектно ориентированный ли язык Javascript?</p>

  <p>JavaScript имеет мощную поддержку объектно-ориентированного программирования, но использует другую модель наследования (прототипную) по сравнению с большинством популярных объектно-ориентированных языков (использующих классическое наследование). Он также поддерживает процедурный и функциональный стили программирования.</p>
</div>
</details>


<details>
<summary>35. Виды наследования в JavaScript? (L)</summary>
<div>
  <p>JavaScript — один из самых выразительных языков программирования, когда-либо созданных. Одной из его лучших особенностей является возможность создавать объекты и наследовать от них без классов и наследования классов.</p>

  <h2>Delegation / Differential Inheritance:</h2>
  <p>Delegate prototype — это объект, который служит базой для другого объекта. Когда вы наследуете от delegate prototype, новый объект получает ссылку на прототип.</p>

  <p>Когда вы пытаетесь получить доступ к свойству нового объекта, он сначала проверяет собственные свойства объекта. Если он не находит его там, он проверяет `[[Prototype]]` и так далее по цепочке прототипов, пока не вернется к `Object.prototype`, который является корневым delegate для большинства объектов.</p>

  <p>Делегирование методов может сохранить ресурсы памяти, потому что вам нужна только одна копия каждого метода, которая будет использоваться всеми экземплярами. </p>

      class Greeter {
        constructor (name) {
          this.name = name || 'John Doe';
        }
        hello () {
          return `Hello, my name is ${ this.name }`;
        }
      }

      const george = new Greeter('George');

      const msg = george.hello();

      console.log(msg); // Hello, my name is George

  <p>Одним из основных недостатков делегирования является то, что оно не очень хорошо подходит для хранения состояния. Если вы попытаетесь сохранить состояние в виде объектов или массивов, изменение любого члена объекта или массива приведет к изменению члена для каждого экземпляра, который разделяет прототип. Чтобы сохранить безопасность экземпляра, вам нужно сделать копию состояния для каждого объекта.</p>

      const proto = {
        hello () {
          return `Hello, my name is ${ this.name }`;
        }
      };

      const greeter = (name) => Object.assign(Object.create(proto), {
        name
      });

      const george = greeter('george');

      const msg = george.hello();

      console.log(msg);

  <img src="https://miro.medium.com/max/1400/1*wgVmoipm1IhKMDluvwuW4Q.png" />

  <h2>Concatenative Inheritance / Cloning / Mixins</h2>
  <p>Конкатенативное наследование — это процесс копирования свойств одного объекта в другой без сохранения ссылки между двумя объектами. Он основан на динамическом расширении объекта JavaScript.</p>

  <p>Клонирование — отличный способ сохранить состояние объектов по умолчанию: этот процесс обычно достигается с помощью `Object.assign()`.</p>

    const proto = {
      hello: function hello() {
        return `Hello, my name is ${ this.name }`;
      }
    };

    const george = Object.assign({}, proto, {name: 'George'});

    const msg = george.hello();

    console.log(msg); // Hello, my name is George

  <p>Обычно этот стиль используется для миксинов. Например, вы можете превратить любой объект в генератор событий, смешав прототип `EventEmitter3`:</p>

    import Events from 'eventemitter3';

    const object = {};

    Object.assign(object, Events.prototype);

    object.on('event', payload => console.log(payload));

    object.emit('event', 'some data'); // 'some data'

  <p>Concatenative Inheritance очень мощное, но оно становится еще лучше, когда вы комбинируете его с замыканиями.</p>


  <h2>Functional Inheritance</h2>
  <p>Функциональное наследование использует фабричную функцию, а затем добавляет новые свойства с помощью конкатенации.</p>

  <p>Функции, созданные с целью расширения существующих объектов, обычно называют функциональными mixins. Основное преимущество использования функций для расширения заключается в том, что оно позволяет использовать замыкание функции для инкапсуляции частных данных. Другими словами, вы можете применять частное состояние.</p>

  <p>Немного неудобно навешивать атрибуты на общедоступное свойство, где пользователь может установить или получить их без вызова соответствующих методов. Что мы действительно хотим сделать, так это скрыть атрибуты в приватном режиме.</p>


      import Events from 'eventemitter3';

      const rawMixin = function () {
        const attrs = {};

        return Object.assign(this, {
          set (name, value) {
            attrs[name] = value;

            this.emit('change', {
              prop: name,
              value: value
            });
          },

          get (name) {
            return attrs[name];
          }
        }, Events.prototype);
      };

      const mixinModel = (target) => rawMixin.call(target);

      const george = { name: 'george' };
      const model = mixinModel(george);

      model.on('change', data => console.log(data));

      model.set('name', 'Sam');
      /*
      {
        prop: 'name',
        value: 'Sam'
      }
      */

  <p>Перемещая attrs из общедоступного свойства в частный идентификатор, мы удаляем все его следы из общедоступного API. Единственный способ использовать его сейчас — через привилегированные методы (getters and setter). Привилегированные методы — это любые методы, определенные в области действия замыкания, что дает им доступ к закрытым данным.</p>

  <p>Обратите внимание, что в приведенном выше примере у нас есть оболочка `mixinModel()` вокруг фактического функционального миксина, `rawMixin()`. Причина, по которой нам это нужно, заключается в том, что нам нужно установить значение `this` внутри функции, что мы и делаем с помощью `Function.prototype.call()`. Мы могли бы пропустить оболочку и позволить вызывающей стороне сделать это, но это было бы неудобно.</p>

  <h2>Composition Over Class Inheritance</h2>

  <b>“Favor object composition over class inheritance.” ~ The Gang of Four, “Design Patterns: Elements of Reusable Object Oriented Software”</b>

  <p>Наследование классов создает отношения is-a с ограничительными таксономиями, которые в конечном итоге не подходят для новых вариантов использования. Но оказывается, мы обычно используем наследование для отношений «имеет», «использует» или «может сделать».</p>

  <p>Композиция больше похожа на педаль эффектов гитары. Хотите что-то, что может делать задержку, тонкое искажение и голос робота? Без проблем! Просто подключите их все:</p>

    const effect = compose(delay, distortion, robovoice); 

  
  <p>Как вы, вероятно, начинаете понимать, конкатенативное наследование — это секретный соус, который делает возможной композицию объектов в JavaScript, что делает как делегирование прототипов, так и функциональное наследование намного более интересными.
  Когда большинство людей думают о прототипном ОО в JavaScript, они думают о делегировании прототипа. К настоящему времени вы должны увидеть, что они многое упускают. Delegate prototype — не лучшая альтернатива наследованию классов, лучшаяя это композиция объектов.</p>

</div>
</details>


<details>
<summary>36. Способы создания обьектов JavaScript? (L)</summary>
<div>
  <h2>Object literal:</h2>

      // ES6 / ES2015, because 2015.

      let mouse = {
        furColor: 'brown',
        legs: 4,
        tail: 'long, skinny',
        describe () {
          return `A mouse with ${this.furColor} fur,
            ${this.legs} legs, and a ${this.tail} tail.`;
        }
      };

  <h2>Object.create():</h2>
  <p>Метод Object.create() используется для создания нового объекта с указанным объектом-прототипом и свойствами. Метод Object.create() возвращает новый объект с указанным объектом-прототипом и свойствами.</p>

    Object.create(prototype[, propertiesObject])

    Используемые параметры:

    1. Прототип: это объект-прототип, из которого должен быть создан новый объект.
     
    2. propertiesObject : это необязательный параметр. Он указывает перечисляемые свойства, которые будут добавлены к вновь созданному объекту.

  <p>Давайте немного разберем пример. "animal" — это prototype delegate. `mouse` является экземпляром. Когда вы пытаетесь получить доступ к свойству mouse, которого там нет, среда выполнения JavaScript будет искать свойство «animal» (делегат).</p>

      let animal = {
        animalType: 'animal',
        
        describe () {
          return `An ${this.animalType}, with ${this.furColor} fur, 
            ${this.legs} legs, and a ${this.tail} tail.`;
        }
      };

      let mouse = Object.assign(Object.create(animal), {
        animalType: 'mouse',
        furColor: 'brown',
        legs: 4,
        tail: 'long, skinny'
      });
  
  <p>Object.assing() - Вы передаете целевой объект и любое количество исходных объектов, разделенных запятыми. Он скопирует все перечисляемые собственные свойства путем присвоения из исходных объектов целевым объектам с последним в приоритете. Если есть какие-либо конфликты имен свойств, версия из последнего переданного объекта побеждает.</p>

  <p>Object.create() — это функция ES5, которая может присоединять прототипы делегатов без использования конструкторов и ключевого слова new.</p>

  <b>Функция-конструктор необязательна для указания поведения  инициализации экземпляра объекта и ее обработатки.</b>

  <p>Любая  функция может создавать и возвращать обьекты. Если это не функция конструктор то она будет называться factory function.</p>

  <p>Улучшенные пример приведенного выше примера:</p>

    let animal = {
      animalType: 'animal',
    
      describe () {
        return `An ${this.animalType} with ${this.furColor} fur, 
          ${this.legs} legs, and a ${this.tail} tail.`;
      }
    };
    
    let mouseFactory = function mouseFactory () {
      return Object.assign(Object.create(animal), {
        animalType: 'mouse',
        furColor: 'brown',
        legs: 4,
        tail: 'long, skinny'
      });
    };

    let mickey = mouseFactory();

</div>
</details>

<details>
<summary>37. Слово new в JavaScript (L)?</summary>
<div>
  <p>Ключевое слово `new` используется для вызова конструктора. Что он на самом деле делает, так это:</p>

  <ul>
    <li>Создает новый экземпляр</li>
    <li>Привязывает this к новому экземпляру</li>
    <li>Устанавливает новому объекту ссылку на [[Prototype]]  объект, на который ссылается свойство `prototype` функции-конструктора.</li>
    <li>Устанавливает свойства .constructor нового объекта на конструктор, который был вызван.</li>
    <li>Устанавливает тип объекта после конструктора, который вы заметите в основном в консоли отладки. Например, вы увидите `[Object Foo]` вместо `[Object object]`.</li>
    <li>Позволяет instanceof проверять, является ли ссылка на прототип объекта тем же объектом, на который ссылается constructor.prototype. Оператор JavaScript instanceof используется для проверки типа объекта во время выполнения. Он возвращает логическое значение (true или false). Если возвращаемое значение истинно, то это указывает на то, что объект является экземпляром определенного класса, а если возвращаемое значение ложно, то это не так.
    </li>
  </ul>

</div>
</details>


<details>
<summary>38. Слово instanceof в JavaScript (L)?</summary>
<div>
    <p>Оператор instanceof проверяет, принадлежит ли объект к определённому классу. Другими словами, object instanceof constructor проверяет, присутствует ли объект constructor.prototype в цепочке прототипов object.</p>


      > function foo() {}
      > var bar = { a: ‘a’};
      > foo.prototype = bar; // Object {a: “a”}
      > baz = Object.create(bar); // Object {a: “a”}
      > baz instanceof foo // true. oops

   <p>Последний результат полностью соответствует спецификации JavaScript. Ничего не сломано — просто instanceof не может гарантировать безопасность типов. Его легко обмануть, заставив сообщать как о ложных срабатываниях, так и о ложноотрицательных.</p>

   <p>`instanceof` ограничивает возможность повторного использования вашего кода и потенциально может вносить ошибки в программы, использующие ваш код.</p>
</div>
</details>



<details>
<summary>39. JavaScript ES6? (L)</summary>
<div>

  <p>ECMAScript 2015 — это шестая редакция стандарта спецификации языка ECMAScript, который используется при реализации JavaScript. Чтобы запустить код ES6 в современном браузере, мы используем BABEL. BABEL — это транспилятор для JavaScript, который позволяет запускать код ES6 в любом браузере.</p>

  <h2>let & var</h2>
  <p>Одна из самых больших проблем с ключевым словом var заключается в том, что оно позволяет перезаписывать значения переменной.</p>
  <p>Если вы не хотите переприсваивать значение переменной, в этом случае мы выбираем ключевое слово let. ключевое слово let в ES6 поддерживает облочную область видимости, в которой область действия переменной ограничена блоком. В случае, если вы объявляете переменную с помощью ключевого слова var, область действия переменной может быть либо внутри функции, либо она может быть глобальной.</p>

  <h2>const</h2>
  <p>Добавлена read-only переменная  const.</p>

  <h2>Template literals</h2>
  <p>В ES6 появилась новая функция, называемая литералами шаблонов, для объединения или создания новых строк. Мы используем обратные галочки (``) для встраивания выражения. Placeholders представлены с помощью ${expression}</p>

  <h2>Spread and Rest operator</h2>
  <p>Оператор Rest позволяет нам представить количество аргументов в виде массива. Оператор Rest обозначается как (...args)</p>

    function sum(...theArgs) {
      return theArgs.reduce((previous, current) => {
        return previous + current;
      });
    }
    console.log(sum(1, 2, 3)); // output 6

  <p>Или такой пример: </p>

    // Use rest to enclose the rest of specific user-supplied values into an array:
      function myBio(firstName, lastName, ...otherInfo) { 
        return otherInfo;
      }

      // Invoke myBio function while passing five arguments to its parameters:
      myBio("Oluwatobi", "Sofela", "CodeSweetly", "Web Developer", "Male");

      // The invocation above will return:
      ["CodeSweetly", "Web Developer", "Male"]  

  <p>Текст после оператора rest ссылается на значения, которые вы хотите заключить в массив. Вы можете использовать его только перед последним параметром в определении функции.</p>
  
  <p>Оператор spread (...) помогает вам разложить итерации на отдельные элементы.</p>

  <p>Синтаксис spread работает с литералами массивов, вызовами функций и инициализированными объектами свойств для распределения значений итерируемых объектов по отдельным элементам. Таким образом, он делает противоположное оператору rest.</p>

    const arrValue = ['My', 'name', 'is', 'Jack'];

    console.log(arrValue);   // ["My", "name", "is", "Jack"]
    console.log(...arrValue); // My name is Jack


  <h2>Destructuring assignment</h2>

  <p>Деструктуризация позволяет нам извлекать значения в отдельные переменные из массива или объекта. Это позволяет нам присваивать значение левой стороне присваивания из массива или объекта.</p>
    
    const point = [10, 25, -34];

    const [x, y, z] = point;

    console.log(x, y, z); // 10 25 -34

    const [a, b,,, c] = [1, 2, 3, 4, 5, 6];
    console.log(a, b, c); // 1, 2, 5

  <h2>Arrow functions</h2>
  <p>Стрелочные функции — одна из примечательных особенностей ES6. Его поведение чем-то похоже на обычные функции, но синтаксически отличается.
  Это делает код очень четким и лаконичным.</p>
  <p>this и аргументы внутри стрелочной функции разрешаются лексически, что означает, что они берутся из внешней области действия функции.</p>
  <p>У стрелочной функции есть несколько ограничений: ее нельзя использовать в качестве метода объекта, конструктора или функции-генератора.</p>

  <h2>Default parameters in ES6 </h2>
  <p>ES6 представил параметры по умолчанию для создания более гибких функций. Параметры по умолчанию возвращаются, когда параметр отсутствует для функции</p>

    function greeting(name = "Anonymous") {
      return "Hello " + name;
    }
    console.log(greeting("Dave")); // Hello Dave
    console.log(greeting()); // Hello Anonymous

  <h2>Classes in ES6</h2>
  <p>ES6 предоставляет новый способ создания объектов с использованием ключевого слова class. Использование синтаксиса класса предназначено только для синтаксиса, и это не традиционные классы, это просто функция. </p>\

    class myclass{
      constructor(){
        this.a = 2
      }
    }
    var myobj = new myclass();
    console.log(typeof myclass)// function

  <h2>Modules in ES6 </h2>
  <p>Модули — одна из самых важных функций в ES6. В ES6 каждый модуль определяется в собственном файле. функции и переменные в одном модуле не видны другому модулю, если они не были экспортированы.</p>

  <p>Чтобы экспортировать определенные переменные из модуля, вы просто используете экспорт ключевого слова. Точно так же, чтобы использовать экспортированные переменные в другом модуле, вы используете import.</p>

    //random.js
    function generateRandom() {
        return Math.random();
    }

    function multiply(a, b) {
        return a * b;
    }

    export { generateRandom, multiply}


    //app.js
    import { generateRandom, multiply} from 'utility';

    console.log(generateRandom()); //logs a random number
    console.log(multiply(1, 2)); //2

  <h2>Promises in ES6</h2>
  <p>Promise — это объект, который даст одно значение, которое может быть либо разрешенным, либо неразрешенным значением. Он находится в трех состояниях: выполнено, отклонено или ожидает выполнения. Обратные вызовы могут быть прикреплены к promise, чтобы узнать причину разрешенного или неразрешенного значения.</p>

    var wait1000 = new Promise(function(resolve, reject) {
      setTimeout(resolve, 1000);
    }).then(function() {
      console.log("Yay!");
    });
  <a href="https://medium.com/javascript-scene/how-to-learn-es6-47d9a1ac2620">How to Learn ES6</a>
</div>
</details>


<details>
<summary>40. В чем преимущества использования spread оператора и чем он отличается от rest оператора? (L)</summary>
<div>
  Spread оператор синтаксиса ES6 очень полезен при написании кода в функциональном стиле, поскольку мы можем легко создавать копии массивов или объектов, не прибегая к Object.create, slice или функции библиотеки. Эта языковая функция часто используется в проектах с Redux и rx.js.

    function putDookieInAnyArray(arr) {
      return […arr, ‘dookie’];
    }
    const result = putDookieInAnyArray([‘I’, ‘really’, “don’t”, ‘like’]); // [“I”, “really”, “don’t”, “like”, “dookie”]
    const person = {
      name: ‘Todd’,
      age: 29,
    };
    const copyOfTodd = { …person };

  В свою очередь, rest оператор синтаксиса ES6 позволяет в сокращенном виде указывать неопределенное количество аргументов, передаваемых в функцию. Можно сказать, что он противоположен spread оператору: собирает данные и добавляет их в массив, вместо разделения массива данных. Он используется в аргументах функций, а также при деструктуризации массивов и объектов.

    function addFiveToABunchOfNumbers(…numbers) {
      return numbers.map(x => x + 5);
    }
    const result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9, 10); // [9, 10, 11, 12, 13, 14, 15]
    const [a, b, …rest] = [1, 2, 3, 4]; // a: 1, b: 2, rest: [3, 4]
    const { e, f, …others } = {
      e: 1,
      f: 2,
      g: 3,
      h: 4,
    }; // e: 1, f: 2, others: { g: 3, h: 4 }

</div>
</details>


<details>
<summary>41. Что такое compose?</summary>
<div>
 <p>Композиция - создание сложной функциональности за счет объединения более простых функций. В некотором смысле, композиция - это вложение функций, каждая из которых передает свой результат в качестве входных данных для другой функции. Но вместо того, чтобы создавать неразборчивое количество вложений, мы создадим функцию более высокого порядка - compose(), которая принимает все функции, которые мы хотим объединить, и возвращает нам новую функцию для использования.</p>
 <p>Это самый базовый вариант реализации. Обратите внимание: функции в аргументах будут выполняться справа налево. То есть сначала выполняется функция, расположенная справа, и ее результат передается в функцию слева от нее. </p>

    var compose = function(f, g) {
      return function(x) {
          return f(g(x));
      };
    };

 <p>Функция reverseAndUpper сначала переворачивает заданную строку, а затем переводит ее в верхний регистр. Мы можем переписать этот код, используя базовую функцию compose:</p>

    var reverseAndUpper = compose(upperCase, reverse);

 <p>Давайте реализуем более гибкую функцию compose, которая может включать любое количество других функций и аргументов. Предыдущая функция compose, которую мы рассмотрели, работает только с двумя функциями и принимает только первый переданный аргумент. Мы можем переписать ее так:</p>

    var compose = function() {
    var funcs = Array.prototype.slice.call(аргументы);
  
    return funcs.reduce(function(f,g) {
        return function() {
          return f(g.apply(this, аргументы));
        };
      });
    };

    Var doSometing = compose(upperCase, reverse, doSomethingInitial);
 
  <h2>Итог:</h2>
  
  <img src="https://miro.medium.com/max/1400/1*Gq3yQWvcjNEpoNzsek3ILg.jpeg"/>
  <img src="https://miro.medium.com/max/1400/1*nPi8K4S8noqPhm-t1IyWHQ.jpeg"/>

  <h2>Еще один способ реализации функции Compose.</h2>
  <p>Например, мы создадим функцию compose, которая получит любое количество функций в качестве аргументов. Для этого мы будем использовать оператор rest.</p>

    const compose = (...fns) => x =>
      fns.reduceRight(())

  <p>Функция compose возвращает функцию, которая ожидает своего начального значения - назовем её x. Отсюда у нас есть массив функций fns. Важно обратить внимание на порядок, в котором мы хотим их вызвать: он идет справа налево. Сначала мы вызываем upperCase, exclaim, а потом repeat. Чтобы сделать это, мы используем reduceRight метод.</p>

    const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);

  <p>Первым аргументом функции reduceRight являются аккумулятор и текущий элемент. Элемент является нашей функцией. С каждой итерацией мы возвращаем результат вызова накопленного значения текущей функции. Второй аргумент для reduceRight - это наше начальное значение, которым является наш x. Теперь мы можем использовать эту функцию, чтобы легко создавать новые композиции.</p>

  <p>Давай создадим функцию withСompose, которая будет составлять наши функции upperCase, exclaim, и repeat. Порядок аргументов нашей функции compose идет справа налево или снизу вверх.</p>

      const upperCase = str => str.toUpperCase();
      const exclaim = str => `${str}!`;
      const repeat = str => `${str} `.repeat(3);

      const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);

      const withСompose = compose(
        repeat,
        exclaim,
        upperCase
      );

      console.log(withСompose("I love coding")); // I LOVE CODING! I LOVE CODING! I LOVE CODING!

  <h3>Пример реализации pipe.</h3>
  <p>Функция pipe, которая аналогична compose, но порядок аргументов обратный. pipe также принимает любое количество функций и начальное значение, но на этот раз вызывает reduce. Таким образом, чтобы сделать функцию withСompose с pipe, мы просто меняем порядок аргументов.</p>

    const upperCase = str => str.toUpperCase();
    const exclaim = str => `${str}!`;
    const repeat = str => `${str} `.repeat(3);

    const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);

    const withСompose2 = pipe(
      upperCase,
      exclaim,
      repeat
    );

    console.log(withСompose2("I love coding")); // I LOVE CODING! I LOVE CODING! I LOVE CODING!

  <p>Хоть функция pipe и существует, всё же чаще используется функция compose, применяемая в функциональных языках, поскольку она следует математической модели композиции.</p>

  
</div>
</details>

<details>
<summary>42. Расскажите про Object.defineProperties?</summary>
<div>
<p>Метод Object.defineProperty - позволяет устанавливать свойствам некоторые настройки (можно ли свойство изменять, удалять и др.)</p>

    Object.defineProperty(объект, 'имя свойства', дескриптор);

<p>Дескриптор - это объект, который описывает поведение свойства. В нем могут быть следующие свойства (в скобках указаны значения по умолчанию):</p>

    value //значение свойства (undefined)
    writable //если true - свойство можно перезаписывать (false)
    configurable // если true, то свойство можно удалять (false)
    enumerable //если true, то свойство видно в цикле for..in (false)
    get //Функции, которая возвращает значение свойства (undefined)
    set //Функции, которая записывает значение свойства (undefined);

<p>Если со свойством произвести запрещенное действие, например, попытаться изменить в то время как writable = false, то ничего не произойдет (а в строгом режиме (при указании 'use strict') - будет ошибка). Также запрещено указывать value/writeble если указаны get/set.</p>

    var obj = {
      val1: 10, //Обычное свойство
    }

    //Создадим свойство через defineProperty
    Object.defineProperty(obj, 'val2', {
      value: 10,
      configurable: false //нельзя удалять
    });

    alert(obj.val1) //10
    alert(obj.val2) //10

    delete obj.val1
    delete obj.val2

    alert(obj.val1) //undefined
    alert(obj.val2) //10

<h3>useCases:</h3>
<p>Object.defineProperty в целом полезен для копирования дескрипторов свойств из одного объекта в другой с помощью связанных методов Object.getOwnPropertyNames() и Object.getOwnPropertyDescriptor(), например. при объединении вещей в прототип.</p>

<p>Object.getOwnPropertyDescriptor как раз позволяет достать свойства writable/configurable/enumerable etc.</p>

<p>И, как вы уже упоминали, их можно использовать для геттеров и сеттеров. Синтаксис литерала объекта работает только при создании новых объектов. Чтобы создать новые геттеры/сеттеры в существующем объекте (например, прототипе), вы должны использовать Object.defineProperty() или скопировать дескрипторы, как упоминалось выше.</p>

<p>Полезно, чтобы избежать перечисления через Object.keys(), for... in циклы, добавление свойств в подклассы массива и тому подобное. Это очень важно при добавлении полифилов во встроенные прототипы, особенно Object.prototype, поскольку вы не хотите, чтобы ваши добавленные методы внезапно отображались в циклах, поскольку это может нарушить работу другого кода, который не выполняет проверку .hasOwnProperty().</p>

<p>[[Writable]], [[Configurable]]  позволяют создавать свойства только для чтения, которые нельзя случайно перезаписать или удалить. Это отлично подходит для библиотек.</p>

<p>Object.freeze() / .seal() / .preventExtensions() расширяют этот тип защиты до такой степени, что вы можете защитить объекты в достаточной степени, чтобы создать несколько безопасных песочниц javascript eval, защищая прототипы встроенных объектов.</p>

<p>Метод Object.freeze() замораживает объект: это значит, что он предотвращает добавление новых свойств к объекту, удаление старых свойств из объекта и изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и записываемости. В сущности, объект становится эффективно неизменным. Метод возвращает замороженный объект.</p>

<p>Метод Object.seal() запечатывает объект, предотвращая добавление новых свойств к объекту и делая все существующие свойства не настраиваемыми. Значения представленных свойств всё ещё могут изменяться, поскольку они остаются записываемыми.</p>

<p>Метод Object.preventExtensions() предотвращает добавление новых свойств к объекту (то есть, предотвращает расширение этого объекта в будущем).</p>

</div>
</details>

<details>
<summary>43. Что такое IIFE?</summary>
<div>
<p> IIFE — это хороший способ защитить область действия вашей функции и переменные внутри нее. Любые переменные внутри IIFE не видимы для внешнего мира. Cуть паттерна в том, чтобы взять функцию и превратить её в выражение, а затем тут же его запустить.</p>


<h2>IIFE с отдаваемым значением</h2>
<p>Реально важной и полезной фичей IIFE является то, что с их помощью вы можете отдавать значение, которое будет назначено переменной.</p>

    var result = (function() {
      return "From IIFE";
    }());

    alert(result); // alerts "From IIFE"

<h2>IIFE с параметрами</h2>
<p>IIFE не только могут отдавать значения, но ещё и брать аргументы во время своего вызова. </p>

    (function IIFE(msg, times) {
      for (var i = 1; i <= times; i++) {
          console.log(msg);
      }
    }("Hello!", 5));

<h2>Классический модульный паттерн в JavaScript</h2>
<p>Пример модульного паттерна, который раскрывают всю мощь совместного применения замыканий и IIFE функций.</p>

    var Sequence = (function sequenceIIFE() { //обьект синглтон sequence
      
      // приватная переменная для хранения значения счетчика
      var current = 0;
      
      // объект, возвращаемый IIFE
      return {
          getCurrentValue: function() {
              return current;
          },
          
          getNextValue: function() {
              current = current + 1;
              return current;
          }
        };
        
    }());

    console.log(Sequence.getNextValue()); // 1
    console.log(Sequence.getNextValue()); // 2
    console.log(Sequence.getCurrentValue()); // 2

<p>Так как переменная current является приватной в IIFE, то никто кроме функций, имеющих доступ к IIFE через замыкание, не имеет к ней доступа.</p>

<h2>IIFE (webpack, scripts modules)</h2>
<p>Указывает webpack добавить оболочку IIFE вокруг выпускаемого кода.</p>

    module.exports = {
      //...
      output: {
        iife: true,
      },
    };

<p>как указано в ссылке ниже. Function declarations загружаются до выполнения любого кода, в то время как  Function expressions загружаются только тогда, когда интерпретатор достигает этой строки кода.</p>
<p>webpack обертывает все модули функциональными выражениями и объединяет их в файлы IIFE, чтобы убедиться, что после загрузки файла IIFE выполнит и подпишет модули как  function expressions, «чтобы избежать их выполнения и перегрузить браузер ненужными процессами в дополнение к получение выгоды от повторного использования».</p>

<h2>Доп информация</h2>
<h3>Проименованные функциональные выражения</h3>
<p>Да, функциональные выражения могут иметь имена. Самое обыденное и всюду объясняемое использование проименованных функциональных выражений — это рекурсия. Пока что не беспокойтесь о них, вы вполне можете понять IIFE и так.</p>

    var fibo = function fibonacci() {
        // тут вы можете использовать "fibonacci()"
    };

    // fibonacci() не сработает, а fibo() да.

<p>Разница тут в том, что функциональное выражение имеет имя “fibonacci”, которое можно использовать внутри самого выражения рекурсивным способом. (Тут вообще есть много всего интересного, например то, что имя функции всплывает в стектрейсе и т.п.).</p>

<h3>Примеры IIFE:</h3>
<p>Любое функциональное выражение с IIFE автоматически и единожды запускается и сразу исчезает.</p>

    let vlad = function() {
        alert("Hello from IIFE!"); //allert 
    }();

    console.log(vlad) // undefined

<h3>Анонимные функции</h3>
<p>Анонимная функция - функция, которая была объявлена без какой-либо функции с именем идентификатора, чтобы ссылаться на нее. Обычно она недоступна после ее первоначального создания. Эти функции создаются во время выполнения.</p>
</div>
</details>


<details>
<summary>44. Что такое Object.assign()?</summary>
<div>
<p></p>

    Object.assign(target, ...sources)

<ul>
  <li>target — это Объект, к которому вы хотите присвоить. В нашем случае экземпляр объекта класса.</li>
  <li>sources — это те источники), из которых будут поступать данные. В нашем случае один источник. Запись базы данных (набор).</li>
</ul>

<p>Свойства в целевом объекте будут перезаписаны свойствами в источниках, если они имеют одинаковый ключ. Свойства более поздних источников аналогичным образом перезапишут более ранние.</p>
<p>Метод Object.assign() копирует только перечисляемые и собственные свойства из исходного объекта в целевой объект. Он использует [[Get]] для источника и [[Set]] для цели, поэтому он будет вызывать геттеры и сеттеры. Поэтому он присваивает свойства, а не просто копирует или определяет новые свойства.</p>

</div>
</details>



<br/>

**Patterns and algorithms**:

<details>
<summary>1. Big O notation?</summary>
<div>
  <p>Big O нотация определяет эффективность алгоритма</p>
  <ul>
    <li>O - относится к порядку функции или скорости ее роста</li>
    <li>n — длина сортируемого массива</li>
  </ul>
  <p>При рассмотрении многих наиболее часто используемых алгоритмов сортировки рейтинг O (n log n) в целом является лучшим, которого можно достичь. Алгоритмы, которые работают с этим рейтингом, включают быструю сортировку, сортировку кучей и сортировку слиянием. Быстрая сортировка является стандартом и используется по умолчанию почти во всех языках программного обеспечения.</p>
  <img src="https://miro.medium.com/max/1400/1*KfZYFUT2OKfjekJlCeYvuQ.jpeg"/>

  <h3>O(1) - Constant time</h3>
  <p>Поиск значения, когда вы знаете, что ключ (объекты) или индекс (массивы) всегда выполняется за один шаг  и является постоянным временем.</p>

  <h3>O(log n) - Logarithmic Time</h3>
  <p>Если вы знаете, на какой стороне массива искать элемент, вы экономите время, срезая другую половину.</p>

    //You decrease the amount of work you have to do with each step
    function thisOld(num, array){
      var midPoint = Math.floor( array.length /2 );
      if( array[midPoint] === num) return true;
      if( array[midPoint] < num ) --> only look at second half of the array
      if( array[midpoint] > num ) --> only look at first half of the array
      //recursively repeat until you arrive at your solution
      
    }
    thisOld(29, sortedAges) // returns true 
    //Notes
    //There are a bunch of other checks that should go into this example for it to be truly functional, but not necessary for this explanation.
    //This solution works because our Array is sorted
    //Recursive solutions are often logarithmic
    //We'll get into recursion in another post!

  <p>Простейший пример — бинарный поиск. Если массив отсортирован, мы можем проверить, есть ли в нём какое-то конкретное значение, методом деления пополам. Проверим средний элемент, если он больше искомого, то отбросим вторую половину массива — там его точно нет. Если же меньше, то наоборот — отбросим начальную половину. И так будем продолжать делить пополам, в итоге проверим log n элементов.</p>

  <p>Сколько раз нужно разделить n на 2, чтобы получить 1? log(n). Итак, у нас есть уровни log(n). Таким образом, наше общее время выполнения равно O(n (работа на уровень) * log(n) (количество уровней)), n log(n) раз. </p>


  <h3>O(n) — Linear Time</h3>
  <p>Вы должны просмотреть каждый элемент в массиве или списке, чтобы выполнить задачу. Одиночные циклы for почти всегда имеют линейное время. Кроме того, методы массива, такие как indexOf, также являются линейными по времени. Вы просто абстрагировались от процесса зацикливания</p>

    //The number of steps you take is directly correlated to the your input size
    function addAges(array){
      var sum = 0;
      for (let i=0 ; i < array.length; i++){  //has to go through each value
        sum += array[i]
      }
    return sum;
    }
    addAges(sortedAges) //133

  <h3>O(A*B) - два независимых параметра</h3>
  <p>Чтобы получить такую сложность вложенный цикл должен идти по независимой структуре данных.</p>
  <img src="https://c10.patreonusercontent.com/4/patreon-media/p/post/51378490/1c8ca889319e4269932f571c8deca755/eyJ3Ijo4MjB9/1.png?token-time=1654041600&token-hash=6085SFLkXFp_GxqrNQBLWkfyZxcvz2hOComuVGleYOk%3D"/>

   <p>В текущем примере считается сумма чисел внутренних под массивов, размер и содержимое которых не зависят от внешнего массива. Поэтому сложность O(A+B).</p>

  <h3>O(n²) — Quadratic Time</h3>
  <p>Вложенные циклы for имеют квадратичное время, потому что вы выполняете линейную операцию внутри другой линейной операции (или n*n = n²).</p>

    //The number of steps you take is your input size squared
    function addedAges(array){
      var addedAge = [];
        for (let i=0 ; i < array.length; i++){ //has to go through each value
          for(let j=i+1 ; j < array.length ; j++){ //and go through them again
            addedAge.push(array[i] + array[j]);
          }
        }
      return addedAge;
    }
    addedAges(sortedAges); //[ 46, 49, 51, 53, 51, 53, 55, 56, 58, 60 ]
    //Notes
    //Nested for loops. If one for loop is linear time (n)
    //Then two nested for loops are (n * n) or (n^2) Quadratic!

  <h3>O(2^n) — Exponential Time</h3>
  <p>Экспоненциальное время обычно подходит для ситуаций, когда вы не так много знаете, и вам нужно попробовать все возможные комбинации или перестановки.</p>

    //The number of steps it takes to accomplish a task is a constant to the n power
    //Thought example
    //Trying to find every combination of letters for a password of length n

  <img src="https://www.freecodecamp.org/news/content/images/2021/06/0_XZsrnwao98R3dGTB.png"/>

  <p>Доп информация по времени </p>

    O(1) - затраты времени не зависят от размера задачи
    O(log(n)) - при увеличении размера задачи вдвое, затраты времени меняются на постоянную величину
    O(n) - при увеличении размера задачи в 2 раза, затраты времени возрастут тоже в два раза
    O(n^2) - при увеличении размера задачи в 2 раза, затраты времени возрастут примерно в четыре раза
    O(n*log(n)) - при увеличении задачи в два раза, затраты времени возрастут в два раза, плюс некоторая прибавка, относительный вклад которой уменьшается с ростом n. При малых n может вносить очень большой вклад. O(n*log(n)) начинает расти как квадрат при малых n, но потом рост замедляется почти до линейного
    O(n^p) - полиномиальный алгоритмы, остающиеся мечтой для некоторых задач.
    O(a^n), O(n!), O(n^n) - неполиномиальные алгоритмы, в порядке ускорения увеличения затрат времени

  <a href="https://www.patreon.com/posts/shpargalka-51378490">Шпаргалка</a>
</div>
</details>



<details>
  <summary>2. Decorator pattern?</summary>
  <div>
  <p>Декоратор – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией.</p>
  <p>Обычно безопасно заменить функцию или метод декорированным, за исключением одной мелочи. Если исходная функция предоставляет свойства, такие как func.calledCount или типа того, то декорированная функция их не предоставит. Потому что это обёртка. Так что нужно быть осторожным в их использовании. Некоторые декораторы предоставляют свои собственные свойства.</p>
  <p>Декораторы можно рассматривать как «дополнительные возможности» или «аспекты», которые можно добавить в функцию. Мы можем добавить один или несколько декораторов. И всё это без изменения кода оригинальной функции!</p>
  <p>Для реализации cachingDecorator мы изучили методы:</p>
  <b>func.call(context, arg1, arg2…) – вызывает func с данным контекстом и аргументами.</b>
  <b>func.apply(context, args) – вызывает func, передавая context как this и псевдомассив args как список аргументов.</b>
  <p>В основном переадресация вызова выполняется с помощью apply:</p>

      let wrapper = function(original, arguments) {
        return original.apply(this, arguments);
      };

  <p>Мы также рассмотрели пример заимствования метода, когда мы вызываем метод у объекта в контексте другого объекта. Весьма распространено заимствовать методы массива и применять их к arguments. В качестве альтернативы можно использовать объект с остаточными параметрами ...args, который является реальным массивом.</p>
  </div>
</details>

<details>
<summary>3. Observer pattern?</summary>
<div>
  <p>В JavaScript часто возникает проблема. Вам нужен способ обновлять части страницы в ответ на определенные события с данными, которые они предоставляют. Скажем, например, пользовательский ввод, который вы затем проецируете на один или несколько компонентов. Это приводит к большому количеству push-and-pull в коде, чтобы все было синхронно.</p>

  <h2>The event observer:</h2>

    EventObserver
    │ 
    ├── subscribe: adds new observable events
    │ 
    ├── unsubscribe: removes observable events
    |
    └── broadcast: executes all events with bound data

  <p>Начните с пустого списка наблюдаемых событий и делайте это для каждого нового экземпляра.</p>

    class EventObserver {
      constructor() {
        this.observers = [];
      }
    }

  <h2>The Subscribe Method:</h2>

    subscribe(fn) {
      this.observers.push(fn);
    }

  <p>Возьмите список наблюдаемых событий и поместите новый элемент в массив. Список событий — это список функций обратного вызова.</p>

  <h2>The Unsubscribe Method:</h2>

    unsubscribe(fn) {
      this.observers = this.observers.filter((subscriber) => subscriber !== fn);
    }

  <p>Отфильтруйте из списка все, что соответствует функции обратного вызова. Если совпадений нет, обратный вызов остается в списке. Фильтр возвращает новый список и переназначает список наблюдателей.</p>

  <h2>The Broadcast Method:</h2>
  <p>Для вызова всех events:</p>

    broadcast(data) {
      this.observers.forEach((subscriber) => subscriber(data));
    }

  <p>Перебираем список наблюдаемых событий и выполняем все обратные вызовы. При этом мы получаем необходимое отношение «один ко многим» с подписанными событиями. Мы передаем параметр data, который связывает колбэки.</p>


    class EventObserver {
      constructor() {
        this.observers = [];
      }

      subscribe(fn) {
        this.observers.push(fn);
      }

      unsubscribe(fn) {
        this.observers = this.observers.filter((subscriber) => subscriber !== fn);
      }

      broadcast(data) {
        this.observers.forEach((subscriber) => subscriber(data));
      }
    }

    const getWordCount = (text) => text ? text.trim().split(/\s+/).length : 0;

    const wordCountElement = document.createElement('p');

    wordCountElement.className = 'wordCount';
    wordCountElement.innerHTML = 'Word Count: <strong id="blogWordCount">0</strong>';
    document.body.appendChild(wordCountElement);

    const blogObserver = new EventObserver();

    blogObserver.subscribe((text) => {
      const blogCount = document.getElementById('blogWordCount');

      blogCount.textContent = getWordCount(text);
    });

    const blogPost = document.getElementById('blogPost');

    blogPost.addEventListener('keyup', () => blogObserver.broadcast(blogPost.value));

  <p>The observer pattern может помочь вам решить реальные проблемы в JavaScript. Он решает извечную проблему синхронизации множества элементов с одними и теми же данными. Как это часто бывает, когда браузер запускает определенные события.</p>



  <a href="https://www.sitepoint.com/javascript-design-patterns-observer-pattern/">JavaScript Design Patterns: The Observer Pattern</a>
</div>
</details>

<details>
<summary>4. Pub/sub pattern?</summary>
<div>
  <p>Шаблон Pub/sub включает промежуточное программное обеспечение, которое также называется брокером Pub/sub. Брокер Pub/sub обрабатывает взаимодействие между издателями и подписчиками. Издатели публикуют содержимое или публикации брокеру Pub/sub, и он обрабатывает доставку этого содержимого соответствующему подписчику.</p>

  <p>Брокер Pub/sub также обеспечивает свободную развязку издателей и подписчиков и поддерживает отношения «многие ко многим» между издателями и подписчиками.</p>


  <p>Таким образом, в отличие от шаблона наблюдателя, шаблон Pub/sub допускает наличие нескольких издателей и нескольких подписчиков.</p>

  <p>В шаблоне Pub/sub издатель публикует содержимое в теме, и заинтересованные подписчики получают доступ к этому содержимому, отправляя подписки брокеру Pub/sub, чтобы подписаться на эту тему. Кроме того, в отличие от шаблона наблюдателя, и издателям, и подписчикам не нужно знать друг о друге.</p>

  <img src="https://miro.medium.com/max/1400/1*SZZ2qpXr6eO-9u_7Dd5jyw.png" />


  <p>Существует множество реализаций шаблонов pub/sub, например, IBM Websphere MQ, RabbitMQ и RocketMQ, Apache Kafka, Google Cloud Pub/Sub и Pushy.</p>

  <p>Наша реализация pub/sub состоит из класса pub/sub, который содержит массив событий, который используется для хранения списка всех опубликованных событий.</p>
  <p>Кроме того, класс pub/sub имеет метод подписки, который обрабатывает все взаимодействия между издателями и подписчиками.</p>

    class Pubsub {
      constructor() {
        this.events = {};
      }

      subscription (eventName, func) {
        return {
          subscribe: () => {
            if (this.events[eventName]) {
              this.events[eventName].push(func);
              console.log(`${func.name} has subscribed to ${eventName} Topic!`)
            } else {
              this.events[eventName] = [func];
              console.log(`${func.name} has subscribed to ${eventName} Topic!`)
            }
          },

          unsubscribe: () => {
            if(this.events[eventName]){
              this.events[eventName] = this.events[eventName].filter((subscriber) => subscriber !== func);
              console.log(`${func.name} has unsubscribed from ${eventName} Topic!`)
            }
          }


        }
      } 


      publish(eventName, ...args) {
        const funcs = this.events[eventName];
        if (Array.isArray(funcs)) {
          funcs.forEach((func) => {
            func.apply(null, args);
          });
        }
      }
    }

    const speak = (param) => {
      console.log(`I am ${param}`);
    };

    const greetAll = (x, y, z) => {
      console.log(`Hello ${x}, ${y}, ${z}`);
    };

    const pubsub = new Pubsub();


    pubsub.subscription("greet", greetAll).subscribe() // prints greetAll has subscribed to greet Topic!

    pubsub.subscription("sayName", speak).subscribe() // prints speak has subscribed to sayName Topic!
    pubsub.subscription("sayName", greetAll).unsubscribe() // prints greetAll has unsubscribed from sayName Topic!



    pubsub.publish("greet", "Lawrence Eagles", "John Doe", "Jane Doe"); // prints Hello Lawrence Eagles, John Doe, Jane Doe

    pubsub.publish("sayName", "Lawrence Eagles"); // prints I am Lawrence Eagles

  <p>В нашем небольшом примере выше метод подписки возвращает объект, содержащий метод подписки, используемый для обработки подписок, и метод отмены подписки, который обрабатывает отказы от подписки.

  Наконец, наш класс pub/sub содержит метод публикации, который принимает переменное количество аргументов и вызывает все функции, которые подписаны на указанное событие с этими аргументами, с помощью применения.</p>

  <h3>Преимущества шаблона публикации/подписки</h3>
  <ul>
    <li>Слабая развязка шаблона Pub/sub делает его пригодным для решения многих задач разработки программного обеспечения. Он обладает высокой масштабируемостью и хорошо подходит для распределенных архитектур, таких как микросервисы.</li>
    <li>Pub/sub отлично подходит для создания уведомлений о событиях, распределенного кэширования, распределенного ведения журналов и систем с несколькими источниками данных.</li>
  </ul>
</div>
</details>


<details>
<summary>5. Отличия Observable от Pub/sub pattern?</summary>
<div>
  <img src="https://habrastorage.org/r/w1560/files/39b/7f9/806/39b7f98064b5458e9e2837cca15e3525.jpg" />
  <p>Pub-sub паттерн является одной из вариаций паттерна Observer. Исходя из названия в паттерне выделяют два компонента Publisher (издатель) и Subscriber (подписчик). В отличие от Observer, связь между объектами осуществляется посредством канала связи Event Channel (шины событий).
  </p>
  <p>Publisher кидает свои события в Event Channel, а Subscriber подписывается на нужное событие и слушает его на шине, что обеспечивает отсутствие прямой связи между подписчиком и издателем.</p>

  <h3>Таким образом можно выделить основные отличительные особенности между Pub-sub и Observer:</h3>
  <ul>
    <li>отсутствие прямой связи между объектами</li>
    <li>объекты сигнализируют друг другу событиями, а не состояниями объекта</li>
    <li>возможность подписываться на различные события на одном объекте с различными обработчиками</li>
  </ul>

  <p>Одной из наиболее известных реализаций паттерна pub-sub является Backbone, AmplifyJs и др. DOM, в некоторой степени тоже реализует модель pub-sub.</p>
</div>
</details>



<details>
<summary>6. Mediator pattern?</summary>
<div>
<p>На основе pub-sub строится работа паттерна Mediator, который позволяет наладить коммуникацию между различными компонентами системы. Mediator представляет собой глобальный объект в системе, о котором знают все компоненты системы, при этом компонент может выступать как слушателем события, так и издателем другого события, таким образом налаживая коммуникацию между объектами системы.</p>

<p>Если провести аналогию, то Mediator это городская АТС, в которую приходят входящие и исходящие вызовы от абонентов, а доходят они строго до нужного абонента. Но как мы знаем у телефонной сети есть недостаток — на новый год она может оказаться перегруженной огромным количеством звонков и перестать доставлять вызова абонентам. Тоже самое может произойти и с Mediator, когда он не справится с потоком событий.</p>

<p>Mediator особенно полезен в тех случаях, когда наблюдаются множественные однонаправленные или двунаправленные связи между различными компонентами системы. Особенно паттерн полезен, когда в приложении имеются вложенные друг в друга компоненты системы (например, дочерние композиционные элементы), чтобы не было необходимости пробрасывать callbacks используя модель всплытия события изнутри наружу. Достаточно предоставить Mediator внутреннему компоненту, который опубликует свое событие, а другие компоненты узнают об этом событии.</p>

<p>Mediator паттерн довольно успешно реализован в Backbone — сам глобальный объект Backbone можно использовать в качестве Mediator, либо унаследоваться от Backbone.Events.</p>
</div>
</details>


<br/>

**TypeScript**:

<details>
<summary>1. Что такое TypeScript и зачем использовать его вместо JavaScript??</summary>
<div>
  <p>TypeScript (TS) – это надмножество JavaScript (JS), среди основных особенностей которого можно отметить возможность явного статического назначения типов, поддержку классов и интерфейсов. Одним из серьёзных преимуществ TS перед JS является возможность создания, в различных IDE, такой среды разработки, которая позволяет, прямо в процессе ввода кода, выявлять распространённые ошибки. Применение TypeScript в больших проектах может вести к повышению надёжности программ, которые, при этом, можно разворачивать в тех же средах, где работают обычные JS-приложения.
  </p>

  <ul>
    <li>TypeScript поддерживает современные редакции стандартов ECMAScript, код, написанный с использованием которых, компилируется с учётом возможности его выполнения на платформах, поддерживающих более старые версии стандартов. Это означает, что TS-программист может использовать возможности ES2015 и более новых стандартов, наподобие модулей, стрелочных функций, классов, оператора spread, деструктурирования, и выполнять то, что у него получается, в существующих средах, которые пока этих стандартов не поддерживают.</li>
    <li>TypeScript – это надстройка над JavaScript. Код, написанный на чистом JavaScript, является действительным TypeScript-кодом.</li>
    <li>TypeScript расширяет JavaScript возможностью статического назначения типов. А именно, она включает в себя:
    <ul> 
      <li>интерфейсы</li> 
      <li>перечисления</li> 
      <li>гибридные типы</li>
      <li>обобщённые типы (generics)</li>
      <li>типы-объединения</li>
      <li>типы-пересечения</li>
      <li>модификаторы доступа</li>
    </ul>
    Применение TypeScript, кроме того, немного упрощает работу за счёт использования вывода типов. В TypeScript есть несколько мест, где используется автоматический вывод типа, когда тип данных в явном виде не указан.
    </li>
    <li>Применение TypeScript, в сравнении с JavaScript, значительно улучшает процесс разработки. Дело в том, что IDE, в реальном времени, получает сведения о типах от TS-компилятора.</li>
    <li>При использовании режима строгой проверки на null (для этого применяется флаг компилятора --strictNullChecks), компилятор TypeScript не разрешает присвоение null и undefined переменным тех типов, в которых, в таком режиме, использование этих значений не допускается.</li>
    <li>Для использования TypeScript нужно организовать процесс сборки проекта, включающий в себя этап компиляции TS-кода в JavaScript. Компилятор может встроить карту кода (source map) в сгенерированные им JS-файлы, или создавать отдельные .map-файлы. Это позволяет устанавливать точки останова и исследовать значения переменных во время выполнения программ, работая непосредственно с TypeScript-кодом.</li>
    <li>TypeScript — это опенсорсный проект Microsoft, выпущенный под лицензией Apache 2. Инициатором разработки TypeScript является Андерс Хейлсберг. Он причастен к созданию Turbo Pascal, Delphi и C#.</li>
    <li>Объектно-ориентированное программирование: TypeScript поддерживает концепции объектно-ориентированного программирования, такие как интерфейсы, наследование, классы и многое другое.</li>
    <li>Компиляция: в отличие от JavaScript, который является интерпретативным языком, TypeScript компилирует код для вас и находит ошибки компиляции, что упрощает отладку.</li>
  </ul>
  <img src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/484/original/Typescript_Compilation_Process.png?1623239887" />

  <p>TypeScript добавляет необязательную статическую типизацию и языковые функции, такие как классы и модули. Важно знать, что все эти расширенные функции добавляют JavaScript нулевую стоимость. TypeScript — это исключительно инструмент времени компиляции. После компиляции у вас остается простой идиоматический JavaScript. TypeScript — это язык для разработки JavaScript в масштабе приложения.</p>

  <img src="https://s3.ap-south-1.amazonaws.com/myinterviewtrainer-domestic/public_assets/assets/000/000/485/original/Typescript_Artboard_3.png?1623240026" />
</div>
</details>



<details>
<summary>2. Unknown type TS?</summary>
<div>
  <p>Неизвестный тип является типобезопасным аналогом любого типа. Неизвестному типу можно присвоить что угодно, но неизвестный тип нельзя присвоить ничему, кроме самого себя и any, без выполнения утверждения типа сужения на основе потока управления. Вы не можете выполнять какие-либо операции над переменной неизвестного типа без предварительного утверждения или сужения ее до более конкретного типа.</p>
  <p>Рассмотрим следующий пример. Мы создаем переменную foo неизвестного типа и присваиваем ей строковое значение. Если мы попытаемся присвоить эту неизвестную переменную строковой переменной bar, компилятор выдаст ошибку.</p>

    let foo: unknown = "Akshay";
    let bar: string = foo; // Type 'unknown' is not assignable to type 'string'.(2322)

  <p>Вы можете сузить переменную неизвестного типа до чего-то определенного, выполнив проверки typeof или сравнения или используя type guards. Например, мы можем избавиться от вышеуказанной ошибки,</p>

    let foo: unknown = "Akshay";
    let bar: string = foo as string;

  <p>Другой пример</p>

    let vakr:unknown = 1011

    let vakr2:any = vakr
    let vakr3:number = vakr as number

    let vakr4:number;
    if( typeof vakr == 'number'){
      vakr4 = vakr
      console.log(vakr4)
    }

</div>
</details>

<details>
<summary>3. Never VS Void type TS?</summary>
<div>
  <p>Как следует из названия, тип never представляет собой тип значений, которые никогда не встречаются. Например, функция, которая никогда не возвращает значение или всегда выдает исключение, может пометить тип возвращаемого значения как never.</p>

    function error(message: string): never {
      throw new Error(message);
    }


  <p>Вы можете задаться вопросом, зачем нам нужен тип «never», когда у нас уже есть «void». Хотя оба типа выглядят одинаково, они представляют собой два совершенно разных понятия.</p>
  
  <p>Функция, которая не возвращает значение, неявно возвращает значение undefined в JavaScript. Следовательно, даже если мы говорим, что он ничего не возвращает, он возвращает «undefined». Обычно в таких случаях мы игнорируем возвращаемое значение. Предполагается, что такая функция имеет возвращаемый тип void в TypeScript.</p>

    // This function returns undefined
    function greet(name: string) {
      console.log(`Hello, ${name}`);
    }

    let greeting = greet("David");
    console.log(greeting);  // undefined

  <p>Напротив, функция, имеющая тип never, никогда не возвращает значений. Она также не возвращает значение undefined. Есть 2 случая, когда функции должны никогда не возвращать тип:</p>

    В случае бесконечного цикла -  while(true){} .
    В случае если функция прокидывает ошибку function foo(){throw new Exception('Error message')}


</div>
</details>
<details>
<summary>4. Enums TS?</summary>
<div>
  <p>Перечисления позволяют нам создавать именованные константы. Это простой способ дать более понятные имена числовым значениям констант. Перечисление определяется ключевым словом enum, за которым следует его имя и члены.</p>

  <p>Рассмотрим следующий пример, определяющий перечисление Team с четырьмя значениями.</p>

    enum Team {
      Alpha,
      Beta,
      Gamma,
      Delta
    }
    let t: Team = Team.Delta;


  <p>По умолчанию перечисления начинают нумерацию с 0. Вы можете переопределить нумерацию по умолчанию, явно назначив значения ее элементам.</p>

  <p>TypeScript также позволяет создавать перечисления со строковыми значениями следующим образом:</p>

    enum Author {
      Anders = "Anders",
      Hejlsberg = "Hejlsberg"
    };

  <p>Тело перечисления состоит из нуля или более элементов. Элементы перечисления имеют численное значение ассоциированное с именем, и могут быть либо константой, либо могут быть вычислены. Элемент перечисления считается константой, если:</p>

  <ul>
    <li>Он не имеет инициализатора, предшествующий элемент перечисления был константой. В этом случае значение текущего элемента перечисления будет равняться значению предшествующего элемента перечисления плюс единица. Исключением является первый элемент перечисления. Если элемент не имеет инициализатора, ему присваивается значение 0.</li>
    <li>Элемент перечисления инициализирован с константным выражением перечисления. Константное выражение перечисления - это подмножество TypeScript выражений, которое может быть полностью вычислено во время компиляции.</li>
  </ul>

  <p>Во всех остальных случаях считается, что элемент перечисления вычисляем.</p>

    enum FileAccess {
        // константные элементы
        None,
        Read    = 1 << 1,
        Write   = 1 << 2,
        ReadWrite  = Read | Write,
        // вычисляемые элементы
        G = "123".length
    }
  <h3>Окружающие вычисления</h3>

  <p>Окружающие перечисления используются для описания формы уже существующих перечислений.</p>

    declare enum Enum {
      A = 1,
      B,
      C = 2
    }

  <p>Одно важное отличие между окружающим и не окружающим перечислениями в том, что в обычных перечислениях элементы, не имеющие инициализатора, считаются константными элементами. Для элемента не константного окружающего перечисления, не имеющего инициализатора, элемент считается вычисляемым.</p>

  <h3>Константные вычисления</h3>

  <p> Константые перечисления определяются используя модификатор const, предшествующий ключевому слову enum.</p>

    const enum Enum {
        A = 1,
        B = A * 2
    }
    
  <p>Константные перечисления могут только использовать константные выражения перечисления, и в отличие обычных перечислений они полностью удаляются в течение компиляции. Элементы константного перечисления встраиваются в местах использования. Это возможно, поскольку константные перечисления не могут иметь вычисляемых элементов.</p>

    const enum Directions {
        Up,
        Down,
        Left,
        Right
    }
    
    let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]

  <p>в сгенерированном коде превратится в</p>

    var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right 

<a href="http://typescript-lang.ru/docs/Enums.html">Перечисления</a>
</div>
</details>


<details>
<summary>5. Optional chaining и Nullish coalescing в TS?</summary>
<div>
  <h3>Optional chaining</h3>
  <p>Необязательная цепочка позволяет вам обращаться к свойствам и вызывать методы для них в цепочке. Вы можете сделать это с помощью оператора ‘?.’.

  TypeScript немедленно прекращает выполнение какого-либо выражения, если оно сталкивается со значением «null» или «undefined», и возвращает «undefined» для всей цепочки выражений.

  Используя необязательную цепочку, опишем следующее выражение:</p>

    let x = foo === null || foo === undefined ? undefined : foo.bar.baz();

  <p>Можно записать как:</p>

    let x = foo?.bar.baz();


  <h3>Nullish coalescing</h3>
  <p>Если person.firstName отсутствует, мы вернемся к значению John.</p>

    const name = person.firstName ?? 'John';
</div>
</details>



<details>
<summary>6. Типы в TS?</summary>
<div>
  <img src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/002/543/original/Typescript-primitive-types.png?1642578765" />

  <p>TypeScript добавляет слой статических типов. Если тип у переменной указан, то в приложении в дальнейшем он не меняется.</p>
  <p>Типы существую при компиляции или проверке исходного кода.</p>
  <p>Каждое место хранения данных имеет статический тип. (Аргумент, переменная...)</p>

    let str: string;
    str = 'abc';
  <p>В большинств случаев TypeScript корректно определяет тип. Это избовляет от необходимости везде писать аннотацию.</p>  

  <h3>Определение типа через выражения</h3>
  <ul>
    <li>Аннотация бывает сложно составной</li>
    <li>При необходимости использовании нескольких варинтов типов для переменной используется оператор |</li>
  </ul>

      let myScore: number | string   //union

  <h3>Псевдоним типа (алиас)</h3>
  <p>При частном использовании составного типа, ему задают псевдоним. Имена псевдонимов, по соглашению, начинаются с большой буквы.</p>

    type Score = number | string
    const myScore: Score = 7

  <h3>Когда аннтоация действительно нужна</h3>
  <p>Когда функция возвращает тип any и мы хотим утчонить значение.</p>
  <p>Когда мы обьявляем и присваеваем переменную в разных местах.</p>
  <p>Когда мы хотим, чтобы тип был сложносоставной и не определялся автоматически.</p>

  
</div>
</details>



<details>
<summary>7. Типизация массивов в TS?</summary>
<div>
  <h2>Списки</h2>
  <p>

  </p>

    const arr: Array<number> = []
    const arr: number[] = []

    const arr2: string[][] = []  //Массив массивов или вложенный массив
    arr2.push(['a', 'b'])

    type MyType = (string | number)
    const arr3: (string | number)[] = []


  <h2>Кортежи</h2>
  <p>Кортеж - сущность с фиксированным числом элементов. Не может иметь большее или меньшее число элементов, чем зафиксированное.</p>

    const typle1: [string, boolean, number] = ['abc', true, 0] //в массиве будет только 3 элемента, их типы соотвествуют по указанному порядку
  
  <p>Tuple хорошо подходит под работу с CSV файлами. (Coma separated value)</p>

    type SimpleCsv = [string, string, number]
    const example: SimpleCsv[] = [
      ['str', 'str', 32]
    ]
</div>
</details>



<details>
<summary>8. Работа с обьектами в TS?</summary>
<div>
  <p>Type для обьекта.</p>

    type MyObj = {
      a: number;
      b: number;
      c: string;
    }

    const obj: MyObj = { a: 1, b: 2, c: 'sdsd' }

    const obj1: object = { };

  <p>Interface для обьекта</p>

    inteface MyObject {
      readonly a: number;   // <--- readonly указывает, что ключ только для чтения и не может быть перезаписан 
      b: number;
      c?: string;   // <--- необязательное поле благодаря ?
      print?: () => number; // <--- при такой декларации можно делать опциональной 
      print2(): number; // более современный метод декларации
      [key string]: string | number;
    }

  <p>Обьединение interface</p>

    interface Person {
      name: stirng;
    }

    interface Person {
      age: number;
    }

    const john: Person = {
      name: 'John',
      age: 40
    }

    // Подводные камне с обьединением

    inteface Account {
      login: string;
    }

    const myAcc: Account = {
      login: 'michey'
    }

    // выдастся ошибка Type '{login: string;}' is missing the following properties from type 'Account': displayName ,id, rpDisplayName
    // потому что в lib.dom.d.ts есть свое определение типа Account (DOM API)
    // Из за одинаковых имен интерфейсов возможны проблемы с пересечением.

    // Решение проблемы добавлять I в началае имени интерфейсов IAccount

  <p>Обьединение разных интерфейсов в друг друга</p>

    interface IAccount {
      email: string;
      login: string;
      active: boolean;
    }

    interface IDeveloper extends IAccount, IPerson .... etc { // обьединит все ключи из указанных интерфейсов
      skills: string[],
      level: string;
    }

    const john: IDeveloper = {
      name: 'John',
      age: 40,
      email: 'pet@mail.ru',
      login: 'pet14log',
      active: true,
      skills: ['tomador', 'pomador', 'JavaSquirt'],
      level: '80lvl',
    }

  <p> Обьединять можно и типы</p>

    type Person = {

    }

    type MyAccount = {

    }

    type MyDeveloper = {

    }

    type FrontendDeveloper = Person & MyAccount & MyDeveloper;

    const devArr: FrontendDeveloper[] = []
</div>
</details>



<details>
<summary>9. Работа с функциями в TS?</summary>
<div>
  <p>Обьявление функций</p>

    const fn1 = (num: number): string => {
      return String(num)
    }

    function fn2(cb: () => string) {}

    type Callback = (num: number) => string;

    function fn2(cb?: Callback) { // обязательна проверка на то передается параметр или нет
      if(cb === undefined){
        cb = String;
      }

      cb(12)
    }


  <p>Параметры по умолчанию</p>

    function createPoint(x = 0, y = 0) { }

    function createPoint(x: number = 0, y: number = 0): [number, number] {
      return [x, y]
    }
    
  <p>Список аргументов</p>

    function createPoint(...nums: number[]): string {
      return nums.join('-')
    }

  <p>Входной аргумент обьект</p>

    interface Printable {
      label: string;
    }


   // Если функция ни чего не возвращает или в какой то момент явно указывается return undefined то указываем :void
    function printReport(obj: Printable): void {
      return undefined
    }

    // drink переданны в printReport будет работать если он не расширяется Printable, потому что входящий obj: Printable  это как минимальный сценарий для входного обьекта. В drink есть label. Этого достаточно.
    // так функции становятся более универсальными и не надо создавать отдельную функцию под каждый входящий обьект
    const drink = {
      label: 'pepsi',
      price: 90,
    }

    printReport(drink)


  <p>Повторное обьявление функций для указания разных входный аргументов для одной и той же функции. (overload)
    При перегрузке количество аргументов не должно меняться. 
    Сколько вариантов функции мы оформили, столько проверок должно быть внутри функции.  
  </p>

    function pickCard(x: number): {suit: string; card: number}    // нет описания самой функции
    function pickCard(x: {suit: string; card: number}[]): number   // нет описания самой функции
    function pickCard(x): any {
      if(typeof x === 'object') {
        return number
      } else if(typeof x === 'number') {
        return {}
      }

    }


</div>
</details>



<details>
<summary>10. Работа с generics в TS?</summary>
<div>
  <p>Обобщённый тип (обобщение, дженерик) позволяет резервировать место для типа, который будет заменён на конкретный, переданный пользователем, при вызове функции или метода, а также при работе с классами. Рассмотрим пример:</p>

    const valueFactory = (x: number) => x
    const myValue = valueFactory(11)

    type TypeFactory<X> = x;
    type MyType = TypeFactory<string>

    // тип MyType в примере выше получит однозначное значение, в данном случае это тип string

  <p>Пример с intefrace</p>  

    interface ValueContainer<Value> {
      value: Value;
    }

    type StringContainer = ValueContainer<string> //  теперь создавая переменную с таким типом, обязательно что бы этой переменной было поле value  c типом String

    const x: StringContainer = {
      value: 'sdsd'
    }

  <p>Пример с class</p>

    class ArrayOfNumbers {
      constructor(public collection: number[]){
        this.collection = collection        //в TypeScript эту часть можно не писать, она произойдет автоматически
      }

      get(index: number): number {
        return this.collection[index]
      }
    }

    class ArrayOfString {
      constructor(public collection: string[]) {}

      get(index: number): string {
        return this.collection[index]
      }
    }

    // Создадим общий класс который может заменить два верхних по отдельности

    class ArrayOfAnything<Type> {
      constructor(public collection: Type[]){ }

      get(index: number): Type {
        return this.collection[index]
      }
    }

    new ArrayOfAnything<string>(['1','2','3sd3'])
    new ArrayOfAnything<number>([1, 2, 3])


    function fillArray<T>(len: number, elem: T): T[] {
      return new Array<T>(len).fill(elem);
    }


    const arr1 = fillArray<number>(10, 0); 
    const arr2 = fillArray<string>(10, '*');

    interface Array<T> {
      concat(...items: Array<T[] | T>): T[];    //метод concat может принимать на вход либо массив элементов Т либо массив массивом элементов Т и вернет массив элементов Т
      reduce<U>(
        callback:(state: U, element: T, index: number, array: T[]) => U,
        firstState:? U
      ): U;
    }



  <p>Создание требований для шаблона</p>
  <p>что здесь может пойти не так?</p>

      function getLength<T>(arg: T): number {
        return arg.length; 
      }

  <p>Ответ достаточно прост: компилятор ничего не знает про тип аргумента. По умолчанию, вместо обобщённого параметра можно подставить любой тип, поэтому компилятор не знает, что это за тип такой, – T и есть ли у него свойство length. Такая проблема решается на уровне разработчика с помощью ограничений. В нашем случае мы хотим ограничить принимаемое множество типов T условием: наличием свойства length. Для этого нужно создать некоторый интерфейс, где указано нужное свойство и расширить его, используя обобщённый тип T.</p>

      interface Lengthwise {
        length: number;
      }

      function printLength<T extends Lenghtwise>(arg: T): number {
        return arg.length;
      }

      printLength(1) // отработает не корректо. у числа нет длинны, синтаксис будет подсвечен. Использовать можно только типы с параметром length
      // можно передать обьект, но только тот у которого будет ключ длинны
      //  но можно передать null  и undefined, но это не правильно

  <p>В коде выше мы оповещаем компилятор о том, что на вход функции getLength могут подаваться аргументы лишь того типа, что имеют свойство length. Такая запись защитит вас от передачи в функции, например, аргумента типа number.</p>

  <p>Здесь T – это некоторый параметр-тип T, который будет захвачен при вызове функции. Конструкция <T> после имени функции указывает на то, что эта функция собирается захватить тип и подменить им все T.</p>


  <p>Создание требований к ключу. "keyof T" на выходе преобразует все ключи обьекта в union.</p>

    function getProperty<T, K extends keyof T>(obj: T, key: K ) {  //Ключ К обязательно должен присутствывать в обьекте
      return obj[key]
    }

    const myObj = {
      a: 1,
      b: 2,
      c: 3,
    }
    // K === 'a' | 'b' | 'c'


    getProperty(myObj, 'd') // TS предупредит, что так делать нельзя! Ведь ключа 'd' нет в наборе union K.  Как результат, функция будет работать с ключами только того обьекта, который был ему передан

    Объединения или union не являются собственно типом данных, но они позволяют комбинировать или объединить другие типы. Так, с помощью объединений можно определить переменную, которая может хранить значение двух или более типов.
</div>
</details>


<details>
<summary>11. Чем отличается interface от type?</summary>
<div>
  <p>Единственная дополнительная функция, которую интерфейсы привносят в таблицу (чего нет у псевдонимов типов), — это «слияние объявлений», что означает, что вы можете определять один и тот же интерфейс несколько раз, и при каждом определении свойства объединяются.</p>

    interface Point { x: number; } //declaration #1
    interface Point { y: number; } //declaration #2

    // These two declarations become:
    // interface Point { x: number; y: number; }
    const point: Point = { x: 1, y: 2 };

</div>
</details>


<details>
<summary>12. Как в TypeScript реализовать свойства класса, являющиеся константами?</summary>
<div>
  <p>В TypeScript, при объявлении свойств классов, нельзя использовать ключевое слово const. При попытке использования этого ключевого слова выводится следующее сообщение об ошибке: A class member cannot have the ‘const’ keyword. В TypeScript 2.0 имеется модификатор readonly, позволяющий создавать свойства класса, предназначенные только для чтения:</p>

    MyClass {
        readonly myReadonlyProperty = 1;

        myMethod() {
            console.log(this.myReadonlyProperty);
        }
    }

    new MyClass().myReadonlyProperty = 5; // ошибка, так как свойство предназначено только для чтения

</div>
</details>

<details>
<summary>13. Для чего нужны Omit и Pick?</summary>
<div>

  <h2>Omit</h2>
  <p>Это новый тип, в котором можно указать свойства, которые будут исключены из исходного типа.</p>

    type Person = { name: string; age: number; location: string; };
    type QuantumPerson = Omit<Person, 'location'>; // Аналогично следующей строке
    QuantumPerson = { name: string; age: number; };

  <h2>Pick</h2>
  <p>Pick помогает вам использовать уже определенный интерфейс, но брать из объекта только те ключи, которые вам нужны.</p>
</div>
</details>


<details>
<summary>14. Для чего нужен тип «Record»?</summary>
<div>
  <p>Он позволяет создавать типизированную мапу.</p>

    let Person = Record<string, number> = {};
    Person.age = 25;

</div>
</details>




<details>
<summary>15. Модификаторы доступа в TypeScript?</summary>
<div>
  <p>TypeScript предоставляет три ключевых слова для управления видимостью членов класса, таких как свойства или методы.</p>

  <ul>
    <li>public: вы можете получить доступ к общедоступному члену в любом месте за пределами класса. Все члены класса по умолчанию общедоступны.</li>
    <li>protected: защищенный член виден только подклассам класса, содержащего этот член. Внешний код, который не расширяет класс контейнера, не может получить доступ к защищенному члену.</li>
    <li>private: закрытый член виден только внутри класса. Никакой внешний код не может получить доступ к закрытым членам класса.</li>
  </ul>
</div>
</details>


<details>
<summary>16. Абстрактные классы в TypeScript?</summary>
<div>
  <p>Абстрактные классы похожи на интерфейсы тем, что они определяют контракт для объектов, и вы не можете создавать их экземпляры напрямую. Однако, в отличие от интерфейсов, абстрактный класс может предоставлять сведения о реализации для одного или нескольких своих членов.</p>

  <p>Абстрактный класс помечает один или несколько своих членов как абстрактные. Любые классы, которые расширяют абстрактный класс, должны предоставлять реализацию для абстрактных членов суперкласса.

  <p>Вот пример абстрактного класса Writer с двумя функциями-членами. Метод write() помечен как абстрактный, тогда как метод приветствия() имеет реализацию. И классы FictionWriter, и RomanceWriter, являющиеся наследниками Writer, должны предоставлять свою конкретную реализацию для метода записи.</p>

    abstract class Writer {
      abstract write(): void;

      greet(): void {
        console.log("Hello, there. I am a writer.");
      }
    }

    class FictionWriter extends Writer {
      write(): void {
        console.log("Writing a fiction.");
      }
    }

    class RomanceWriter extends Writer {
      write(): void {
        console.log("Writing a romance novel.");
      }
    }

    const john = new FictionWriter();
    john.greet();  // "Hello, there. I am a writer."
    john.write();  // "Writing a fiction."

    const mary = new RomanceWriter();
    mary.greet();  // "Hello, there. I am a writer."
    mary.write();  // "Writing a romance novel."

</div>
</details>

<details>
<summary>17. Что такое пересечение типов в TypeScript?</summary>
<div>
  <p>Типы пересечения позволяют объединять элементы двух или более типов с помощью оператора «&». Это позволяет комбинировать существующие типы, чтобы получить единый тип со всеми необходимыми функциями.</p>

  <p>В следующем примере создается новый тип Supervisor, содержащий члены типов Employee и Manager.</p>

  interface Employee {
    work: () => string;
  }

  interface Manager {
    manage: () => string;
  }

  type Supervisor = Employee & Manager;

  // john can both work and manage
  let john: Supervisor;

</div>
</details>


<details>
<summary>18. Что такое type guards в TypeScript?</summary>
<div>
  <p>Защита типа — это некоторое выражение, которое выполняет проверку во время выполнения, гарантирующую тип в некоторой области.</p>

  <p>Пример без использования type guards:</p>
  <img src="https://miro.medium.com/max/682/1*oVBS5cWU6It-y3DPA5HloA.png"/>

  <p>В примере сверху есть ошибки типов, потому что мы можем получить доступ только к членам  union которые принадлежат к обоим типам.</p>

  <p>Мы могли бы использовать приведения типо для исправления ошибок:</p>

    function makeNoise(creature: Human | Dog) {
        
        if (typeof (creature as Human).speak === 'function') {
            (creature as Human).speak();
        }
        
        if (typeof (creature as Dog).bark === 'function') {
            (creature as Dog).bark();
        }
        
    }

  <p>Но это усложнит запись кода. Для облегчения понимания кода рекомендуется использовать type guards. Есть два основных способа определения type guards:</p>

  <ul>
    <li>Используя предикаты типов</li>
    <li>Используя оператор in</li>
  </ul>

  <h3>Используем предикаты типов:</h3>
  <p>Определение функции, у которой тип возвращаемого значения  является предикатом типа, выглядит следующим образом:</p>

    function isHuman(creature: Human | Dog): creature is Human {
        return typeof (creature as Human).speak === 'function';
    }

  <p>Мы создали функцию type guard isHuman(creature), которая возвращает предикат типа created is Human. Любой предикат принимает параметр и тип. Параметр должен быть частью текущей сигнатуры функции. В нашем случае это существо.</p>

  <p>Предикат вернет true/false в зависимости от того является ли creature обьектом класса Human и имеет ли creature метод speak.</p>

  <h3>Используем in оператор:</h3>
  <p>С использованием in оператора, функция будет выглядеть следующим образом:</p>

    function isDog(creature: Human | Dog): creature is Dog {
        return 'bark' in creature;
    }

  <p>Оператор in возвращает значение true, если указанное свойство находится в указанном объекте.</p>

  <p>В нашем примере кода первое решение с использованием предикатов типов лучше, потому что мы не только проверяем, существует ли свойство в объекте, но также и является ли свойство функцией.</p>

  <p>Итоговый код будет выглядеть следующим образом.</p>

     function makeNoise(creature: Human | Dog) {
        
        if (isHuman(creature)) {
            creature.speak();
        }
        
        if (isDog(creature)) {
            creature.bark();
        }
        
    } 

  <p>Используя нашу type guard, Typescript может гарантировать, что наш параметр  creature является либо Human, либо Dog, и больше не будет показывать ошибки.</p>

  <p>Еще один пример</p>
   
    function entityIsUser(entity: Entity): entity is User {
      return !!(entity as User).name;
    }
    function entityIsProduct(entity: Entity): entity is Product {
        return !!(entity as Product).description;
    }

    function handleEntities(entities: Entity[]) {

        entities.forEach(entity => {

            if (entityIsUser(entity)) {
                handleUser(entity);
            }
            if (entityIsProduct(entity)) {
                handleProduct(entity);
            }

        });
    }
</div>
</details>


<br/>

**React**:

<details>
<summary>1. Что такое React?</summary>
<div>
  <i>Жизнь упрощается, когда компоненты пользовательского интерфейса не знают о сети, бизнес-логике или состоянии приложения. Имея одни и те же реквизиты, всегда визуализируйте одни и те же данные.</i>
  <h2>История React:</h2>
  <p>
   Когда React был впервые представлен, он коренным образом изменил работу фреймворков JavaScript. В то время как все остальные продвигали MVC, MVVM (Model-View-ViewModel) и т. д., React решил изолировать рендеринг представления от представления модели и внедрить совершенно новую архитектуру в экосистему JavaScript: Flux.
   </p>
   <h2>Чем React лучше? Какую основную проблему он решил?</h2>
   <p>
    В 2013 году Facebook потратил немало усилий на интеграцию функции чата: функция, которая будет работать и доступна через приложение, интегрируясь практически на каждой странице сайта. Это было сложное приложение внутри уже сложного приложения, и неконтролируемая мутация модели DOM, наряду с параллельным и асинхронным характером многопользовательского ввода-вывода, создавала трудности для команды Facebook.
   </p>
  
   <p>Например, как вы можете предсказать, что будет отображаться на экране, когда что угодно может захватить DOM и изменить его в любое время по любой причине, и как вы можете доказать, что то, что было отображено, было правильным?</p>

   <p>Вы не могли дать такие гарантии ни с одной из популярных интерфейсных сред до React. Условия race-DOM были одной из самых распространенных ошибок в ранних веб-приложениях.</p>

   <i>Недетерминизм = изменяемое состояние + параллельные процессы</i>

   <p>Работой номер 1 для реакта стало решение этих проблем. Сделать это удалось с помощью следующих двух ключевых инноваций.</p>

   <ul>
    <li><b>Однонаправленный поток данных</b> с помощью flux архитектуры.</li>
    <li><b>Состояние компонента иммутабельно.</b> После установки состояние компонента не может быть изменено. Изменения состояния не меняют текущее представление. Вместо этого они запускают ререндер представления уже с новым состоянием.</li>
   </ul>

   <i>«Самый простой способ, который мы нашли, концептуально, чтобы структурировать и отображать наши представления (view), — это просто попытаться полностью избежать мутаций».  — Tom Occhino, JSConfUS 2013</i>

   <p>С помощью Flux, React решил проблему неконтролируемой мутации. Вместо того, чтобы прикреплять eventlisteners  к любому произвольному количеству произвольных объектов (моделей) для запуска обновлений DOM, React представил единственный способ управления состоянием компонента: dispatch в store. Когда состояние store изменится, store запросит у компонента повторный рендеринг.</p>

   <img src="https://miro.medium.com/max/1400/1*lNLcKqywLkrHadcA-zhgBA.png" />

   <b>Одна из главных причин для того что бы использовать реакт, это детерминированный подход к рендеру представлений</b>

   <b>Это антишаблон читать данные из DOM с целью реализации доменной логики. Это противоречит цели использования React. Вместо этого считывайте данные из своего store и управляйте началом рендеринга.</b>

   <h2>Другие преимущества React:</h2>
   <h3>JSX</h3>
   <p>До появления JSX, если вы хотели написать декларативный код пользовательского интерфейса, вам приходилось использовать HTML-шаблоны, а в то время для этого не существовало хорошего стандарта. Каждый фреймворк использовал свой собственный специальный синтаксис, который вам нужно было изучить, чтобы делать такие вещи, как цикл по данным, интерполировать переменные или выполнять условное ветвление.</p>

   <p>Вы можете перебирать элементы с помощью Array.prototype.map, использовать логические операторы, пользоваться тернарным оператором, вызывать чистые функции, использовать литералы шаблонов (Шаблон строки) или вообще делать что-либо еще, что может делать выражение JavaScript. На мой взгляд, это огромное преимущество перед конкурирующими UI-фреймворками.</p>

   <h3>Synthetic events</h3>
   <p>React предоставляет оболочку для событий DOM, называемую синтетическими событиями.</p>

   <ul>
    <li>Сглаживают межплатформенные различия в обработке событий, упрощая работу кода JS в любом браузере.</li>
    <li>Автоматически управляют памятью. Если бы вы собирались создать список с бесконечной прокруткой в ​​необработанном HTML-коде JavaScript, вам нужно было бы делегировать события или перехватывать и отсоединять прослушиватели событий, когда элементы прокручиваются на экране и за его пределами, чтобы избежать утечек памяти. Синтетические события автоматически делегируются корневому узлу, что означает, что разработчики React получают управление памятью событий просто так. </li>
   </ul>
   
   
   <h3>Жизненный цикл компонента</h3>
   <p>Жизненный цикл компонента React существует для защиты состояния компонента. Состояние компонента не должно изменяться, пока React отрисовывает компонент. Вместо этого компонент переходит в известное состояние, отрисовывается, а затем открывает свой жизненный цикл для эффектов, обновлений состояния и событий.</p>

   <p>Начиная с React 0.14, React представил синтаксис класса для подключения к жизненному циклу компонентов React. У React есть два разных жизненных цикла: монтирование, обновление и размонтирование:</p>

   <img src="https://miro.medium.com/max/672/1*xRzCfozCPTWXp8wgnZrXiA.png"/>

   <p>Затем в жизненном цикле обновления есть еще три фазы:</p>

   <img src="https://miro.medium.com/max/720/1*9wk48udC9l884fOZydImiw.png"/>
   <ul>
    <li><b>Рендеринг</b> — помимо вызова хуков, ваша функция рендеринга должна быть детерминированной и не иметь побочных эффектов. Обычно вы должны думать об этом как о чистой функции от props до JSX.</li>
    <li><b>Pre-Commit</b> — здесь вы можете читать из DOM, используя метод жизненного цикла getSnapShotBeforeUpdate. Полезно, если вам нужно прочитать такие вещи, как положение прокрутки или отображаемый размер элемента перед повторным рендерингом DOM.</li>
    <li><b>Commit</b> — на этапе commit React обновляет DOM и ссылки. Вы можете подключиться к нему с помощью componentDidUpdate или хука useEffect. Здесь можно запускать эффекты, планировать обновления, использовать DOM и т. д.</li>
  </ul>

  <img src="https://miro.medium.com/max/1400/1*cEWErpe-oY-_S1dOaT1NtA.jpeg"/>

  <p>На мой взгляд, представлять компонент как  долгоживущий класс — не лучшая ментальная модель того, как работает React. Помните: состояние компонента React не предназначено для изменения. Он предназначен для замены, и каждая замена текущего состояния вызывает повторный рендеринг. Это позволяет реализовать, пожалуй, лучшую функцию React: упростить создание детерминированных view render.</p>
  
  <p>Лучшей ментальной моделью такого поведения является то, что каждый раз, когда React выполняет рендеринг, он вызывает детерминированную функцию, которая возвращает JSX. Эта функция не должна напрямую вызывать свои побочные эффекты, но может ставить эффекты в очередь для запуска React.</p>

  <b>Другими словами вам стоит думать о большинстве React компонентов как о чистых функциях от пропсов до JSX.</b>

  <h2>Итого:</h2>
  <ul>
    <li>Почему React? Детерминированное представление визуализируется благодаря однонаправленному потоку данных и неизменному состоянию компонента.</li>
    <li>JSX обеспечивает простую декларативную разметку в вашем JavaScript.</li>
    <li>Синтетические события сглаживают межплатформенные отличия в работе с событиями и уменьшают головную боль при управлении памятью.</li>
    <li>Жизненный цикл компонента существует для защиты состояния компонента. Он состоит из mount, update и unmount, а этап обновления состоит из этапов render, pre-commit и commit.</li>
    <li>Хуки React позволяют вам подключиться к жизненному циклу компонента без использования синтаксиса класса, а также упрощают обмен поведением между компонентами.</li>
    <li>Контейнеры и компоненты представления позволяют изолировать проблемы представления от состояния и эффектов, делая как ваши компоненты, так и бизнес-логику более пригодными для повторного использования и тестирования.</li>
    <li>Компоненты более высокого порядка упрощают совместное использование компонуемых поведений на многих страницах вашего приложения таким образом, что вашим компонентам не нужно знать о них (или быть тесно связанными с ними).</li>
  </ul>

  <a href="https://medium.com/javascript-scene/the-missing-introduction-to-react-62837cb2fd76">The missing introduction to React</a>
</div>
</details>

<details>
<summary>2. Основные принципы работы с React JS?</summary>
<div>
  <p>Ключевые особенности React: декларативность, универсальность, компонентный подход, виртуальный DOM, JSX. </p>


  <a>Декларативность:</a></br>
  <p>Декларати́вное программи́рование — парадигма программирования, в которой задаётся спецификация решения задачи, то есть описывается ожидаемый результат, а не способ его получения.  Декларативное программирование — это как попросить вашего друга нарисовать пейзаж. Тебе все равно, как он рисует, это зависит от него.
</p>

  <a>Универсальность:</a></br>
  <p>Одна из ключевых особенностей React — универсальность. Эту библиотеку можно использовать на сервере и на мобильных платформах с помощью React Native. Это принцип Learn Once, Write Anywhere или «Научитесь один раз, пишите где угодно».


  <a>Composition:</a><br>
  <p>
     Композиция это обьединения частей или елементов в единое целое. Композиция в React JS используется вместо наследования.<br>
     Модель композиции React: <br>
     1. Родитель может знать, а может и не знать кто будет компонентом ребенком в будущем.<br>
     2. Ребенок ни когда не знает кто родитель.<br>
     3. Ребенок ни когда не знает кто его братья и сестры.<br>
     4. Отношения между компонентами проиходят через всем понятный интерфейс (ПРОПСЫ).<br>

  </p>

</div>
</details>

<details>
<summary>3. Что такое JSX(Javascript Syntax Expression)?</summary>
<div>
  *JSX* (JavaScript и XML) - это XML-подобный синтаксис, расширяющий возможности ECMAScript. По сути, он является синтаксическим сахаром для функции `React.createElement()`, совмещая выразительность JavaScript с HTML-подобным синтаксисом разметки. За парсинг и отработку отвечает babel.
  JSX- выражение, это означает, что вы можете использовать JSX внутри операторов if и for, присваивать его переменным, принимать его в качесиве аргументов и возвращать из функций:
   <p> В приведенном ниже примере, текст внутри тега `h1` в методе `render()` возвращается в виде JavaScript-функции: </p>

    
    class App extends React.Component {
      render() {
        return (
             <h1 className="greeting">
               Привет, мир!
             </h1>
          </div>
        )
      }
    }
  
    const element = React.createElement(
    'h1',
    {className: 'greeting'},
    'Привет, мир!'
    );

    
</div>
</details>

<details>
<summary>4.  Что такое Lifting State Up (поднятие) в React??</summary>
<div>
 <p>Часто несколько компонентов должны отражать одни и те же изменяющиеся данные. Мы рекомендуем поднимать общее состояние до ближайшего общего предка. </p>
 <img src="https://res.cloudinary.com/practicaldev/image/fetch/s--vrgvZSMl--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://aviyel.com/assets/uploads/files/1636976926667-image.png" />
</div>
</details>

<details>
<summary>5. Что такое props в React?</summary>
<div>
  <p>
  *Props* - это входные данные для компонента. Это простые значения (примитивы) или объект, содержащий несколько значений, которые передаются компонентам при их создании с помощью синтаксиса, похожего на атрибуты HTML-тегов.

  <p>Основное назначение пропов в React заключается в предоставлении компоненту следующего функционала:</p>

  <p>1. Передача данных компоненту</p>
  <p>2. Вызов изменения состояния</p>
    Создадим элемент со свойством `reactProp`:
  <p>

      <Element reactProp={'1'} />
  </p>
    Этот `reactProp` добавляется в качестве свойства ко встроенному объекту *props*, который присутствет во всех компонентах, созданных с помощью React.
  <p>

     props.reactProp
  </p>  
  </p>
</div>
</details>


<details>
<summary>6. Как работает виртуальный DOM?</summary>
<div>
  
  <img src="https://api.bcode.dev/v1/content/storage/post/100004/a36995c00227434eb59af3dfd8f246c5.png"/>

  <p>🔸 В React каждый пользовательский интерфейс — это отдельный компонент, и у каждого компонента есть свое состояние.</p>
  <p>🔸 React следует observable pattern и наблюдает за изменениями состояний.</p>
  <p>🔸 Всякий раз, когда в состояние какого-либо компонента вносится изменение, React обновляет виртуальное дерево DOM, но не изменяет реальное дерево DOM.</p>
  <p>🔸 После обновления React сравнивает текущую версию виртуального DOM с предыдущей версией.</p>
  <p>🔸 React знает, какие объекты изменяются внутри виртуальном DOM, основываясь на том, что он изменяет только эти объекты в реальном DOM, совершая минимальные манипуляционные операции.</p>
  <p>🔸 Этот процесс отмечен как "diffing". Изображение ниже прояснит концепцию больше.</p>

  <img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/12a/500/0c2/12a5000c239d0c3eb96cd4848e7221a1.jpg"/>

  <a>Эффективный diff алгоритм:</a> 
  <p>Для дерева с числом элементов «n» сложность порядка O(n3). React реализует оптимизированный алгоритм O(n) на основе двух предположений:</p>

   1. Элементы разных типов будут создавать разные деревья. 

  <p>React анализирует дерево с помощью поиска в ширину (Breadth-first search - один из методов обхода графа). Для узла дерева, если тип элемента изменен, например, с «section» на «div». React уничтожит все поддерево под этим элементом и восстановит его с нуля.</p>

   1. Разработчик указывает с помощью ключа (key prop), на то какие элементы должны быть стабильны в разных рендерах.

  <p>React будет использовать этот ключ для сопоставления элементов между двумя деревьями и минимизации ненужных мутаций.</p>

</div>
</details>


<details>
<summary>7. Что такое React Fibers?</summary>
<div>
  <p>Fiber - это новый механизм согласования или повторной реализации основного алгоритма в React v16. Цель React Fiber -  увеличении производительности при разработке таких задач как анимация, организация элементов на странице и движение элементов. Ее главная особенность это инкрементный рендеринг: способность разделять работу рендера на единицы и распределять их между множественными фреймами.
</div>
</details>


<details>
<summary>8. Согласование в React?</summary>
<div>
  <p>Каждый раз, когда происходит изменение в состоянии компонента, запускается механизм, именуемый "согласование" (reconciliation), который вычисляет разницу (дифф) между прошлым состоянием и новым. С алгоритмической точки зрения происходит поиск отличий в двух деревьях. В общем случае алгоритм, выполняющий это вычисление, работает со сложностью O(n3).</p>
  <img src="https://api.bcode.dev/v1/content/storage/post/100004/a36995c00227434eb59af3dfd8f246c5.png"/>
</div>
</details>


<details>
<summary>9. В чем разница между теневым (Shadow) и виртуальным DOM?</summary>
<div>
  <p>*Shadow DOM* - это браузерная технология, спроектированная для ограничения области видимости переменных и CSS в *веб-компонентах*. Используется для инкапсуляции.</p>
</div>
</details>

<details>
<summary>10. В чем разница между настоящим и виртуальным DOM?</summary>
<div>
Ниже представлены основные отличие между реальным и виртуальным DOM:

| Реальный DOM | Виртуальный DOM |
| ----- | ------- |
| Обновления медленные | Обновления быстрые |
| Манипуляции с DOM очень дорогостоящие | Манипуляции с DOM не очень дорогие |
| Вы можете обновлять HTML напрямую | Вы не можете обновлять HTML напрямую |
| Активная работа с DOM часто приводит к утечкам памяти | Утечки памяти практически полностью исключены |
| При обновлении элемента создается новая DOM | При изменении элемента обновляется только JSX |
</div>
</details>

<details>
<summary>11. Что такое фрагмент (Fragment)?</summary>
<div>
  <p>
  Это распространенный паттерн в React, который используется в компонентах, возвращающих несколько элементов. *Fragments* позволяют группировать дочерние элементы без создания лишних DOM-узлов:</p>
  <p>

    render() {
      return (
        <React.Fragment>
          <ChildA />
          <ChildB />
          <ChildC />
        </React.Fragment>
      )
    }
  </p>

  <p>Также существует *сокращенный синтаксис*, но он не поддерживается в некоторых инструментах:</p>
  <p>

    render() {
      return (
        <>
          <ChildA />
          <ChildB />
          <ChildC />
        </>
      )
    }
  </p>

  <p>1. Фрагменты немного быстрее и используют меньше памяти. Реальная польза от этого ощущается в очень больших и глубоких деревьях элементов</p>
  <p>2. Некоторые механизмы CSS, например, *Flexbox* и *Grid* используют связь родитель-ребенок (предок-потомок, если угодно), поэтому добавление дополнительных `div` может сломать макет страницы.</p>
  <p>3. Удобнее пользоваться инспектором DOM</p>
  </p>
</div>
</details>



<details>
<summary>12. Что такое `React.memo()`?</summary>
<div>
  <a>Определение React.memo:</a>
  <p>Когда компонент заключен в React.memo(), React рендерит компонент и запоминает результат. Перед следующим рендерингом, если новые пропсы одинаковы, React повторно использует memoизированный результат, пропуская следующий рендеринг.</p>

  <p>React всегда перерисовывает компонент при изменении состояния, даже если компонент обернут в React.memo(). </p>

  ```jsx
  export function Movie({ title, releaseDate }) {
    return (
      <div>
        <div>Movie title: {title}</div>
        <div>Release date: {releaseDate}</div>
      </div>
    );
  }
  export const MemoizedMovie = React.memo(Movie);
  ```

<p>Похожий функционал предоставляет хук `useMemo()`.</p>

<a>Использование кастомного сравнения props:</a>
<p>По-умолчанию мемо делает поверхностное сравнение props. Функцию для кастомного сравнения можно передать вторым параметром:</p>

```jsx
React.memo(Component, [areEqual(prevProps, nextProps)]);
```

<p>Функция areEqual должна вернуть true если пропсы равны.</p>

<a>Когда использовать memo:</a>
<img src="https://dmitripavlutin.com/static/c07d2ce4ede6301197b9605a75ae9b4e/47a22/when-to-use-react-memo-infographic.webp" />
</div>
</details>


<!-- <details>
<summary>13. Какие преимущества предоставляет использование React?</summary>
<div>
  <p>Удобная работа с DOM.  </p>
    <p>Virtual DOM - это древовидная структура JavaScript простых обьектов которая синхронизуется в памяти. Использовать Virtual DOM быстрее потому что он никогда не рендериться для пользователя, он остается только в памяти.   </p>
    <p>Когда приложение React грузится, React создает копию реального DOM дерева. Когда изменяется state вместо того что бы перерисовывать все реально DOM дерево, React сначала обновляет virtual DOM с обновленным state.  </p>
    <p>Потом React сравнивает Virtual DOM vs Real DOM для того что бы узнать что именно должно быть обновлено. После этого только изменяется Real DOM. Только те элементы которые притерпели изменения.  </p>
  </p>
<p>JSX</p>
  <p>JSX используется препроцессорами (например Babel). Для трансформации HTML-like текста в JS файлы в JS обьекты которы будут распрешены.</p>
<p>Components</p>
<p>React components нужны для того что бы сделать код легко переиспользуемым. И разделить весь UI на мелкие и разные части.  </p>
<p>React components работают идентично JS функциям. Они имеют доступ к произвольным входным данным **props**. И должны возвращать элемент описывающий то что мы будет показывать пользователю.</p>

</div>
</details> -->


<details>
<summary>13. Как реализовать рендеринг на стороне сервера или SSR?</summary>
<div>
  <p>React поддерживает рендеринг на стороне Node-сервера из коробки. Для этого используется специальная версия DOM-рендерера, которая реализует такой же паттерн, что и клиентская версия:</p>

   
    import ReactDOMServer from 'react-dom/server'
    import App from './App'

    ReactDOMServer.renderToString(<App />)
    

  <p>Этот метод возвращает обычный HTML в виде строки, которая затем может быть помещена в тело (body) ответа сервера. На стороне клиента React определяет предварительно отрендеренный контент и просто вставляет его в существующее дерево компонентов.
  </p>
</div>
</details>


<details>
<summary>14. Какие методы жизненного цикла компонента существуют в React?</summary>
<div>
<img src='https://cdn-images-1.medium.com/max/1600/1*cPwvUhZrnB1dtZnjBEfXfA.png' />
  <ul>
    <li>
      <b>constructor()</b> - Конструктор компонента React вызывается до того, как компонент будет примонтирован. В начале конструктора необходимо вызывать super(props). Если это не сделать, this.props не будет определён. 
      <br>
      Конструкторы в React обычно используют для двух целей: Инициализация внутреннего состояния через присвоение объекта this.state. Привязка обработчиков событий к экземпляру.
      <br>
      <b>useState</b> - заменяет конструктор. Служит для управление локальным state у компонента.
    </li>
    <br/>
    <li>
      <b>componentDidMount()</b> - вызывается сразу после монтирования. В этом методе должны происходить действия, которые требуют наличия DOM-узлов. Это хорошее место для создания сетевых запросов.
      <br/>
      Этот метод подходит для настройки подписок. Но не забудьте отписаться от них в componentWillUnmount().
      <br/>
      <b>useEffect(callBack, [])</b> - Инициализируется немедленно после первого рендера, инициализирует state которому могут понадобиться DOM ноды, Network запросы и другие side effects.
    </li>
    <br/>
    <li>
      <b>componentDidUpdate(prevProps, prevState, snapshot)</b> - вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если пропсы не изменились, новый запрос может и не требоваться.
      <br>
      <p>

        const mounted = useRef()
        useEffect(() => {
          if(!mounted.current) {
            mounted.current = true
          } else {
            console.log('componentDidUpdate !)
          }

        })

   </p>
    <b>useEffect(callBack)</b> - вызывается и при первом рендере и после обновления. Для эмуляции componentDidUpdate нужна проверка на первый рендер и useRef.
    </li>
    <br/>
    <li>
      <b>componentWillUnmount()</b> - вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().
    </li>
    <br/>
      <b>useEffect(callBack)</b> - return функция. Возвращает функцию которая будет запущена после unmount'a компоненты. Подходит для отмены таймеров, сетевых запросов и подписок.
    <br/>
    <li>
      <b>useRef</b> - предоставляет доступ к DOM елементам созданным при рендере, помогает useEffect симитировать работу componentDidUpdate.
       <p>useRef() - это хук принимающий в качестве аргумента какое то значение и возвращающий референс. Референс это специальный обьект у которого есть свойство current.</p>
       reference.current - предоставляет доступ к значению, reference.current = newValue обновляет значение.<br/>
       1. Значение референса остается не изменным между ререндерами. <br/>
       2. Обновление референса не вызывает ререндер. <br/>
    </li>
    <br/>
    <li>
      <b>useMemo()</b> - сохраняет результат полученной функции между ререндерами и не перезапускает ее до тех пор пока не изменятся зависимости.
       <p>useMemo(compute, dependencies)</b> - принимает на вход два параметра. Compute - функия результат которой надо запомнить. Dependencies - зависимости без изменения которых не будет перезапущена функция compute.</p>
       Если сравнивать useMemo и useCallback то useCallback более специфическая функция для запоминания callback, но useMemo тоже умеет запоминать callback.<br/>
    </li>
    <br/>
    <li>
      <b>useCallback()</b> - при не изменяющемся deps, хук вернет тот же самый instance функции между ререндерами.
       <p>useCallback(callbackFnc, deps)</b> - принимает на вход два параметра. CallbackFnc - функия incstance которой надо запомнить. Deps - зависимости без изменения которых instance функции останется тем же самым.</p>
       Кейсы использования useCallback():<br/>
       <p>1. Функциональная компонента обернута React.memo() и принимает функцию как аргумент.</p>
       <p>2. Когда функция является зависимостью для других hooks, useEffect(..., [callback)]</p>
       <p>3. Когда у функции есть внутреннее состояние, когда функция debounced или throttled.</p>
    </li>
    <br/>
  </ul>
  
  <img src='https://res.cloudinary.com/practicaldev/image/fetch/s--S1NFg-EJ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://miro.medium.com/max/800/1%2AJ1OWWbEDit18yTrM0sthgA.png'/>
  <img src ='https://res.cloudinary.com/practicaldev/image/fetch/s--HiDZKzEO--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://miro.medium.com/max/1000/1%2A2ANppcgcNvccNSsS8fHbnQ.png'/>
</div>
</details>

<details>
<summary>15. Что такое Context в React и для чего он используется?</summary>
<div>
  <br />
  <p>Контекст разработан для передачи данных, которые можно назвать «глобальными» для всего дерева React-компонентов (например, текущий аутентифицированный пользователь, UI-тема или выбранный язык).</p>
  <p>Контекст позволяет избежать передачи пропсов в промежуточные компоненты: 
    
    // Контекст позволяет передавать значение глубоко
    // в дерево компонентов без явной передачи пропсов
    // на каждом уровне. Создадим контекст для текущей
    // UI-темы (со значением "light" по умолчанию).
    const ThemeContext = React.createContext('light');

    class App extends React.Component {
      render() {
        // Компонент Provider используется для передачи текущей
        // UI-темы вниз по дереву. Любой компонент может использовать
        // этот контекст и не важно, как глубоко он находится.
        // В этом примере мы передаём "dark" в качестве значения контекста.
        return (
          <ThemeContext.Provider value="dark">
            <Toolbar />
          </ThemeContext.Provider>
        );
      }
    }

    // Компонент, который находится в середине,
    // теперь не должен явно передавать UI-тему вниз.
    function Toolbar(props) {
      return (
        <div>
          <ThemedButton />
        </div>
      );
    }

    class ThemedButton extends React.Component {
      // Определяем contextType, чтобы получить значение контекста.
      // React найдёт (выше по дереву) ближайший Provider-компонент,
      // предоставляющий этот контекст, и использует его значение.
      // В этом примере значение UI-темы будет "dark".
      static contextType = ThemeContext;
      render() {
        return <Button theme={this.context} />;
      }
    }
  </p>
  <p>Обычно контекст используется, если необходимо обеспечить доступ данных во многих компонентах на разных уровнях вложенности. По возможности не используйте его, так как это усложняет переиспользование компонентов.</p>
</div>
</details>



<details>
<summary>16. Для чего нужен атрибут key при рендере списков?</summary>
<div>
  <br />
  <p>
    Ключи (keys) помогают React определять, какие элементы были изменены, добавлены или удалены. Их необходимо указывать, чтобы React мог сопоставлять элементы массива с течением времени.
  </p>
  <p>
    Лучший способ выбрать ключ — это использовать строку, которая будет явно отличать элемент списка от его соседей. Чаще всего вы будете использовать ID из ваших данных как ключи. Главное что бы ключи были уникальные и не смещались.</p>
    <p>Чаще всего с этой задачей не возникает проблем, так как у любой сущности, с которой мы работаем, есть свой идентификатор (например, primary key из базы данных).
    Так же можно использовать UUID. </p>
    <p>Кстати, key не обрабатывается как обычный проп и его нельзя получить внутри компонента как this.props.key. Если вам нужны данные, которые были переданы в key внутри компонента, то просто передайте их отдельным пропом (например, id):
  </p>
  
</div>
</details>

<details>
<summary>17. Как работает проп children?</summary>
<div>
  <br />
  <p>
    Некоторые компоненты не знают своих потомков заранее. Это особенно характерно для таких компонентов, как Sidebar или Dialog, которые представляют из себя как бы «коробку», в которую можно что-то положить. Для таких компонентов мы рекомендуем использовать специальный проп children, который передаст дочерние элементы сразу на вывод:
    
    function FancyBorder(props) {
      return (
        <div className={'FancyBorder FancyBorder-' + props.color}>
          {props.children}
        </div>
      );
    }
  </p>
    <p>Если внимательно посмотреть на документацию React, то можно увидеть следующее определение children: "children are an opaque data structure" (свойство children – непрозрачная структура данных). Другими словами, нельзя однозначно полагаться на тип этого пропса, так как снаружи можно передать всё что угодно. Подобное поведение может приводить к трудноотловимым ошибкам. Например проверка this.props.children.length это не всегда количество детей. Если children это одиночный элемент, например строка, то свойство length вернет длину этой строки.
  </p>
  <p>
    Это позволит передать компоненту произвольные дочерние элементы, вложив их в JSX:
  
    function WelcomeDialog() {
      return (
        <FancyBorder color="blue">
          <h1 className="Dialog-title">
            Добро пожаловать
          </h1>
          <p className="Dialog-message">
            Спасибо, что посетили наш космический корабль!
          </p>
        </FancyBorder>
      );
    }
  </p>
  <p>
    Всё, что находится внутри JSX-тега <FancyBorder>, передаётся в компонент FancyBorder через проп children. Поскольку FancyBorder рендерит {props.children} внутри div, все переданные элементы отображаются в конечном выводе.
  </p>
</div>
</details>


<details>
<summary>18. В чем разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?</summary>
<div>
  <br />
  <p> В HTML элементы формы, такие как input, textarea и select, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные. В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState().
  </p>
  <p>
    В управляемом компоненте с каждой мутацией состояния связана функция-обработчик. Благодаря этому валидация или изменение введённого значения становится простой задачей. Например, если мы хотим, чтобы имя обязательно было набрано заглавными буквами, можно написать такой handleChange:
    
    handleChange(event) {
      this.setState({value: event.target.value.toUpperCase()});
    }
  </p>
  <p>
    Вместо того, чтобы писать обработчик события для каждого обновления состояния, вы можете использовать неуправляемый компонент и читать значения из DOM через реф.
  
    class NameForm extends React.Component {
      constructor(props) {
        super(props);
        this.handleSubmit = this.handleSubmit.bind(this);
        this.input = React.createRef();
      }

      handleSubmit(event) {
        alert('Отправленное имя: ' + this.input.current.value);
        event.preventDefault();
      }

      render() {
        return (
          <form onSubmit={this.handleSubmit}>
            <label>
              Имя:
              <input type="text" ref={this.input} />
            </label>
            <input type="submit" value="Отправить" />
          </form>
        );
      }
    }
  </p>
  <p>
    Неуправляемые компоненты опираются на DOM в качестве источника данных и могут быть удобны при интеграции React с кодом, не связанным с React. Количество кода может уменьшиться, правда, за счёт потери в его чистоте. Поэтому в обычных ситуациях мы рекомендуем использовать управляемые компоненты.
  </p>
  <p>Настройка контролируемого input включает в себя 3 шага: </p>
    1. Создать стейт для хранения значения input: 
    <p>

      [val, setVal] = useState('') 
   </p>
    1. Определить event handler для обновления state когда пользователь вводит данные в input 
    <p> 

      onChange = event => setVal(event.target.value)
   </p>    
    1. Присоединить eventHandler и установить значение аттрибута value на input field: 
    <p>

      <input onChange={onChange} value={val} />.
   </p>
    Debouncing значения input'a в state требует создания нового разделенного состояния с использованием hook'a useDebouncedValue(value, wait):
    <p>  
    
     debouncedQuery = useDebouncedValue(value, wait). 
   </p>
</div>
</details>

<details>
<summary>19. Что такое PureComponent?</summary>
<div>
  <br />
  <p>
    React.PureComponent похож на React.Component. Отличие заключается в том, что React.Component не реализует shouldComponentUpdate(), а React.PureComponent реализует его поверхностным сравнением пропсов и состояния.
  </p>
  <p>
    Если метод render() вашего React-компонента всегда рендерит одинаковый результат при одних и тех же пропсах и состояниях, для повышения производительности в некоторых случаях вы можете использовать React.PureComponent.
  </p>
  <p>
    Метод shouldComponentUpdate() базового класса React.PureComponent делает только поверхностное сравнение объектов. Если они содержат сложные структуры данных, это может привести к неправильной работе для более глубоких различий (то есть, различий, не выраженных на поверхности структуры). Наследуйте класс PureComponent только тогда, когда вы ожидаете использовать простые пропсы и состояние
  </p>
  <p></p>
</div>
</details>

<details>
<summary>20. Что такое state в React?</summary>
<div>
  <br />
  <p>
   State это JavaScript объект, который хранит динамические данные компонента и позволяет компоненту отслеживать изменения между рендерами(render).
  </p>
  <p>
    Ещё раз: крайне важно не изменять state напрямую. Для установки нового состояния в React предусмотрена функция setState. 
    setState() планирует обновления объекта состояния компонента. Когда состояние изменяется, компонент отвечает повторным рендерингом.
     Вызовы setState является асинхронными, когда они находятся внутри обработчиков событий, и когда вы не полагаетесь на this.state, чтобы отобразить новое значение сразу после вызова setState.
  </p>
  <p>
   Общая рекомендация, которую дают разработчики React, это делать структуру максимально плоской, похожей на то, как хранятся данные в базе данных. Причём желательно в хорошо нормализованном виде. Другими словами, не нужно дублировать данные в состоянии. 
  </p>
</div>
</details>

<details>
<summary>21. События в React?</summary>
<div>
  <br />
  <p>
   В любой обработчик события при вызове передаётся объект типа SyntheticEvent, кроссбраузерный "враппер" (обёртка) над нативным объектом события. Интерфейсно он не отличается от нативного, кроме того, что работает одинаково во всех браузерах.

      class Component extends React.Component {
        onClick = (event) => {
          console.log(event); // => SyntheticBaseEvent
          console.log(event.type); // => "click"
        }

        // ...
      }
  </p>
  <p>
    SyntheticEvent хранит в себе оригинальный объект события и предоставляет интерфейс для доступа к его свойствам и методам. Этот интерфейс одинаков для всех браузеров, что крайне удобно с точки зрения разработки. К примеру, необходимо отменить действие по умолчанию (перезагрузку страницы) при отправке формы:

        handleSubmit = (e) => {
          e.preventDefault();
          this.setState({ count: this.state.count + 1 });
        };
  </p>
  <p>
   Точно так же нужно поступать при необходимости предотвратить всплытие события. Только вместо preventDefault вызывается функция stopPropagation.
  </p>
  <p>
    React нормализует события так, что они имеют консистентные свойства в различных браузерах. Кроме того, в формах добавляется событие onChange, которое ведёт себя в соответствии со своим названием и сильно упрощает работу.  
  </p>
  <p><a>stopPropagation</a> предотвращает дальнейшее распространение текущего события на этапах захвата и всплытия.

  <a>preventDefault</a> предотвращает действие браузера по умолчанию для этого события.
  </p>
</div>
</details>

<details>
<summary>22. Что такое Компонент высшего порядка (Higher-Order Component, HOC)?</summary>
<div>
  <br />
  <p>
    Компонент высшего порядка — это функция, которая принимает компонент и возвращает новый компонент. React Higher Order Component — это паттерн, который проистекает из природы React, которая отдает предпочтение композиции, а не наследованию. HOC часто встречаются в сторонних библиотеках, например connect в Redux и createFragmentContainer в Relay.
    
    HOC — это чистая функция с нулевыми побочными эффектами.
    Помогает для Воспроизведения DRY. Прим. memo.
    const EnhancedComponent = higherOrderComponent(WrappedComponent);
  </p>
  <p>
    Заметьте, что HOC ничего не меняет и не наследует поведение оборачиваемого компонента, вместо этого HOC оборачивает оригинальный компонент в контейнер посредством композиции. HOC является чистой функцией без побочных эффектов.  Оборачиваемый компонент получает все пропсы, переданные контейнеру, а также проп data. Для HOC не важно, как будут использоваться данные, а оборачиваемому компоненту не важно, откуда они берутся.
  </p>

  <h2>Для чего нужны HOC?</h2>

  <p>1. Обеспечения возможности переиспользования кода, логики, а так же начальная загрузка</p>
  <p>2. Перехват рендеринга (RenderHighjacking)</p>
  <p>3. Абстрагирования и манипулирования состоянием</p>
  <p>4. Манипулирования пропами</p>


  <a>Примеры использования: </a>
  <p>1. Для отображения лоадера пока компонент ждет данные. Отслеживает props и пока они пусты будет показывать значек загрузки.</p>
  <p>2. Компоненты которые рендерятся по условию. Когда их props достигают определенных значений.</p>
</div>
</details>

<details>
<summary>23. Хук useState?</summary>
<div>
  <br />
  <p>
    Хук состояния - useState. ASYNC.
    Возвращает массив где первой значение это начальное значение стейт, а второе функция сеттер.
  </p>
  <p>
    Говорит реакту запустить следующую итерацию рендера. Однако реакт так же может оптимизировать процесс. Несколько вызовов useState приведут к одному рендеру.
  </p>
  <br />

      ​ // Toggle a boolean
      ​ const [toggled, setToggled] = useState(false);
    ​   setToggled(toggled => !toggled);
  <p>
    Ленивая инициализация state:
    Каждый раз при ре-рендере компонента реакт запускает useState(initialState). Когда туда передается примитивный тип данных проблем не возникает. Когда initialState требует тяжелых вычислительных операций выгодно передавать в useState саму функцию. 
  </p>

    function MyComponent({ bigJsonData }) {
      const [value, setValue] = useState(function getInitialState() {
        const object = JSON.parse(bigJsonData); // expensive operation
        return object.initialValue;
      });
      // ...
    }
  <p>getInitialState() выполняется только один раз при начальном рендеринге, чтобы получить начальное состояние.

  При более последующих ререндерах компонента getInitialState() не вызывается, пропуская дорогостоящую операцию.</p>

</div>
</details>


<details>
<summary>24. Хук useEffect?</summary>
<div>
  <br />
  <p>
    Для выполнения побочных эффектов, например, прямой работы с DOM в React используется встроенный хук useEffect(). Он заменяет собой три колбека жизненного цикла:
  </p>
      •	componentDidMount()
      •	componentDidUpdate()
      •	componentWillUnmount()

  <br />
  <p>
    Колбек, переданный в useEffect(), отрабатывает после того как изменения будут запущены в дом (Асинхронно). То есть произошло объединение методов componentDidUpdate() и componentDidMount(). Такое изменение было сделано ради удобства. Мировая практика использования React показала, что, в основном, эффекты происходят после каждого рендера, независимо от того, первая эта отрисовка или все последующие.
  </p>
  <p>
    Второй параметр передаваемый в useEffect это массив. Отсуствующий массив - useEffect запускается после каждого ререндера, пустой массив [] - useEffect запускается единождый после инициализирующего рендера,  Массив с зависимостями [state/props] - useEffect запускается при изменении значений переданных в массив state/props.
  </p>

  <p>
      Сброс эффекта:</p>
    <p>В некоторых случаях эффект нужно сбрасывать. Например, когда эффект после изменения пропсов перестает быть актуальным, его нужно "зачистить". Для этого достаточно вернуть функцию из useEffect(), внутри которой выполняется очистка:
  </p>

     // Предположим, что этот эффект зависит от пропса userId
     useEffect(() => {
     const id = setTimeout(/* какой-то код с userId */);

     return () => clearTimeout(id);
    }, [userId]);
</div>
</details>


<details>
<summary>25. Хук ref?</summary>
<div>
  <p>
   useRef() – хранение любых данных между вызовами компонента. Этот хук возвращает обычный объект со свойством current внутри. Единственное отличие этого объекта, от создаваемого вручную { current: ... }, в том, что хук возвращает один и тот же объект при каждом вызове компонента. По своему поведению useRef() похож на использование обычного свойства внутри классового компонента (this.someproperty).
  </p>
</div>
</details>


<details>
<summary>26. Хук useMemo?</summary>
<div>
  <p>
    Встроенный в реакт хук, который запоминает результат выполнения функции. На вход принимается сама  функция и массив ее зависимостей. Во время иницилизирующего рендера хук запоминает результат выполнения функции. Если во время следующих ререндеров зависимости не изменяются useMemo не запустит функцию, но вернет ее результат.
  </p>

      const memoizedResult = useMemo(compute, dependencies);
  <p>
    Но если зависимости изменились useMemo запустит функцию и сохранит ее результат.
    Если callback использует state или props нужно не забыть указать их как зависимости.
  </p>

      const memoizedResult = useMemo(() => {
        return expensiveFunction(propA, propB);
      } , [propA, propB]);

  <p>
    useCallback по сравнению с useMemo более специализированный хук для сохранения callbacks.  useMemo может заменить useCallback:
  </p>

    const callback = () => {
      return 'Result';
    };
    const memoizedCallback = useMemo(() => callback, [prop]);

  <p>Просто обернув callback  в стрелочную функцию.</p>
</div>
</details>


<details>
<summary>27. Хук useCallback?</summary>
<div>
  <p>
   useCallback возвращает один и тот же экземпляр передаваемой функции (параметр 1) вместо создания нового при каждом повторном рендеринге компонента. Новый экземпляр передаваемой функции (параметр 1) может быть создан только при изменении массива зависимостей (параметр 2).
  </p>

      function MyComponent() {
        // handleClick is the same function object
        const handleClick = useCallback(() => {
        console.log('Clicked!');
      }, []);

      // ...
      }
</div>
</details>

<details>
<summary>28. Разница useCallback vs useMemo?</summary>
<div>
  <p>
   useCallback(fn, deps)` это просто `useMemo(() => fn, deps)`
  </p>

  <p>Когда компонент собирается повторно визуализироваться, React сравнивает каждый созданный под его исходным компонентом объект с новой версией этого объекта. И хотя объекты точно такие же, они не указывают на один и тот же объект. React идентифицирует их как разные объекты, позволяя воссоздавать снова и снова при каждом повторном рендеринге.</p>

  <h2>Для чего нужны useCallback и useMemo?</h2>

  <p>Если useCallback и useMemo используются правильно, они необходимы, чтобы предотвратить повторные рендеры и сделать код более эффективным.</p>

  <p>useMemo используется вместо того, чтобы возвращать невызванную функцию, как это делает useCallback – он работает с передаваемой функцией и возвращает результирующее значение только при изменении массива параметров. Другими словами, useMemo вызывает функцию только при необходимости и возвращает кэшированное значение для других визуализаций.</p>

  <p>Когда компонент повторно визуализируется, он создает новые экземпляры всех объектов, включая все функции в нем:

  useCallback – кэширует экземпляр функции между визуализациями.
  useMemo – кэширует значение между визуализациями.</p>



</div>
</details>


<details>
<summary>29. Расскажите про хуки и их ценность в React JS?</summary>
<div>
<p>Вызов Хука обычно приводит к побочным эффектам — эффектам, которые позволяют вашему компоненту подключаться к таким вещам, как состояние компонента и ввод-вывод. Побочный эффект — это любое изменение состояния, наблюдаемое вне функции, кроме возвращаемого функцией значения.</p>

<p>useEffect позволяет ставить эффекты в очередь для запуска в соответствующее время жизненного цикла компонента, что может быть сразу после монтирования компонента (например, componentDidMount), во время фазы фиксации (например, componentDidUpdate) или непосредственно перед размонтированием компонента (например, componentWillUnmount).</p>

<p>Хуки позволяют вам:</p>

<ul>
  <li>Пишите свои компоненты как функции, а не классы.</li>
  <li>Организуйте свой код лучше.</li>
  <li>Разделяйте многократно используемую логику между различными компонентами</li>
  <li>Составьте хуки, чтобы создать свои собственные пользовательские хуки (вызов хука из другого хука).</li>
</ul>


<p>Вообще говоря, вы должны отдавать предпочтение функциональным компонентам и хукам React, а не компонентам на основе классов. Обычно они содержат меньше кода, лучше организованы, более удобочитаемы, более пригодны для повторного использования и более проверяемы.</p>


<h2>Правила использования Хуков:</h2>

<p>1. Хуки не должны вызываться внутри циклов, условий или вложенных функций. Это позволяет обеспечить одинаковый порядок вызова хуков при повторном рендеринге и сохранять состояние хуков между несколькими вызовами `useState()` и `useEffect()`</p>
<p>2. Хуки можно вызывать только внутри функциональных компонентов React и других хуков, вы не должны вызывать их внутри обычных функций</p>

</div>
</details>

<details>
<summary>30. Что такое порталы в React?</summary>
<div>
  <br />
  <p>
    Порталы позволяют рендерить дочерние элементы в DOM-узел, который находится вне DOM-иерархии родительского компонента.

    ReactDOM.createPortal(child, container)
  </p>
  <p>
    Первый аргумент (child) — это любой React-компонент, который может быть отрендерен, такой как элемент, строка или фрагмент. Следующий аргумент (container) — это DOM-элемент.
  </p>
  <p>
    Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.
  </p>
  <p><i>Источник: <a href ="https://ru.reactjs.org/docs/portals.html">ru.reactjs.org</a></i></p>
</div>
</details>

<details>
<summary>31. Что такое debounce и throttle?</summary>
<div>
  <br />
  <p>Это две похожие но разные техники контроля за тем сколько раз будет вызвана функция за определенное время.
  </p>
  <p>
  Debounce - возвращает функцию которая может быть вызвана любое количество раз, но будет вызвана только после N ms после вызова идущей перед ней функции.
  </p>
  <p>
  Throttle - возвращает функцию которая может быть вызвана любое количество раз, но будет вызывать callback не чаще одного раза в N ms.
  </p>
  <p>Use case: Поиск города в огромном массиве из всех городов по мере ввода названия города. Каждый поиск является тяжеловестным, что влечет за собой зависания.
  Это означает, что в нашем фильтре городов мы не сможем попросить наш компьютер отфильтровать города с буквами «Sa», пока он все еще пытается сделать то же самое для городов с буквой «S» в названии. Нам придется либо предотвратить второй процесс, либо остановить первый, а затем запустить второй.</p>
</div>
</details>

<details>
<summary>32. Что такое React Reconciliation (Cверка) и как он работает?</summary>
<div>
  <br />
  <p>
    Reconciliation (Cверка) - это процесс, посредством которого React обновляет DOM. В этот процесс входит и Virtual DOM и Diffing алгоритм. Когда состояние компонента изменяется, React должен рассчитать необходимость обновления DOM. Это делается путем создания виртуального DOM и сравнения его с текущим DOM. В этом контексте виртуальный DOM будет содержать новое состояние компонента.
  </p>
  <p>
    При сравнении двух деревьев первым делом React сравнивает два корневых элемента. Поведение различается в зависимости от типов корневых элементов. 
  </p>
  <p>
    Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля. 
  </p>
  <p>
    При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих элементов DOM-узел и обновляет только изменённые атрибуты.
  </p>
  <p>
    По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React проходит по обоим спискам потомков одновременно и создаёт мутацию, когда находит отличие. Эта неэффективность может стать проблемой. Когда у дочерних элементов есть ключи, React использует их, чтобы сопоставить потомков исходного дерева с потомками последующего дерева.
  </p>
</div>
</details>

<details>
<summary>33. Можно создавать анимации в React?</summary>
<div>
  <br />
  <p>
    React может использоваться для создания крутых анимаций! В качестве примера посмотрите библиотеки React Transition Group и React Motion.
  </p>
  <p><i>Источник: <a href ="https://ru.reactjs.org/docs/faq-styling.html#can-i-do-animations-in-react">ru.reactjs.org</a></i></p>
</div>
</details>

<details>
<summary>34. Что такое DRY?</summary>
<div>
  <p> Don’t Repeat Yourself </p>
  <p> Не повторять свой код. Главный из паттернов для поддержания этого принципа High-Order Component. </p>
  <p>Также важно понимать, что DRY нужен не для того, чтобы писать код быстрее. Его задача — упростить чтение и поддержку нашего решения. Поэтому не спешите создавать абстракции сразу. Лучше сделать простую реализацию какой-то части кода, а потом проанализировать, какие абстракции нужно создать, чтобы упростить чтение кода и уменьшить количество мест для изменений, когда они понадобятся.

  <a>Чеклист правильной абстракции:</a>

    1. Имя абстракции полностью соответствует ее назначению
    2. Абстракция выполняет конкретную, понятную задачу
    3. Чтение кода, из которого была выделена абстракция, улучшилось
</p>
</div>
</details>

<details>
<summary>35. Что такое KISS?</summary>
<p>
  KISS — «Оставьте код простым и тупым». Думаю, с понятием простого кода вы знакомы. Но что значит «тупой» код? В моем понимании, это код, который решает задачу, используя минимальное количество абстракций, при этом вложенность этих абстракций друг в друга также минимальна.
</p>
</div>
</details>

<details>
<summary>36. Что такое YAGNI?</summary>
<p>
  YAGNI — «Вам это не понадобится». Код должен уметь делать только то, для чего он написан. Мы не создаем никакой функционал, который может понадобиться потом или который делает приложение лучше на наш взгляд. Делаем только то, что нужно конкретно для реализации поставленной задачи.
</p>
</div>
</details>


<details>
<summary>37. Хук useLayoutEffect?</summary>
<p>
  Согласно официальной документации хук useLayoutEffect по своим параметрам (сигнатуре) полностью идентичен хуку useEffect. Главное же отличие заключается в том, что useLayoutEffect вызывается синхронно, после всех изменений в DOM. Также сами разработчики React рекомендуют использовать useLayoutEffect только в случае острой необходимости, чтобы вдруг не возникло проблем с правильным рендерингом компонентов. Хук useLayoutEffect можно использовать в случаях, когда необходимо произвести какие-то вычисления либо замеры в реальном DOM или провести синхронно мутацию (изменения).
</p>

<h3>Отличия:</h3>
<p>У useEffect одна загвоздка в том, что он запускается после того, как React отрисовывает ваш компонент и гарантирует, что ваш callback эффекта не блокирует отрисовку браузера. Отличается от  componentDidMount и componentDidUpdate тем что они запускаютс синхронно после рендера компонента. 
Однако, если ваш эффект мутирует DOM (например через ссылку узла DOM) и мутация DOM изменит внешний вид узла DOM между моментом его рендеринга и изменениями от вашего useEffect, тогда вам не стоит использовать useEffect . Вам лучше использовать useLayoutEffect. В противном случае пользователь может увидеть мерцание, когда ваши мутации DOM вступят в силу. Это почти единственный случай, когда вы хотите избежать использования useEffect и вместо этого использовать useLayoutEffect.</p>

<p>useEffect запускается асинхронно и после рендеринга на экране.
Итак, это выглядит:</p>

    1. Вы каким-то образом вызываете рендеринг (изменение состояния или повторный рендеринг родителя)
    2. React отображает ваш компонент (вызывает его)
    3. Экран визуально обновлен
    4. ТОГДА запускается useEffect

<p>useLayoutEffect, с другой стороны, запускается синхронно после рендеринга, но до обновления экрана. Это выглядит вот так:</p>

    1. Вы каким-то образом вызываете рендеринг (изменение состояния или повторный рендеринг родителя)
    2. React отображает ваш компонент (вызывает его)
    3. useLayoutEffect запускается, и React ждет его завершения.
    4. Экран визуально обновлен

<h3>use case:</h3>
<p>Если ваш компонент мерцает при обновлении состояния — например, он сначала рендерится в частично готовом состоянии, а затем сразу же повторно рендерится в своем конечном состоянии — это хороший признак того, что пришло время поменять местами в useLayoutEffect.

Так же useLayoutEffect будет иметь место, когда ваше обновление представляет собой двухэтапный (или многоэтапный) процесс. Вы хотите «сгруппировать» пару обновлений вместе перед перерисовкой экрана? Попробуйте использовать этот хук.</p>


</div>
</details>


<details>
<summary>38. Что такое React.lazy(), suspense?</summary>
<div>
  <p> Функция React.lazy позволяет рендерить динамический импорт как обычный. Проще говоря, она позволяет загружать дополнительные компоненты в наш общий файл bundle (для браузера) только тогда, когда они понадобятся. Это дает возможность облегчить загрузку страницы сразу, но с другой стороны увеличивает ожидание, когда приходит время подгрузки. Поэтому тут важно построить «цепочку поведения пользователей» и правильно разделить компоненты на «пачки».</p>
  <p> Suspense («задержка») позволяет показать запсное содержание, пока подгружается компонента черзе React.lazy.
  Меняем обычный импорт на импорт с «ленивой загрузкой». Например, отложим загрузку двух компонент в файле App.js. </p>
  </br>

  <a>Было:</a>

    import DialogsContainer from './components/Dialogs/DialogsContainer';
    import ProfileContainer from './components/Profile/ProfileContainer';
    ....
  <a>Стало:</a>

    const DialogsContainer = React.lazy(() => import('./components/Dialogs/DialogsContainer'));
    const ProfileContainer = React.lazy(() => import('./components/Profile/ProfileContainer'));
  </br>

  <p>Теперь сами ленивые компоненты в том же файле нам в месте вызова нужно обернуть в компоненту Suspense, которая позволяет нам показать запасное содержимое (например, индикатор загрузки) пока происходит загрузка ленивой компоненты. Сам компонент Suspense можно разместить где угодно выше над этими компонентами. Например:</p>

    return (
          
            <div className="app-wrapper">
              <HeaderContainer />
              <Navbar />
              <div className="app-wrapper-content">
                <Suspense fallback={<Preloader />}> //вот начало оборачивания
                  <Route path='/dialogs' render={ () => <DialogsContainer /> } />
                <Route path='/profile/:userId?' render={ () => <ProfileContainer /> } />
                </Suspense>
                  <Route path='/users' render={ () => <UsersContainer /> } />
                  <Route path='/news' render={ () => <News /> } />
                  <Route path='/music' render={ () => <Music /> } />
                  <Route path='/setings' render={ () => <Setings /> } />
                  <Route path='/login' render={ () => <Login /> } />
              </div>
            </div>
        );
    

  <p>Можно в качестве альтернативы создать подобие ХОКа, как показывал Димыч у видео. Для этого создаем файл src/components/hoc/withSuspense.js:</p>

    import React, { Suspense } from 'react';
    import Preloader from '../common/Preloader/Preloader';
    export const withSuspense = (Component) => {
        return (props) => {
            return  <Suspense fallback={<Preloader />}>
                <Component {...props} />
                </Suspense>
        }
    }
  </br>

  <p>И теперь оборачиваем те же наши компоненты этим ХОКом, а не самой компонентой Suspense:</p>

    return (
        
          <div className="app-wrapper">
            <HeaderContainer />
            <Navbar />
            <div className="app-wrapper-content">
                <Route path='/dialogs' render={ withSuspense(DialogsContainer) } /> //вот
                <Route path='/profile/:userId?' render={ withSuspense(ProfileContainer) } /> //и вот
                <Route path='/users' render={ () => <UsersContainer /> } />
                <Route path='/news' render={ () => <News /> } />
                <Route path='/music' render={ () => <Music /> } />
                <Route path='/setings' render={ () => <Setings /> } />
                <Route path='/login' render={ () => <Login /> } />
            </div>
          </div>
      );

</div>
</details>


<details>
<summary>39. React 18 в кратце об изменениях?</summary>
<div>
  <a>Automatic Batching</a>
  <p>До версии 18, React уже объединял/группировал (batched) несколько обновлений состояния в одно, чтобы уменьшить количество ненужных повторных отрисовок. Однако это происходило только в обработчиках событий DOM, поэтому промисы, тайм-ауты или другие обработчики этим не могли воспользоваться. Дело в том, что ранее каждый вызов useState (установка нового значения) приводил к перерисовке компонентов. Чуть позже движок оптимизировали и такие вызовы начали группироваться и выполняться за один раз, что должно было сократить количество перерисовок. Теперь данный функционал еще больше оптимизировали. 
 </p>
 </br>
  <p>ReactDOM.flushSync() может принудительно заставить компонент перерисовываться при каждом вызове useState (установка нового значения). Это может иногда понадобиться.</p>
  </br>
  <a>Strict Mode</a>
  <p>Напомню что Strict Mode был добавлен в React 16.3. Данный режим позволяет реакту производить дополнительные проверки что бы исключить возможные проблемы приложения.
  Далее, некоторые дополнения к строгому режиму (Strict Mode), включая новое поведение, называемое «строгими эффектами» (“strict effects”). Данный режим будет вызывать двойные эффекты — в частности, монтирование и размонтирование (mount и unmount). Добавление <StrictMode> в приложение React добавляет особое поведение (только в режиме DEV) ко всем компонентам, вокруг которых оно выполняется. Например, при работе в «строгом режиме» React намеренно выполняет двойной рендеринг компонентов, чтобы избавиться от небезопасных побочных эффектов.
  Эти дополнительные проверки предназначены для проверки нескольких циклов монтирования/размонтирования. Он обеспечивает не только более устойчивые компоненты, но и правильное поведение с технологией Fast Refresh во время разработки (когда компоненты монтируются/размонтируются для обновления) и новый «Offscreen API», который в настоящее время находится в разработке. </p>

  <a>Offscreen API</a>
  <p> Обеспечивает лучшую производительность, скрывая компоненты вместо их размонтирования, сохраняя состояние и по-прежнему вызывая эффекты монтирования/размонтирования. Это сыграет решающую роль в оптимизации таких компонентов, как вкладки, виртуализированные списки и т. д. </p>

  <a>Root API</a>
  <p>Немного про новое API, ориентированных на пользователя. Функция рендеринга (render) — та, которая находится в корне каждого приложения React, будет заменена на createRoot.
  Новый API — это шлюз для доступа к новым функциям React 18. createRoot предоставляется вместе с устаревшим API, чтобы способствовать постепенному внедрению и упрощению возможных сравнений производительности.</p>
  
    import ReactDOM from "react-dom";
    import App from "App";

    const container = document.getElementById("app");

    // Old
    ReactDOM.render(<App />, container);

    // New
    const root = ReactDOM.createRoot(container);

    root.render(<App />);

  <a>Параллельный рендеринг — Concurrent Rendering</a>
  <p>Если совсем просто про concurrent rendering то так: В обычном поведении, если React начал перерисовывать DOM, все остальные обновления в очереди блокируются и дожидаются окончания обновления. Concurrent rendering должен решить эту проблему. В конкурентном режиме рендеринг не блокируется. Он прерывается. Это улучшает UX и открывает новые возможности.</p>
</div>
</details>

<details>
<summary>40. Что такое forward ref?</summary>
<div>
  <p>React forwardRef — это метод, который позволяет родительским компонентам передавать ссылки своим дочерним элементам. Использование forwardRef в React дает дочернему компоненту ссылку на элемент DOM, созданный его родительским компонентом. Затем это позволяет дочернему элементу читать и изменять этот элемент везде, где он используется.</p>

  <h2>Как работает forwardRef в React?</h2>
  <p>В React родительские компоненты обычно используют props для передачи данных своим дочерним элементам. Представьте, что вы создаете дочерний компонент с новым набором props, чтобы изменить его поведение. Нам нужен способ изменить поведение дочернего компонента без необходимости искать состояние или повторно отображать компонент. Мы можем сделать это, используя refs. Мы можем получить доступ к узлу DOM, который представлен элементом, используя refs. В результате мы внесем в него изменения, не влияя на его состояние и не перерисовывая его.</p>

  <p>Когда дочернему компоненту необходимо сослаться на текущий узел своего родителя, у родительского компонента должен быть способ, которым дочерний компонент может получить свою ref. Этот метод известен как forward ref.</p>

        Syntax:

      React.forwardRef((props, ref) => {})

      Parameters: Принимает функцию с аргументами props и ref.

      Return Value: Возвращает JSX элемент.

  <h2>Для чего нужен forwardRef?</h2>
  <p>Давайте начнем с примера: допустим, у нас есть компонент ввода в нашем приложении React, который выглядит следующим образом:</p>

      const Input = (props) => {
        return <input {...props} />;
      };

  <p>Теперь мы также хотим сфокусировать компонент ввода на нажатие кнопки.</p>

  <p>Для этого нам просто нужно создать новую ссылку в нашем приложении, передать ее в Input и вызвать .focus() для элемента, верно? Неправильно!</p>
  <b>По умолчанию свойство ref работает только с элементами HTML, а не с компонентами React.</b>

  <p>Когда мы хотим передать ссылку на компонент React, нам нужно указать React, на какой элемент HTML он должен ссылаться, поскольку в нашем компоненте может быть более одного элемента.</p>

  <p>Вот где forwardRef становится полезным. Это позволяет нам указать, на какой именно элемент HTML мы хотим ссылаться.</p>


  <h2>Пример исопльзования  forwardRef.</h2>
  <p>Наша задача — перенаправить ссылку, которую получает компонент Input, на элемент ввода HTML.

  Мы делаем это, заключая компонент в forwardRef. Функция принимает обратный вызов с двумя параметрами:</p>

  <ul>
    <li>The component props</li>
    <li>The ref to be forwarded</li>
  </ul>

  <p>Этот callback вызов является нашим функциональным компонентом, который теперь принимает второе свойство.</p>

      const Input = forwardRef((props, ref) => {
        // Here goes the content of our component
      });

  <p>В возвращенном коде JSX нам теперь нужно передать ссылку, которую мы получаем в функции, в правильный компонент HTML, который в нашем случае является input элементом.</p>


      const Input = forwardRef((props, ref) => {
      return (
          <input
            ref={ref}
            {...props}
          />
        );
      });


      import React, { useState, useRef, forwardRef } from 'React';

      const Input = forwardRef((props, ref) => {
        return <input ref={ref} {...props} />;
      });

      const App = () => {
        const inputRef = useRef(null);
        const [value, setValue] = useState('');
        const onInputChange = (e) => {
          e.preventDefault();
          setValue(e.target.value);
        };

        const focus = () => {
          inputRef.current?.focus();
        };

        return (
          <>
            <Input value={value} onChange={onInputChange} ref={inputRef} />
            <button onClick={focus}>Focus</button>
          </>
        );
      };

  <h2>Доп материалы:</h2>

  <h3>Custom names for DevTools</h3>
  <p>Функция forwardRef берет имя компонента из функции, которую она принимает в качестве параметра. Если вы используете анонимные или стрелочные функции, ваши DevTools отобразят компонент следующим образом.</p>

  <img src="https://felixgerschau.com/static/8cc0dcf5e6d3a8bd5fd9e6a2636a5de0/b3e51/anonymous-function-devtools.png"/>

  <p>Есть несколько способов избежать этого. Во-первых, вы можете использовать выражение регулярной функции с таким именем:</p>

      const Input = forwardRef(function Input(props, ref) {
        return <input ref={ref} {...props} />;
      });

  <p>Вы также можете установить отображаемое имя вручную, добавив следующую строку в конец файла:</p>

      Input.displayName = 'Input';




  <a href="https://felixgerschau.com/react-forwardref-explained/">forwardRef Explained</a>
</div>
</details>


<details>
  <summary>41. Отличие элемента от компонента?</summary>
  <div>
  <h2>Элемент</h2>
  <ul>
    <li>Элемент — это простой объект JavaScript, который описывает состояние компонента и узел DOM, а также его желаемые свойства.</li>
    <li>Он содержит только информацию о типе компонента, его свойствах и любых дочерних элементах внутри него.</li>
    <li>immutable</li>
    <li>Мы не можем применять какие-либо методы к элементам.</li>
  </ul>
  <p>Пример: </p>

      const element = React.createElement(
        'div',
        {id: 'login-btn'},
        'Login'
      )

  <h2>Компонент</h2>
  <ul>
    <li>Компонент — это основной строительный блок приложения React. Это класс или функция, которая принимает ввод и возвращает элемент React.</li>
    <li>Он может содержать состояние и свойства и имеет доступ к методам жизненного цикла React.</li>
    <li>mutable</li>
    <li>Мы можем применять методы к компонентам.</li>
  </ul>
  <p>Пример: </p>

      function Button ({ onLogin }) {
        return React.createElement(
          'div',
          {id: 'login-btn', onClick: onLogin},
          'Login'
        )
      }

  </div>
</details>

<br/>

**React Router**:

<details>
  <summary>1. Что такое React Router?</summary>
  <div>
    <p>React Router — это стандартная библиотечная система маршрутизации, построенная поверх React. Он используется для создания маршрутизации в приложении React с использованием пакета React Router. Это поможет вам определить несколько маршрутов в приложении. Он предоставляет синхронный URL-адрес в браузере с данными, которые будут отображаться на веб-странице. Он поддерживает стандартную структуру и поведение приложения и в основном используется для разработки одностраничных веб-приложений.</p>
    <ul>
      <li>BrowserRouter: это реализация маршрутизатора, которая будет использовать API истории HTML5 (pushState, popstate и event replaceState) для синхронизации вашего пользовательского интерфейса с URL-адресом. Это родительский компонент, полезный для хранения всех остальных компонентов.</li>
      <li>Routes: это более новый компонент, представленный в React v6, и его обновление.</li>
      <li>Route: он считается условно отображаемым компонентом, и некоторый пользовательский интерфейс будет отображаться с его помощью всякий раз, когда есть совпадение между его путем и текущим URL-адресом.</li>
      <li>Link: полезно создавать ссылки на различные маршруты и осуществлять навигацию по всему приложению. Он работает аналогично тегу привязки в HTML.</li>
    </ul>
  </div>
</details>



<details>
  <summary>1. ?</summary>
  <div>
  </div>
</details>



<details>
  <summary>1. ?</summary>
  <div>
  </div>
</details>



<details>
  <summary>1. ?</summary>
  <div>
  </div>
</details>



<details>
  <summary>1. ?</summary>
  <div>
  </div>
</details>



<details>
  <summary>1. ?</summary>
  <div>
  </div>
</details>



<details>
  <summary>1. ?</summary>
  <div>
  </div>
</details>

<br/>

**Flux-архитектура, Redux и MobX**:

<details>
  <summary>1. Что такое Flux - архитектура? Какие сущности она имеет?</summary>
  <div>
    <p>
      Flux-архитектура — архитектурный подход или набор шаблонов программирования для построения пользовательского интерфейса веб-приложений, сочетающийся с реактивным программированием и построенный на однонаправленных потоках данных.
    </p>
    <p>
      Основной отличительной особенностью Flux является односторонняя направленность передачи данных между компонентами Flux-архитектуры. Архитектура накладывает ограничения на поток данных, в частности, исключая возможность обновления состояния компонентов самими собой. Такой подход делает поток данных предсказуемым и позволяет легче проследить причины возможных ошибок в программном обеспечении.
    </p>
    <img src="https://miro.medium.com/max/1400/1*MZj98upz0EUO52VAB4B41Q.jpeg" />
  </div>
</details>

<details>
<summary>2. Назовите ключевые принципы Redux</summary>
<div>
  <p>Redux следует трем фундаментальным принципам:</p>

  <p>1. Единственный источник истины:** состояние всего приложения хранится в древовидном объекта - в одном хранилище. Единственное состояние-дерево облегчает наблюдение за изменениями и отладку или инспектирование приложения</p>
  <p>2. Состояние доступно только для чтения:** единственный способ изменить состояние заключается в запуске операции - объекте, описывающем произошедшее. Это позволяет гарантировать, что ни представления, ни сетевые коллбеки не буду иметь возможности изменять состояние напрямую</p>
  <p>3. Изменения производятся с помощью "чистых" функций:** для определения того, как изменяется состояние в зависимости от операции, создаются редукторы (reducers). Редукторы - это "чистые" функции, принимающие предыдущее состояние в качестве аргумента и возвращающие новое. Благодаря чистым функциям доступен time travel в RTK.</p>
</div>
<img src="https://d33wubrfki0l68.cloudfront.net/01cc198232551a7e180f4e9e327b5ab22d9d14e7/b33f4/assets/images/reduxdataflowdiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif"/>
</details>

<details>
<summary>3. Store?</summary>
<div>
  <img src="https://habrastorage.org/webt/gm/ww/nq/gmwwnqmma6rdwtf3ofir3fjrcmy.gif" />
  <p>Все, что хранится в хранилище, мы называем состоянием, но не все состояния одинаково полезны. Вот какую классификацию вводит документация Redux:</p>

  <a>Domain data — данные приложения, которые нужно отображать, использовать и модифицировать. Например, список пользователей, загруженный с сервера.</a>
  </br>
  <a>App state — данные, определяющие поведение приложения. Например, текущий открытый URL.</a>
  </br>
  <a>UI state — данные, определяющие то, как выглядит UI. Например, вывод списка в плиточном виде.</a>
  </br>

  <p>
    Так как стор представляет собой ядро приложения, данные внутри него должны описываться в терминах domain data и app state, но не как дерево компонентов UI. Например, такой способ формирования состояния state.leftPane.todoList.todos — плохая идея. Крайне редко дерево компонентов отражается напрямую на структуру состояния, и это нормально. Представление зависит от данных, а не данные от представления.</p>
  
   <h2>Store API:</h2>

      const store = new Store(reducers, initialState);

   <h3>dispatch(action):</h3>
   <p>Метод dispatch позволит передать инструкцию для Store, что мы хотим изменить дерево состояния. Это обрабатывается с помощью только что рассмотренного редюсера.
   Функция reduce для хранилища будет вызываться с текущим результатом getState() и заданным действием синхронно. Его возвращаемое значение будет считаться следующим состоянием. С этого момента он будет возвращаться из getState(), и listeners  будут немедленно уведомлены.</p>

   <h3>subscribe(listener):</h3>
   <p>Метод subscribe позволит передать в Store функцию-подписчик, которой, когда наше дерево состояния изменится, мы сможем передать эти его новые изменения с помощью аргумента в обратном вызове .subscribe().</p>

   <h3>replaceReducer(nextReducer):</h3>
   <p>Заменяет редюсер, используемый в настоящее время хранилищем для вычисления состояния.
      Это расширенный API. Это может понадобиться, если ваше приложение реализует разделение кода и вы хотите динамически загружать некоторые редюсеры. Вам также может понадобиться это, если вы реализуете механизм горячей перезагрузки для Redux.</p>

   <h3>getState():</h3>
   <p>Возвращает текущее дерево состояний вашего приложения. Оно равно последнему значению, возвращенному редьюсером хранилища.</p>

</div>
</details>

<details>
<summary>4. Reducers?</summary>
<div>
  <p>(reducer) — это чистая функция, которая вычисляет следующее состояние дерева на основании его предыдущего состояния и применяемого действия.

    (currentState, action) => newState

  Чистая функция работает независимо от состояния программы и выдаёт выходное значение, принимая входное и не меняя ничего в нём и в остальной программе. Получается, что редуктор возвращает совершенно новый объект дерева состояний, которым заменяется предыдущий.

  Чего не должен делать редуктор
  Редуктор — это всегда чистая функция, поэтому он не должен:

  <li>мутировать аргументы;</li>
  <li>мутировать состояние. Вместо этого создаётся новое состояние с помощью Object.assign({}, ...);</li>
  <li>иметь побочные эффекты (никаких API-вызовов с какими-либо изменениями);</li>
  <li>вызывать нечистые функции. Это функции, результат которых зависит от чего-то кроме их аргументов (например, Date.now() или Math.random()).</li>
  </br>

      Редуктор для каждой части состояния
    const title = (state = '', action) => {
      if (action.type === 'CHANGE_LIST_TITLE') {
        return action.title
      } else {
        return state
      }
    }
    const list = (state = [], action) => {
      switch (action.type) {
        case 'ADD_ITEM':
          return state.concat([{ title: action.title }])
        case 'REMOVE_ITEM':
          return state.map((item, index) =>
            action.index === index
              ? { title: item.title }
              : item
        default:
          return state
      }
    }
</p>
</div>
</details>

<details>
<summary>5. Dispatcher?</summary>
<div>
  <p>Что бы обновить store необходимо вызвать метод dispatch(). Он вызывается у объекта store который вы создаёте в store.js. Этот объект принято называть store поэтому обновление состояния в моём случае выглядит так:</p>

    store.dispatch({ type: ACTION_1, value_1: "Some text" });

    ACTION_1 это константа события о которой речь пойдет дальше (см. Actions).

  <p>Эта функция вызовет функцию reducer который обработает событие и обновит соответствующие поля хранилища.</p>
  
</div>
</details>



<details>
<summary>6. Что такое селекторы (selectors) Redux и зачем их использовать?</summary>
<div>
<p>*Selectors* - это функции, принимающие состояние Redux в качестве аргумента и возвращающие некоторые данные для передачи компоненту.</p>

<p>Например, так можно извлечь данные пользователя из состояния:</p>

  ```javascript
  const getUserData = state => state.user.data
  ```

<p>Селекторы имеют два главных преимущества:</p>

<p>1. Селектор забирает из стора конкретные нужные данные.</p>
<p>2. Селектор не выполняет повторных вычислений до тех пор, пока не изменится один из его аргументов</p>

    const Foo = () => {
      const value = useSelector(state => state.value);

      return (
        <Bar value={value} />
      );
    };

    export default Foo;

</div>
</details>


<details>
<summary>7. Что такое операция (action) в Redux?</summary>
<div>
<p>*Actions* - это обычные JavaScript-объекты, содержащие данные приложения, которые отправляются в хранилище. Операции должны иметь свойство `type`, указывающее какой тип операции необходимо выполнить. Операции также могут содержать полезную нагрузку (payload) - данные для обновления состояния.</p>

<p>Вот как может выглядеть операция по добавлению новой задачи в список:</p>

  ```
  // здесь используется константа
  {
    type: ADD_TODO,
    text: 'Добавление задачи в список'
  }
  ```
</div>
</details>



<details>
<summary>8. Проведите сравнение Redux и Flux</summary>
<div>
  <p>Отличия между Redux и Flux можно свести к следующему:</p>

  <p>1. **Недопустимость мутаций:** во Flux состояние может быть изменяемым, а Redux требует, чтобы состояние было иммутабельным, и многие библиотеки для Redux исходят из предположения, что вы никогда не будете менять состояние напрямую. Вы можете обеспечить иммутабельность состояния с помощью таких пакетов, как `redux-immutable-state-invariant`, `Immutable.js` или условившись с другими членами команды о написании иммутабельного кода</p>
  <p>2. **Осторожность в выборе библиотек:** Flux не пытается решать такие проблемы, как повторное выполнение/отмена выполнения, стабильность (постоянство) кода или проблемы, связанные с обработкой форм, явно, а Redux имеет возможность к расширению с помощью промежуточного программного обеспечения (middleware) и предохранителей хранилища, что породило богатую экосистему</p>
  <p>3. **Отсутствие интеграции с Flow:** Flux позволяет осуществлять очень выразительную статическую проверку типов, а Redux пока не поддерживает такой возможности</p>

   
</div>
</details>

<details>
<summary>9. В чем разница между `mapStateToProps()` и `mapDispatchToProps()`?</summary>
<div>
<p> `mapStateToProps()` - это утилита, помогающая компонентам получать обновленное состояние (которое было обновлено другим компонентом):</p>

<p>

    const mapStateToProps = (state) => {
      return {
        todos: getVisibleTodos(state.todos, state.visibilityFilter)
      }
    }
</p>

<p>`mapDispatchToProps()` - утилита, помогающая компонентам вызывать операции (которые могут привести к обновлению состояния приложения):</p>

<p>

    const mapDispatchToProps = (dispatch) => {
      return {
        onTodoClick: (id) => {
          dispatch(toggleTodo(id))
        }
      }
    }
</p>

<p>Ваши компоненты должны быть связаны только с отображением информации. Единственное место, откуда они должны получать информацию, — это пропсы.</p>

<p>Отдельно от «отображения материала» (компонентов) стоит:
    как вы получаете данные для отображения,
    и как вы обрабатываете события.
    Для этого есть контейнеры.</p>

<p>

    class FancyAlerter extends Component {
      sendAlert = () => {
          this.props.sendTheAlert()
      }

      render() {
          <div>
            <h1>Today's Fancy Alert is {this.props.fancyInfo}</h1>
            <Button onClick={sendAlert}/>
          </div>
      }
    }

</p>

<p>Вот где появляется mapDispatchToProps: в соответствующем контейнере:</p>

    function mapDispatchToProps(dispatch) {
        return({
            sendTheAlert: () => {dispatch(ALERT_ACTION)}
        })
    }

    function mapStateToProps(state) {
        return({fancyInfo: "Fancy this:" + state.currentFunnyString})
    }

    export const FancyButtonContainer = connect(
        mapStateToProps, mapDispatchToProps)(
        FancyAlerter
    )

<p>Теперь FancyButtonContainer знает о redux, dispatch, store, state и... прочем.

Компонент в шаблоне, FancyAlerter, который выполняет рендеринг, не должен знать ни о чем из этого: он получает свой метод для вызова при нажатии кнопки через свои props.

И... mapDispatchToProps был полезным средством, которое предоставляет Redux, позволяющим контейнеру легко передавать эту функцию в обернутый компонент в своих реквизитах.</p>
</div>
</details>

<details>
<summary>10. Обязательно ли хранить состояние всех компонентов в хранилище Redux?</summary>
<div>
<p>Данные приложения следует хранить в хранилище Redux, а состояние компонентов пользовательского интерфейса в соответствующих компонентах. У создателя Redux Дэна Абрамова по этому поводу есть статья под названием "Следует ли вам использовать Redux?"</p>
</div>
</details>


<details>
<summary>11. Как рекомендуется получать доступ к хранилищу Redux?</summary>
<div>
<p>Лучшим способом получить хранилище в компоненте является использование функции `connect()`, которая создает новый компонент, оборачивающий существующий. Этот паттерн называется *компоненты высшего порядка*, он является предпочтительным способом расширения функциональности компонента в React. Это позволяет передавать в компонент состояние и "создателей операций" (action creators), в том числе, при обновлении хранилища.</p>

<p>Создадим компонент `FilterLink` с помощью `connect()`:</p>

<p>

     import { connect } from 'react-redux'
     import { setVisibilityFilter } from '../actions'
     import Link from '../components/Link'

     const mapStateToProps = (state, ownProps) => ({
       active: ownProps.filter === state.visibilityFilter
     })

     const mapDispatchToProps = (dispatch, ownProps) => ({
       onClick: () => dispatch(setVisibilityFilter(ownProps.filter))
     })

     const FilterLink = connect(
       mapStateToProps,
       mapDispatchToProps
     )(Link)

     export default FilterLink
</p>

<p>Поскольку такой вариант имеет несколько оптимизаций производительности и, как правило, меньше подвержен "багам", разработчики Redux почти всегда рекомендуют использовать `connect()` вместо прямого доступа к хранилищу (с помощью API контекста).</p>

     class MyComponent {
       someMethod() {
         doSomethingWith(this.context.store)
       }
     }
</p>
</div>
</details>

<details>
<summary>12. Для чего в Redux нужны константы??</summary>
<div>
<p>Константы позволяют легко обнаруживать все случаи их применения в проекте при использовании IDE. Они также позволяют избегать глупых ошибок, связанных с типами - немедленно выбрасывается исключение `ReferenceError`.</p>

<p>Обычно, мы сохраняем константы в отдельном файле  (`constants.js` или `actionTypes.js`)</p>

```javascript
export const ADD_TODO = 'ADD_TODO'
export const DELETE_TODO = 'DELETE_TODO'
export const EDIT_TODO = 'EDIT_TODO'
export const COMPLETE_TODO = 'COMPLETE_TODO'
export const COMPLETE_ALL = 'COMPLETE_ALL'
export const CLEAR_COMPLETED = 'CLEAR_COMPLETED'
```

<p>В Redux мы используем их в двух местах:</p>

1. **Во время создания операции:**

      `actions.js`:

      ```javascript
      import { ADD_TODO } from './actionTypes';

      export function addTodo(text) {
        return { type: ADD_TODO, text }
      }
      ```

2. **В редукторах:**

      `reducer.js`:

      ```javascript
      import { ADD_TODO } from './actionTypes'

      export default (state = [], action) => {
        switch (action.type) {
          case ADD_TODO:
            return [
              ...state,
              {
                text: action.text,
                completed: false
              }
            ];
          default:
            return state
        }
      }
      ```
       
</div>
</details>



<details>
<summary>13. Как структурировать директории верхнего уровня в Redux?</summary>
<div>
<p>Большинство приложений имеют несколько "топовых" директорий:</p>

<p>1. **components**: используется для "тупых" компонентов, не знающих о Redux</p>
<p>2. **containers**: используется для "умных" компонентов, подключенных к Redux</p>
<p>3. **actions**: используется для всех создателей операций - названия файлов указывают на соответствующие части приложения</p>
<p>4. **reducers**: используется для всех редукторов - названия коррелируют с ключами состояния</p>
<p>5. **store**: используется для инициализации хранилища</p>

<p>Такая структура прекрасно подходит для небольших и средних приложений.</p>
</div>
</details>


<details>
<summary>14. Обязательно ли хранить все состояние в Redux? Можно ли использовать внутреннее состояние компонентов?</summary>
<div>
<p>Вы сами принимаете решение, что использовать. В этом заключается работа разработчика - определить, какое состояние требуется  приложению и где должна храниться каждая часть этого состояния. Одни разработчики предпочитают хранить все состояние в Redux, что обеспечивает полную сериализацию и управляемость приложения. Другие предпочитают хранить некритичное состояние UI, такое как "открыт ли выпадающий список" внутри компонента.</p>

<p>Ниже представлены основные правила определения того, какие типы данных следует хранить в Redux:</p>

     1. Нуждаются ли другие части приложения в этих данных?
     2. Требуется ли создавать производные данные на основе оригинальных?
     3. Используются ли эти данные несколькими компонентами?
     4. Существует ли вероятность того, что потребуется восстанавливать прошлое состояние?
     5. Собираетесь ли вы кэшировать данные (для использования версии из кэша вместо повторного запроса)?
</div>
</details>

<details>
<summary>15. Middleware?</summary>
<div>
  <img src="https://d33wubrfki0l68.cloudfront.net/08d01ed85246d3ece01963408572f3f6dfb49d41/4bc12/assets/images/reduxasyncdataflowdiagram-d97ff38a0f4da0f327163170ccc13e80.gif" />

  <p>Мидлвары — функции, которые последовательно вызываются в процессе обновления данных в хранилище.</p>

  <h3>Общий принцип работы таков:</h3>

  <p>Мидлвары встраиваются в хранилище при его создании
  Во время диспатчинга (отправки действий) данные проходят через них и только затем попадают в редьюсер</p>
  
  Типичные примеры использования включают:

    Логирование
    Оповещение об ошибках
    Работу с асинхронным API
    Маршрутизацию
  </br>
  <p>Посмотрим как их подключить:</p>

    import { createStore, applyMiddleware } from 'redux';
    import thunk from 'redux-thunk';

    const store = createStore(
      reducer,
      /* preloadedState, */
      applyMiddleware(thunk)
    )
  <p>thunk — это мидлвар, но перед тем, как передать его в функцию createStore, нужно применить к нему функцию applyMiddleware. Также обратите внимание на то, что мидлвар мы передаём вторым параметром, хотя в предыдущем уроке вторым параметром шёл initState. Объясняется это просто — функция createStore проверяет тип второго параметра и в зависимости от этого понимает, что перед ней. В общем случае она принимает три параметра: редьюсер, начальное состояние и мидлвары</p>  
</div>
</details>


<details>
<summary>16. RTK Slice?</summary>
<div>
  <p> Чтобы мы не делали внутри слайсов, в конце-концов они генерируют обычные редьюсеры и действия, которые затем передаются в Redux. То есть, слайсы не добавляют никаких новых возможностей в сам Redux. Они автоматизируют рутину, сокращают количество кода и предоставляют более удобные "ручки" для управления действиями и состоянием.</p>

  <p>Для создания слайса нам нужно как минимум три компонента: имя, начальное состояние, набор редьюсеров.</p>

    import { createSlice } from '@reduxjs/toolkit';

    // Начальное значение
    const initialState = {
      value: 0,
    };

    const counterSlice = createSlice({
      name: 'counter',
      initialState,
      // Редьюсеры в слайсах мутируют состояние и ничего не возвращают наружу
      reducers: {
        increment: (state) => {
          state.value += 1;
        },
        decrement: (state) => {
          state.value -= 1
        },
        // пример с данными
        incrementByAmount: (state, action) => {
          state.value += action.payload
        },
      },
    });

  <a>Имя:</a>
  <p>Имя это свойство в состоянии приложения, внутри которого хранятся данные текущего слайса. Кроме того, имя используется как префикс в названии действия. На картинке слева Navigator. Помогает отладке, мы видим откуда взялось действие.</p>
  <img src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImM2ODlmN2VlNWE0OTkxZDhlNmIxOTE0ZGI5YTE0NWM3LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=47a192fc8d37671228ecb3ad1cb1d72f2fcbbbd052400fb316bc3cb84440bac1" />

  <a>Начальное состояние:</a>

  <p>Под начальным состоянием понимается базовая структура данных и какие-то статические данные, если они есть, например значение 0 для счетчика. А вот те данные, которые нужно выкачать по API, к начальным не относятся. Они заполняются уже потом, через действия.</p>

  <a>Редьюсеры:</a>
  <p>Редьюсеры в Toolkit очень похожи на редьюсеры самого Redux, но имеют несколько важных отличий. Каждый редьюсер соответствует конкретному действию, поэтому внутри нет конструкции switch, а сами редьюсеры очень маленькие. И внутри редьюсеров происходит прямое изменение состояния. Как такое возможно?

  <p>Redux, несмотря на свою концептуальную красоту и чистоту, становится неудобным в работе, когда состояние становится глубоко вложенным. Запрет на прямое изменение порождает сложные конструкции, которые приходится писать для обновления глубоко спрятанных данных:</p>

    {
      ...state,
      firstLevel: {
        ...state.firstLevel,
        secondLevel: {
          ...state.firstLevel.secondLevel,
          thirdLevel: {
            ...state.firstLevel.secondLevel.thirdLevel,
            property1: action.data
          },
        },
      },
    }

 <p>Для решения этой проблемы в JavaScript написали немало библиотек, но все они требуют изучения еще одного инструмента, который хоть и сокращает количество кода, но вносит еще один уровень абстракции, со своими проблемами и сложностями использования. Так продолжалось до тех пор, пока не появился Immer.</p>   


 <p>И наконец экспорты. Функция createSlice() генерирует редьюсер и экшены к нему. Всё это нужно экспортировать в показанном стиле: редьюсер по умолчанию, действия по именам:</p>

    export const { increment, decrement, incrementByAmount } = counterSlice.actions;
    export default counterSlice.reducer; 
</div>
</details>


<details>
<summary>17. Immer?</summary>
<div>
  <p>Immer. Эта библиотека позволяет отследить прямые изменения внутри объекта, так чтобы обновить оригинал без мутаций, то есть создавая копию в стиле Redux.</p>

    import produce from 'immer';

    const baseState = [
      {
        title: "Learn TypeScript",
        done: true
      },
      {
        title: "Try Immer",
        done: false
      },
    ];


    // draft содержит такие же данные как и baseState,
    // но они обернуты в Proxy для отслеживания изменений
    // Эти изменения затем используются для обновления baseState
    const nextState = produce(baseState, (draft) => {
      draft[1].done = true;
      draft.push({title: 'Hexlet teach me'});
    });

    // Разные объекты!
    nextState !== baseState;

<p>В отличие от прямого изменения baseState, Immer делает это как редьюсеры в Redux, в неизменяемом стиле.</p>

  <p>Получается, что каждый редьюсер в Toolkit, это тот колбек из Immer, в который передается draft. Теперь мы можем мутировать состояние, но внутри все работает так, как будто мы этого не делаем. Благодаря такому подходу сохраняются все возможности, которые предоставляет Redux, включая его DevTool - утилиту для анализа происходящего в браузере. В этом заключается главная фантастика происходящего. Мы получили плюсы от обоих миров, сохранив всю экосистему Redux.</p>

  
</div>
</details>


<details>
<summary>18. Batch?</summary>
<div>
  <p>Когда появляется несколько слайсов, то возникает необходимость обновить состояние сразу несколькими экшенами. Если это делать обычным способом, то на каждое действие будет происходить перерисовка компонента:</p>

    import React, { useEffect } from 'react';
    import { useDispatch } from 'react-redux';
    import { addUsers } from '../slices/usersSlice.js';
    import { addPosts } from '../slices/postsSlice.js';
    import Posts from './Posts.jsx';

    export default () => {
      const dispatch = useDispatch();

      useEffect(async () => {
        // получаем данные users и posts
        const { data: posts } = await axios.get('/posts');
        const { data: users } = await axios.get('/users');
        dispatch(addPosts(posts));
        dispatch(addUsers(users));
      });

      return (<Posts />)
    };
  
    export default () => {
    // Вытаскиваем данные из хранилища. state – все состояние
    const users = useSelector((state) => state.usersSlice.users);
    const posts = useSelector((state) => state.postsSlice.posts);

    const renderPost = (post) => {
      const author = users.find((user) => user.id === post.authorId); // ошибка! users ещё не добавлен в стор
      const body = `Автор: ${author.name}. Текст: ${post.body}.`;
      return <div>{body}</div>;
    };

      return (
        {posts.map(renderPost)}
      );
    };

  <p>Компонент Posts отрисовывается при каждом изменении состояния. Происходит это дважды: когда мы добавляем посты dispatch(addPosts(posts)) и когда добавляем пользователей dispatch(addUsers(users)). В первом случае возникает проблема, так как пользователи ещё не добавлены, то автор не будет найден. Чтобы этого избежать есть специальная функция batch(), она позволяет объединить несколько обработчиков состояния:</p>

    // file: components/App.jsx

    import React, { useEffect } from 'react';
    // импортируем batch
    import { batch } from 'redux';
    import { useDispatch } from 'react-redux';
    import { addUsers } from '../slices/usersSlice.js';
    import { addPosts } from '../slices/postsSlice.js';
    import Posts from './Posts.jsx';

    export default () => {
      const dispatch = useDispatch();

      useEffect(async () => {
        // получаем данные users и posts
        const { data: posts } = await axios.get('/posts');
        const { data: users } = await axios.get('/users');
        // batch принимает функцию, внутри которой мы можем диспатчить экшены
        batch(() => {
          dispatch(addPosts(posts));
          dispatch(addUsers(users));
        });
      }, []);

      return (<Posts />)
    };
  <p>Теперь, при загрузке постов и пользователей и добавлении их в стор, компонент Posts отрисуется один раз, когда все данные уже добавлены.</p>

  
</div>
</details>



<details>
<summary>19. Организация хранения данных в Redux/RTK?</summary>
<div>

  <p>Нормализация – это процесс удаления избыточных данных.
    Нормализация – это метод проектирования базы данных, который позволяет привести базу данных к минимальной избыточности.</p>

  <p>Правильный подход при работе с Redux — воспринимать его как реляционную базу данных. Данные внутри хранилища должны быть нормализованы. При таком взгляде каждый слайс работающий с набором сущностей может восприниматься как отдельная таблица в базе данных.</p>

  <p>Основные принципы организации данных в хранилище:</p>

    Каждая сущность хранится в своём редьюсере.

    Коллекция сущностей одного типа хранится в виде объекта, где ключи — идентификаторы объектов, а значения — сами объекты.

    Порядок данных в этом объекте задаётся отдельным массивом состоящим только из идентификаторов.

    Данные ссылаются друг на друга только по идентификаторам.
  
  <h2>Было:</h2>

    const blogPosts = [
    {
      id: 'post1',
      author: { username: 'user1', name: 'User 1' },
      body: '......',
      comments: [
        {
          id: 'comment1',
          author: { username: 'user2', name: 'User 2' },
          comment: '.....'
        },
        {
          id: 'comment2',
          author: { username: 'user3', name: 'User 3' },
          comment: '.....'
        }
      ]
    },
    ];
  <h2>Стало:<h2>  

    {posts: {
        entities: {
          post1: {
            id: 'post1',
            author: 'user1',
            body: '......',
            comments: ['comment1', 'comment2'],
          },
          post2: {
            id: 'post2',
            author: 'user2',
            body: '......',
            comments: [],
          },
        },
        ids: ['post1', 'post2'],
      },
      comments: {
        entities: {
          comment1: {
            id: 'comment1',
            author: 'user2',
            comment: '.....',
          },
          comment2: {
            id: 'comment2',
            author: 'user3',
            comment: '.....',
          },
        },
        ids: ['comment1', 'comment2'],
      },
      users: {
        entities: {
          user1: {
            username: 'user1',
            name: 'User 1',
          },
          user2: {
            username: 'user2',
            name: 'User 2',
          },
          user3: {
            username: 'user3',
            name: 'User 3',
          },
        },
        ids: ['user1', 'user2', 'user3'],
      }
    }

  <p>  Теперь данные нормализованы. Каждая сущность хранится в своём собственном редьюсере. Объект entities хранит сами сущности, а ids - идентификаторы. Какие преимущества мы получили?</p>

    Массив с id хранит в себе еще и порядок сущность в entities.

    Данные не повторяются, а значит достаточно поменять только одно место при их изменении

    Редьюсеры не имеют вложенности

    Данные в таком виде легко извлекать и модифицировать

    Теперь посмотрим как это будет выглядеть внутри слайсов:
    
    const slice = createSlice({
      name: 'users',
      initialState: {
        ids: [],
        entities: {},
      },
      reducers: {
        addUser(state, action) {
          const { user } = action.payload;

          state.entities[user.id] = user;
          state.ids.push(user.id);
        }
        removeUser(state, action) {
          const { userId } = action.payload;

          delete state.entities[userId];
          state.ids = state.ids.filter((id) => id !== userId);
        },
        updateUser(state, action) {
          const { userId, data } = action.payload;

          Object.assign(state.entities[userId], data);
        }
      },
    });

    dispatch(addUser({ user }));
    dispatch(removeUser({ userId }));
    dispatch(updateUser({ userId, data }));

</div>
</details>


 <details>
<summary>20. RTK entity adapter?</summary>
<div>
  <p>Entity Adapter. Он предоставляет набор готовых редьюсеров и селекторов для основных операций над сущностями. Сначала пример:</p>

    import {
      createSlice,
      createEntityAdapter,
    } from '@reduxjs/toolkit';

    const usersAdapter = createEntityAdapter();

    // По умолчанию: { ids: [], entities: {} }
    const initialState = usersAdapter.getInitialState();

    const slice = createSlice({
      name: 'users',
      initialState,
      reducers: {
        addUser: usersAdapter.addOne,
        addUsers: usersAdapter.addMany,
        removeUser: usersAdapter.removeOne,
        updateUser: usersAdapter.updateOne,
      },
    });

    // Где-то в приложении

    // По соглашению, в передаваемых данных должен быть id для правильной работы
    dispatch(addUser(user));
    // Данные передаются в формате: { id, changes }
    dispatch(updateUser({ id: user.id, changes: data }));
    // Достаточно передать идентификатор
    dispatch(removeUser(user.id));

  <p> Буквально 4 строчки в редьюсерах и мы получили полноценную реализацию стандартных операций над пользователем. Но это еще не все, кроме готовых редьюсеров, Entity Adapter дает нам набор готовых селекторов для извлечения данных из хранилища. Для этого их нужно сгенерировать и экспортировать из файла со слайсом:</p> 

    // Колбек определяет базовый селектор, извлекающий нужную часть состояния из Redux
    // Для слайса users это state.users
    export const selectors = usersAdapter.getSelectors((state) => state.users);

  <p>Пример использования в приложении:</p>

    import { useSelector, useDispatch } from 'react-redux';

    import { selectors } from '../slices/usersSlice.js';

    const MyComponent = (props) => {
      // Извлекаем всех пользователей в виде массива
      // Внутри происходит выборка данных из state.users.entities
      // отсортированная по state.users.ids
      const users = useSelector(selectors.selectAll);

      // тут логика вывода
    }
    Кроме selectAll(state) мы получаем:

    selectIds(state) – возвращает ids
    selectEntities(state) – возвращает entities
    selectTotal(state) – возвращает общее количество
    selectById(state, id) – возвращает конкретную сущность или undefined если ничего не найдено

    // id – какой-то идентификатор
    const user = useSelector((state) => selectors.selectById(state, id));  
</div>
</details>


<details>
<summary>21. RTK Extra Reducers?</summary>
<div>
  <p>Разделение данных по слайсам (а фактически по редьюсерам в Redux) приводит к ситуациям, когда на одно действие нужно реагировать в разных частях хранилища. Например, если удаляется пост, то нужно удалить и его комментарии, которые находятся в другом слайсе.</p>

  <p>В Redux такая задача решалась просто добавлением в switch реакции на нужное действие по его имени. В Redux Toolkit так уже не получится из-за железной связи редьюсеров с действиями. Это цена, которую мы платим за сокращение кода.</p>

  <p>Для реакции на действия, происходящие в других слайсах, Redux Toolkit добавляет механизм дополнительных редьюсеров extraReducers. Работает он достаточно просто. В слайс добавляется свойство extraReducers, через которое можно устанавливать реакцию (редьюсеры) на внешние действия:</p>

     // Импортируем из других слайсов действия на которые нужно реагировать
    import { removePost } from '../postsSlice.js';

    const postCommentsAdapter = createEntityAdapter();
    const initialState = postCommentsAdapter.getInitialState();

    const postCommentsSlice = createSlice({
      name: 'comments',
      initialState: initialState,
      reducers: {
        // Обычные редьюсеры
      },
      extraReducers: (builder) => { // Дополнительные редьюсеры
        // При удалении поста нужно удалить все его комментарии
        builder.addCase(removePost, (state, action) => {
          const postId = action.payload;
          // Выбираем все комментарии кроме тех, что нужно удалить
          const restEntities = Object.values(state.entities).filter((e) => e.postId !== postId);
          // setAll удаляет текущие сущности и добавляет новые
          postCommentsAdapter.setAll(state, restEntities);
        });
      },
    });

    // Где-то в приложении
    dispatch(removePost(post.id));

  <p>Дополнительные редьюсеры добавляются как кейсы в объект builder, изменяя его напрямую. Поэтому нам не нужно ничего возвращать. Более того, builder поддерживает цепочки, а значит мы можем вызывать добавление кейсов друг за другом builder.addCase().addCase()....</p>  
</div>
</details>

<details>
<summary>22. Redux-thunk?</summary>
<div>
  <p>Redux thunk это термин в программировании который обозначает "кусочек кода который делает какую то отложенную работу". Вместо того, чтобы выполнять некоторую логику сейчас, мы можем написать тело функции или код, который можно использовать для выполнения работы позже.</p>

  <p>В частности, для Redux «thunks» — это шаблон написания функций с логикой внутри, которые могут взаимодействовать с dispatcher хранилища Redux и методами getState.</p>

  <p>Redux-thunk: это промежуточное программное обеспечение, которое отслеживает каждое действие, проходящее через систему, и, если это функция, она вызывает эту функцию.</p>


  <p>Redux будет передавать два аргумента функциям-преобразователям: dispatch, чтобы они могли отправлять новые действия, если им это нужно; и getState, чтобы они могли получить доступ к текущему состоянию. Код redux-thunk выглядит вот так:</p>

    function createThunkMiddleware(extraArgument) {
      return ({ dispatch, getState }) => next => action => {
        if (typeof action === 'function') {
          return action(dispatch, getState, extraArgument);
        }

        return next(action);
      };
    }

    const thunk = createThunkMiddleware();
    thunk.withExtraArgument = createThunkMiddleware;

    export default thunk;

  <p>Функция getState может быть полезна для принятия решения о том, следует ли извлекать новые данные или возвращать кешированный результат, в зависимости от текущего состояния.</p>



  <h2>Для чего используются thunks?</h2>
  <p>Thunks позволяют нам писать дополнительную логику, связанную с Redux, отдельно от слоя пользовательского интерфейса. Эта логика может включать побочные эффекты, такие как асинхронные запросы или генерация случайных значений, а также логика, требующая dispatching нескольких действий или доступа к состоянию хранилища Redux.</p>

  <p>Reducers Redux не должны содержать побочных эффектов, но для реальных приложений требуется логика, имеющая побочные эффекты. Некоторые из них могут находиться внутри компонентов, но некоторым может потребоваться жить вне уровня пользовательского интерфейса. Thunks (и другое промежуточное ПО Redux) дают нам место для размещения этих побочных эффектов.</p>
  <p>Это может быть сделано для улучшения тестируемости логики, чтобы уровень пользовательского интерфейса оставался как можно более тонким и «презентативным», или для улучшения повторного использования и совместного использования кода.</p>


  <h2>Итого:</h2>
  <p>redux-thunk позволяет создавать actions которые будут функциями с возможность dispatch другие функции, а не только action обьекты.</p>
  <p>redux-thunk это пример Redux Middleware и как таковой должен придеживаться сигнатуры validMiddleware => (store) => (next) => (action)
  
  Где store = {dispatch, getState}</p>

  <p>redux-thunk логика достаточно проста. Выполняется проверка на то, является ли переданный action функцией. И если да, функция запускается. По умолчанию происходит импорт Middleware без extraArgument, но потом к thunk добавляется поле withExtraArgument = createThunkMiddleware. При необходимости эта функция будет использована.</p>

  <a href="https://daveceddia.com/what-is-a-thunk/#commento-login-box-container">thunk theory</a>
  <a href="https://user3141592.medium.com/understanding-the-redux-thunk-source-code-b3f8b930faf6">thunk underhood</a>

</div>
</details>



<details>
<summary>23. ES6 generators?</summary>
<div>
  <p>Как видно из примера, генераторы вводят новый синтаксис в язык. Во-первых, это звездочка после слова function. Она просто указывает на то, что мы имеем дело с генератором. Во-вторых, выражение yield (подчеркиваю: это – не инструкция).</p>

  <p>Генератор в отличие от обычной функции при своем вызове не выполняет тело, а возвращает специальный объект с методом next. Каждый раз, когда вызывается next, запускается тело генератора с того места, где оно остановилось последний раз. При первом вызове выполнение идёт с самого начала генератора и продолжается до встречи с выражением yield. В этот момент управление передаётся наружу, next возвращает то, что было передано в yield, а генератор замирает в этом состоянии, на выражении yield. Последующие вызовы начинают работу от yield.</p>

  <p>Еще один пример для осознания:</p>

    const gen = function* () {
      yield 1;
      yield 2;
      yield 3;
    };

    const it = gen();
    it.next(); // { value: 1, done: false }
    it.next(); // { value: 2, done: false }
    it.next(); // { value: 3, done: false }
    it.next(); // { value: undefined, done: true }

  <p>Или даже так:</p>

    const it = gen();
    [...it]; // [1, 2, 3]

  <p>Кроме yield в генераторах можно использовать версию yield*, которая ожидает на вход коллекцию и делает yield для каждого элемента этой коллекции.</p>

    const makeIterator = function* () {
      yield* this.collection;
    };

  <p>Теперь можно переписать наш первый пример вот таким образом:</p>

    const obj = {
      collection: ['yo', 'ya'],
      [Symbol.iterator]: function* () {
        yield* this.collection;
      },
    };

    for (const v of obj) {
      console.log(v);
    }
    // yo
    // ya

</div>
</details>




<details>
<summary>24. Redux-saga?</summary>
<div>
  <p>Redux-saga это библиотека нацеленная делать сайд-эффекты проще и лучше путем работы с сагами.</p>
  <p>Саги это дизайн паттерн, который пришел из мира распределенных транзакций, где сага управляет процессами, которые необходимо выполнять транзакционным способом, сохраняя состояние выполнения и компенсируя неудачные процессы.</p>
  <p>Работает на генераторах, умеет приостанавливать и возобновлять свою работу в любой момент.</p>
  <p>Это библиотека, абстрагирующая и облегчающая работу с побочными эффектами в react/redux приложениях.</p>
  <p>Сага работает в "фоне".</p>
  <p>Саги позволяют организовать сложные цепочки побочных эффектов в последовательные вызовы.</p>
  
  <img src="https://raw.githubusercontent.com/rohit120582sharma/Documentation/master/images/redux-saga_architecture.png" />


  <h2>createSagaMiddleware(options)</h2>
  <h3>Options: Object</h3>
  <p>Список опций для передачи в middleware.</p>
  <ul>
    <li>context: Object - иницианизирующее значение saga context.</li>
    <li>sagaMonitor - для выведения логов</li>
    <li>onError: (error: Error, { sagaStack: string }) - если установлено, то мидллвар будет вызывать ее с uncaught ошибками из Saga. Полезно для того что бы посылать не обработанные exception в следящие сервисы.</li>
    <li>effectMiddlewares - Функция [] - позволяет вам перехватывать любой эффект, разрешать его самостоятельно и отправлять в следующий middleware.</li>
  </ul>



  <h2>Saga watcher</h2>

  <p>Следят за действиями в приложении, и когда происходит экшн реагируют.</p>

  <h2>Saga worker</h2>

  <p>Выполняет бизнес логику (запрос/таймаут/запись в кэш)</p>

  <h2>Effects:</h2>
  <p>Блокирующие/Не блокирующие</p>
  <img src="https://soshace.com/wp-content/uploads/rcl-uploads/articles/2019/11/1484933.jpg" />
  <h3>Take</h3>
  <a>Блокирующий</a>
  <p>Указывает middleware ждать dispatch указанного действия. Генератор приостанавливается до тех пор, пока не будет отправлено указанное действие. Ждет какого либо диспатча и когда он происходит может выполнится.</p>
  
  <h3>Take Every</h3>
  <p>Создает и запусткает worker-saga на каждый dispatch данного экшена.<p>

  <h3>Take Latests</h3>
  <p>Автоматически отменяет любую предыдущую задачу саги, запущенную ранее, если она все еще выполняется.<p>  

  <h3>Take Leading</h3>
  <p>Автоматически отменяет любую следующу задачу саги, запущенную позднее, если первая запущенная еще выполняется.<p>  

  <h3>Put</h3>
  <p>Вызывает dispatch с переданным action.<p>  

  <h3>Call</h3>
  <a>Блокирующий</a>
  <p>Выполняет переданную функцию. Если функция вернет promise, приостанавлевает сагу до тех пор, пока promise не вызовет Resolve. Принимает простые функции, асинхронные функции или генераторы. Вторым аргументом передается данные на вход переданной функции.<p>  

  <h3>Fork</h3>
  <a>Не блокирующий</a>
  <p>Указывает Redux middleware выполнить не блокирующий вызов переданной функции. Все форкнутые задачи прикреплены к своим родителям. Любая ошибка всплывает к родительской задаче. Если ошибка произошла родительская задача блокируется и не выполняется. Возвращает таску, к которой можно джоинится.</p>

  <h3>Spawn</h3>
  <a>Не блокирующий</a>
  <p>Позволяет создать паралельную задачу в корне саги, сам процесс не привязан к родителю.</p>

  <h3>Join</h3>
  <p>Заблокировать не блокирующую задачу и получить результат.</p>

    export function* workerSaga() {
    // бизнес логика

        const  task = yield fork(loadPeople)
        yield fork(loadPlanets)

        const people = yield join(task)
        
    }
  <h3>All</h3>
  <p>Запускает несколько эффектов параллельно и ждет их завершения</p>

  <h3>Apply</h3>
  <p>Вызывает функцию в контексте первого аргумента</p>

  

</div>
</details>


</br>


**Сборка, server side, deploy, загрузка, оптимизации**:

<details>
<summary>1. Коротко о Webpack?</summary>
<div>

  <h2>Что такое Webpack?</h2>
  <p>Webpack — это статический сборщик модулей. Его основная задача — пакетирование файлов JavaScript для использования в браузере, но он также способен преобразовывать, связывать и упаковывать практически любые ресурсы.</p>

  <p>Webpack используется затем, чтобы собрать все зависимости, которые включают не только код, но и другие ресурсы, и создать граф зависимостей. Сборщик может работать только с JS-файлами, поэтому webpack должен предварительно обработать все остальные файлы и ресурсы, прежде чем они попадут в пакет.</p>

  <h2>Что такое граф зависимостей в Webpack?</h2>

  <p>Если какой-либо файл зависит от любого другого типа файлов, таких как JavaScript, CSS /SCSS, а также некодовых ресурсов, таких как изображения, SVG, веб-шрифты и т. д. в вашем приложении, то webpack рассматривает его как зависимость.</p>

  <p>Когда webpack пакетирует приложение, он начинает с точки входа в файле webpack.config.js и рекурсивно строит граф зависимостей, который включает все зависимости, необходимые приложению. Он собирает их в один или несколько файлов в зависимости от потребностей, после чего они загружаются браузером.</p>

  <h2>Терминология:</h2>

  <h3>Plugins:</h3>
  <p>Дополнительный функционал добавляемый в виде классов к конфигу веб пака.</p>
  <p>Плагины являются основой веб-пакета. Сам Webpack построен на той же системе плагинов, которую вы используете в своей конфигурации webpack!  Они также служат для выполнения чего-либо еще, чего не может сделать загрузчик.</p>
  <p>Поскольку плагины могут принимать аргументы/параметры, вы должны передать новый экземпляр в свойство plugins в конфигурации вашего веб-пакета.</p>

     plugins: [
      new webpack.ProgressPlugin(),
      new HtmlWebpackPlugin({ template: './src/index.html' }),
    ],

  <h3>Loaders:</h3>
  <p>Webpack сам по себе знает только javascript и json, поэтому, когда мы хотим, чтобы он упаковывал ресурсы любого другого типа, такие как .css, .scss или .ts, webpack нуждается в помощи для компиляции и объединения этих типов ресурсов.</p>
  <p>Loaders — это утилиты node-based, созданные для webpack, чтобы помочь webpack скомпилировать и/или преобразовать определенный тип ресурса, который может быть объединен в виде модуля javascript.</p>

  <h4>css-loader:</h4>
  <p>это модуль npm, который поможет webpack собирать CSS из всех файлов css, на которые есть ссылки в вашем приложении, и помещать их в строку.</p>

  <h4>style-loader:</h4>
  <p>Заберет строку полученную из css-loader'a и положит ее внутрь тега style.</p>


  <h3>Rule:</h3>
  <p>Определяют какому  типу файлов, какой набор loader соотвествует. Обрабатываются снизу вверх (справа на лево)
  </p>
  <p>По имени файла (регулярка): Можно так же включать и исключать определенные директории (include/exclude).</p>

  <p>По имени issuer (того, кто запросил этот файл). Точно так же можно включать и исключать директории. Пример: если jpg файлик будет указан в css то issuer будет css файл. Тот кто его запросил, тот кому необходим итоговый файл.</p>

  <h3>Compiler и Compilation</h3>
  <p>Compiler движок который создает обьект Compilation с настройками, которые ему пришли из CLI или Node api.</p>

  <p>Compilation - обьект сборки. Имеет доступ ко всем модулям и их зависимостям. Проще говоря имеет доступ непосредственно к процессу сборки. Содержит достаточно большое число методов, с помощью которых плагины взаимодействуют с процессом компиляции.</p>

  <h3>Настройка optimization:</h3>
  <p>Позволяет управлять:</p>
  <ul>
    <li>Сжатием итогового бандла JS</li>
    <li>Разбивать bundle на chunks по определнным правилам.</li>
  </ul>
  <p>По-умолчанию настроен на:</p>
  <ul>
    <li>Удобную работу в dev-режиме</li>
    <li>Минимальный развер bundle в production-режиме</li>
  </ul>

  <h3>Mode:</h3>
  <p>Определяет режим работы webpack. Грубо говоря пресеты для определнных настроек. (Development, production, none)</p>



  <h3>devServer:</h3>
  <h4>Без devServer:</h4>

  <p>Невозможно сообщить браузеру, что изменился js или css.</p>

  <p>Постоянная перекомпиляция всего bundle.</p>
  <p>нагрузка на диск, рам  и процессор.</p>

  <h4>С devServer:</h4>
  <p>Автоматически обновляет страницу (либо ее часть) при изменении js, css, svg...</p>
  <p>Хранит все в оперативной памяти и не мучает ssd.</p>


  <img src="https://www.dotnetcurry.com/images/aspnet-core/aspnet-core3-spa/spa-dev-server.png?w=980&h=755" />


  <h3>HMR</h3>
  <p>HMR обменивает, добавляет или удаляет модули во время работы приложения без полной перезагрузки. Это может значительно ускорить разработку.</p>

  <h3>manifest.json</h3>
  <p>JSON файл со сгенерированными файлами , пишется на диск даже в dev режиме. </p>


  <h3>Output:</h3>
  <p>Задается вместо наших бандлов и ассетов и так далее. то есть то, куда будут сложены все выходные файлы.</p>


  <h3>Postcss:</h3>
  <p>CSS => PARSER CSS to AST (Делает обьекты) ====== (Предоставляет api сюда вставлять плаины) =====> Generator AST to CSS =>CSS</p>
  <p> Плагины например autoprefixer и cssnano (сжимает css обьем бандла станет меньше)</p>

    {
      test: /\.css$/,
      use: [
        {
          loader: MiniCssExtractPlugin.loader, // сжали  css
          options: {
            hmr: !env.production,
          },
        },
        {
          loader: 'css-loader', // загрузили css
          options: {
            sourceMap: true,
          },
        },
        {
          loader: 'postcss-loader',
          options: {
            plugins: [
              autoprefixer(), // добавили перфиксы
              cssnano(),   // сократили ксс за счет изменение синтаксиса
            ],
            sourceMap: true,
          },
        },
      ],
      }


  <h3>Source map</h3>
  <p>Позволяет видеть исходные код файла.</p>

  <h2>Пример конфигурации:</h2>

      const path = require('path');
      const webpack = require('webpack');
      // imports

      module.exports = env => ({
      entry: path.resolve('static/js/app.js'),
      devtool: 'source-map',
      output: {
        path: path.join(__dirname, 'www/static'),
        filename: '[name]-[hash].js',
        publicPath: '/static/',
      },
      module: {
        rules: [
          // rules
        ],
      },
      plugins: [
        // plugins
      ],
      optimization: {
        // optimization
      },
      });

<a href="https://medium.com/swlh/deep-dive-in-webpack-113dd6d39b33">Deep dive in WEBPACK</a>
</div>
</details>

<details>
<summary>2. Этапы загрузки web страницы?</summary>
<div>

  <p>Итак, пользователь вводит в адресной строке браузера адрес сайта и нажимает кнопку “Ввод”.</p>
  <h2>Поиск  ip адреса (DNS lookup.)</h2>
  <p>Чтобы сделать запрос по указанному URL, браузеру нужно знать IP сервера. Первым делом он смотрим в свой локальный кэш DNS.Компонент Browser Engine как раз имеет доступ к этому кэшу.</p>

  <a>В браузере Chrome локальный кэш DNS . доступен по ссылке chrome://net-internals/#dns</a>

  <p>Если там нет соответствующей записи, то браузер передаёт управление операционной системе, которая проверяет свой кэш DNS. Если и там отсутствует соответствующая запись, то ОС смотрит в локальные хосты (файл /etc/hosts в Unix-системах). Если запись о хосте отсутствует, то операционная система обращается к интернет провайдеру, у которого тоже есть свой кэш DNS на своих рекурсивных серверах DNS. В случае отсутствия записи в кэше на серверах DNS провайдера, запрос идёт на корневой DNS. У корневого DNS тоже есть кэш. Если соответствующей записи в кэше корневого DNS нет, запрос идёт дальше по цепочке серверов DNS.</p>
  <p>К примеру, если адрес нашего сайта site.com.ua, то запросы к DNS выглядят так: site.com.ua.: . (корневой DNS) -> ua (DNS зоны “ua”) -> com (DNS зоны “com”)-> site.</p>
  <p>Если на любом из этапов находится нужная запись, то она сохраняется во всех кэшах и управление возвращается браузеру, который уже знает IP нужного сервера.</p>

  <h2>Поиск страницы в кэше или запрос GET</h2>
  <p>Далее Browser Engine смотрит в локальном кэше, нет ли запрашиваемой страницы. Если страницы в кэше нет, то Browser Engine передаёт управление компоненту Rendering Engine, который обращается к компоненту Networking Component, чтобы тот сделал запрос GET на указанный IP на порт 80 по протоколу HTTP или на порт 443 по протоколу HTTPS (в зависимости от указанного протокола в URL) со своими стандартными HTTP заголовками. Среди стандартных заголовков есть заголовок host, в котором передаётся хост запрашиваемого сайта (в нашем примере site.com.ua). Если в браузере хранятся куки к этому домену, то он отправляет их в заголовке cookie. Запрос будет выполнен, если соответствующий порт на пользовательском компьютере открыт.</p>

    	
    GET / HTTP/1.1
    Host: vanseodesign.com
    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:50.0) Gecko/20100101 Firefox/50.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    Accept-Encoding: gzip, deflate
    Cookie: _ga=GA1.2.604372764.1484810328; PHPSESSID=7ip53s84rki0mn2rjae5bhin05; bp-activity-oldestpage=1
    Connection: keep-alive
    Upgrade-Insecure-Requests: 1
    Cache-Control: max-age=0

  <p>На сервере запрос принимает веб-сервер (например, nginx или apache).</p>

  <h2>Ответ от сервера</h2>
  <p>В конфигурационных файлах веб-сервера прописаны обслуживаемые хосты. Веб-сервер достаёт хост из заголовка запроса host и сопоставляет с теми, которые указаны в конфигурации. Если есть совпадение, то веб-сервер находит в конфигурационном файле правила обработки такого запроса и выполняет их.</p>

  <p>Приложение сгенирирует файл HTML и веб-сервер отдаст его браузеру.</p>

  <h2>Браузер получает HTML</h2>
  <p>Браузер получил файл HTML с соответствующими HTTP заголовками от сервера, в которых указана длина контента (заголовок Content-Length), тип контента (заголовок Content-Type со значением “text/html; charset=UTF-8” для файлов HTML), заголовки для кэширования. Если присутствуют кэширующие заголовки, то браузер сохраняет файл в локальный кэш.</p>

  <a>Заголовки ответа сервера можно увидеть в Chrome DevTools на вкладке Networking, выбрав нужный запрос</a>

  <p>Если длина контента больше нуля и тип контента поддерживается браузером, то браузер пытается его обработать. В нашем случае браузер получает файл HTML с соответствующим заголовком Content-Type. Браузер начинает разбор (parsing) этого файла с первой инструкции, которой является инструкция <!DOCTYPE>. DOCTYPE указывает на версию HTML, чтобы браузер понимал, каким правилам следовать во время разбора (какие теги как обрабатывать).</p>
  <p>Если DOCTYPE отсутствует, то браузер переключится в режим quirks mode и попытается разобрать документ HTML, однако многие элементы будут проигнорированы. Если указан корректный DOCTYPE, то браузер будет работать в standards mode и будет разбирать документ в соответствии с правилами той версии, которая указана в DOCTYPE.</p>


  <h2>Rendering Engine начинает разбор документа HTML.</h2>

  <p>Создаётся DOM (Document Object Model). В браузере этот объект доступен по ссылке, которая хранится в переменной document. У документа есть несколько состояний. Первое состояние — loading. Оно означает, что документ только начал формироваться.</p>  
  
  <a>Состояние документа хранится в переменной document.readyState.</a>
  <p>Также создаётся объект styleSheets, который будет хранить все стили.</p>
  <a>Все стили на странице доступны по ссылке, которая хранится в переменной document.styleSheets.</a>

  <p>Любой файл — это набор байтов. Браузер берёт полученный набор байтов и преобразует их в символы по таблице символов в соответствии с кодировкой, которая была передана в заголовке Content-Type. В нашем примере это кодировка UTF-8.</p>

  <p>Следующий процесс —разбивание текста на смысловые блоки (tokenization). Так браузер распознаёт теги <'html>, <'head> и проч., а также понимает, какие правила к какому тегу применять (например, поддерживаемые атрибуты).</p>

  <h2>Networking component и загрузка сторонних ресурсов</h2>
  <p>Во время разбора, если Rendering Engine встречает ссылку на внешний ресурс, то он передаёт команду загрузить этот ресурс компоненту Networking Component. Это может быть ссылка на стили, скрипты, картинки и т.п. Networking Component ставит все ресурсы в очередь на загрузку. Каждому ресурсу Networking Component присваивает приоритет.</p>

  <a>Приоритеты ресурсов можно посмотреть в Chrome DevTools на вкладке Networking в колонке Priority.</a>

  <p>Так, у HTML, CSS и шрифтов самый высокий приоритет. У изображений приоритет изначально низкий, но если Rendering Engine обнаружит, что изображение попадает в поле видимости (view port) пользователя, то повысит приоритет до среднего. Приоритет скрипта зависит от положения на странице и способа загрузки. У асинхронных скриптов (async/defer) низкий приоритет. У скриптов, которые в документе перед изображениями — высокий, у тех, что после хотя бы одного изображение — средний.</p>

  <p>По возможности браузер пытается загружать ресурсы параллельно. Однако, он не может загружать параллельно более 6 ресурсов с одного домена.</p>

  <h2>JavaScript Interpreter</h2>
  <p>Немного иначе происходит загрузка скрипта. Вместо того, чтобы вернуть управление Rendering Engine’у, Networking Component . передаёт управление JavaScript Interpreter, который преобразует байты в исполняемый код: байты -> символы -> токены -> Abstract Syntax Tree (evaluating). Далее в работу вступает компилятор, который оптимизирует AST, кэширует некоторые участки кода, компилирует его на лету (JIT compilation) в исполняемый код и исполняет (executing). Однако исполняется скрипт только, когда готова CSSOM. До тех пор скрипт стоит в очереди на исполнение.</p>


  <a>Во многих современных браузерах во время исполнения JavaScript в отдельном потоке продолжается сканирование документа на наличие ссылок на другие ресурсы и постановка ресурсов в очередь на скачивание (Speculative parsing).</a>

  <h2>DOMContentLoaded</h2>
  <p>Когда Rendering Engine заканчивает разбор документа, он вызывает событие DOMContentLoaded, и состояние документа меняется на interactive. При этом ресурсы (например, картинки) могут продолжать загружаться.</p>

  <p>Когда все ресурсы загрузились, вызывается событие load, а состояние документа меняется на complete.</p>

  <h2>Rendering sequence</h2>
  <h2>Render Tree</h2>

  <p>После того, как документ полностью разобран и сформированы DOM и CSSOM, Rendering Engine начинает построение Render Tree. В него попадут все элементы, которые нужно отрисовать. Некоторые элементы изначально могут быть невидимыми — их не нужно рисовать. Для каждого элемента, который “выпадает” из потока (например, используется position: absolute), будет создаваться отдельная ветка в Render Tree.
  Во время Rendering Tree происходит сопоставление узлов из DOM и узлов CSSOM.</p>

  <h3>Layout Operation</h3>
  <p>Первый делом браузер создает layout каждого отдельного узла Render-Tree. Макет состоит из размера каждого узла в пикселях и того, где (положение) он будет напечатан на экране. Этот процесс называется layout, поскольку браузер вычисляет информацию о layout каждого узла.</p>
  <p>Этот процесс также называется reflow или browser reflow, и он также может происходить при прокрутке, изменении размера окна или манипуляции элементами DOM.</p>

  <p><b>Reflow: </b> вычисляет макет страницы. Reflow элемента повторно вычисляет размеры и положение элемента, а также запускает дальнейшие reflow дочерних элементов, предков и элементов, которые появляются после него в DOM. Затем он вызывает окончательную repaint. Reflowing очень дорог, но, к сожалению, его легко запустить.</p>

  <h3>Paint Operation</h3>
  <p>До сих пор у нас был список геометрий, которые необходимо вывести на экран. Поскольку элементы (или поддерево) в Render-Tree могут накладываться друг на друга, и они могут иметь свойства CSS, которые заставляют их часто менять внешний вид, положение или геометрию (например, анимацию), браузер создает для них layer.</p>

  <p>Создание слоев помогает браузеру эффективно выполнять операции painting на протяжении всего жизненного цикла веб-страницы, например, при прокрутке или изменении размера окна браузера. Наличие слоев также помогает браузеру правильно отображать элементы в порядке наложения (вдоль оси Z), как это было задумано разработчиком.</p>

  <p>Каждый layer отрисовывается по отдельности</p>

  <p>Внутри каждого слоя браузер заполняет отдельные пиксели для любого видимого свойства элемента, такого как граница, цвет фона, тень, текст и т. д. Этот процесс также называется растеризацией. Для повышения производительности браузер может использовать разные потоки для выполнения растеризации.</p>

  <h3>Compositing Operation</h3>
  <p>До сих пор мы не нарисовали ни одного пикселя на экране. У нас есть разные слои (bitmap изображения), которые должны отображаться на экране в определенном порядке. В операциях компоновки эти слои отправляются на GPU, чтобы окончательно отобразить их на экране.</p>

  <p>Отправка целых слоев на отрисовку явно неэффективна, потому что это должно происходить каждый раз, когда происходит перекомпоновка (макет) или перерисовка. Следовательно, слой разбивается на разные tiles, которые затем будут отображаться на экране.</p>

  <h3>Critical Rendering path</h3>
  <img src="https://miro.medium.com/max/700/1*yQJkz12sPxS-kJoMDqzbEQ.png" />


  <h2>Доп. информация:</h2>
  <p>В современных браузерах скачивание документа, его разбор и отрисовка происходят по кускам, частями.</p>

  <p>В документе HTML могут присутствовать некоторые мета-теги, которые могут менять порядок загрузки ресурсов, а также их приоритет.</p>

  <p>К примеру, мета-тег dns-prefetch вынуждает Rendering Engine обратиться к Networking Component и получить IP нужного домена ещё до того, как Rendering Engine встретить его в документе.</p>

  <p>Мета-тег prefetch вынудит Networking Component поставить указанный ресурс в очередь на загрузку с низким приоритетом.</p>
  
  <p>Мета-тег preload вынудит Networking Component поставить указанный ресурс в очередь на загрузку с высоким приоритетом.</p>

  <p>Мета-тег preconnect вынудит Networking Component заранее подключиться к другом хосту, то есть пройти нужные этапы: DNS lookup, redirects, hand shakes.</p>

  <a>Время, которое затрачивается на каждый этап, происходящий во время запроса и разбора документа HTML, хранится в объекте performance.timing.</a>


</div>
</details>


<details>
<summary>3. Что такое NGIX web-server?</summary>
<div>
  <p>NGINX, произносится как «engine-ex», был официально выпущен в октябре 2004 года. Создатель программного обеспечения Игорь Сысоев начал свой проект в 2002 году как попытку решить проблему C10k. C10k — это задача одновременного управления десятью тысячами подключений.</p>

  <h2>Как работает NGINX?</h2>
  <p>Когда пользователь совершает действие на странице, информация передается на сервер. Он находит файлы, передает сведения.</p>

  <p>Если обрабатывать запросы каждого пользователя по отдельности, серверу придется одновременно выполнять много процессов. Сайт начнет работать медленно. Nginx позволяет обойти ограничение. Его архитектура асинхронная: все запросы обрабатываются на разных этапах, что повышает скорость обработки.</p>

  <p>Запросы от одного пользователя разбиваются на маленькие структуры — сетевые соединения. Обработка происходит быстрее: за однотипные действия отвечает один процесс. После обработки соединения собираются в одном виртуальном контейнере, чтобы преобразоваться в единый первоначальный запрос, а затем отправляются пользователю. Благодаря такому принципу работы Nginx одно сетевое соединение может обслуживать до 1024 запросов.</p>

  <img src="https://blog.skillfactory.ru/wp-content/uploads/2021/12/image1-9013741.png" />

  
</div>
</details>




<details>
<summary>4. Deploy React приложения?</summary>
<div>
  <h2>Пример docker файла:</h2>

      # stage1 as builder
      FROM node:10-alpine as builder

      # copy the package.json to install dependencies
      COPY package.json package-lock.json ./

      # Install the dependencies and make the folder
      RUN npm install && mkdir /react-ui && mv ./node_modules ./react-ui

      WORKDIR /react-ui

      COPY . .

      # Build the project and copy the files
      RUN npm run build


      FROM nginx:alpine

      #!/bin/sh

      COPY ./.nginx/nginx.conf /etc/nginx/nginx.conf

      ## Remove default nginx index page
      RUN rm -rf /usr/share/nginx/html/*

      # Copy from the stahg 1
      COPY --from=builder /react-ui/build /usr/share/nginx/html

      EXPOSE 3000 80

      ENTRYPOINT ["nginx", "-g", "daemon off;"] 

  <h2>Пример конфигурации nginx.conf</h2>  

    worker_processes 4;

    events { worker_connections 1024; }

    http {
        server {
            listen 80;
            root  /usr/share/nginx/html;
            include /etc/nginx/mime.types;

            location /appui {
                try_files $uri /index.html;
            }
        }
    }

  <h2>Stage 1</h2>
  <p>Мы используем node:10-alpine в качестве базового образа для stage1 и копируем package.json для установки всех зависимостей. Затем мы копируем оставшийся проект позже, таким образом, мы можем пропустить установку зависимостей каждый раз, когда в файлах происходят изменения. Docker использует кеш для создания образа из существующих слоев, если нет изменений.</p>
  <p>Мы собираем проект с помощью react scripts, и все собранные статические файлы помещаются в папку /build.</p>

  <h2>Stage 2</h2>
  <p>Stage 2 начинается с базового образа nginx:alpine и копирования файла nginx.conf, удаления индексного файла из корневого каталога и, наконец, копирования всех файлов из stage 1 в корневой каталог, откуда он может обслуживать контент.</p>



</div>
</details>


<details>
<summary>5. Cache Control for React App?</summary>
<div>
  <h2>Common Deployment</h2>
  <p>После сборки приложения мы можем просто использовать Nginx, чтобы указать на статические файлы.</p>

    server {
      listen 80;
      root /PATH/TO/APP/build;
      try_files $uri $uri/ /index.html;
    }

  <h2>Cache Issue</h2>
  <p>При доступе к странице в первый раз все страницы и ресурсы находятся на сервере, как показано на следующем изображении:</p>
  <img src="https://res.cloudinary.com/practicaldev/image/fetch/s--glW9yzr---/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://chanvinxiao.com/cn/blog/cache-control-for-react-app-with-nginx/fresh.png" />

  <p>Закройте браузер, затем снова откройте, введите адрес, нажмите Enter, браузер получит кэш из локального, как показано на следующем изображении:</p>

  <img src="https://res.cloudinary.com/practicaldev/image/fetch/s--n_vrOr_6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://chanvinxiao.com/cn/blog/cache-control-for-react-app-with-nginx/cache.png" />

  <p>Даже если страница была обновлена ​​между двумя запросами, браузер не получит обновление с сервера, так как disk cache не взаимодействует с сервером.</p>

  <h2>Solution</h2>
  <p>Если файл ресурсов будет обновлен, имя файла изменится, поэтому кеш ресурса не будет проблемой, нам просто нужно отключить кеш страницы</p>

  <p>Заменим:</p>

    try_files $uri $uri/ /index.html;

  <p>на</p>

     location / {
        if ( $uri = '/index.html' ) {
          add_header Cache-Control no-store always;
        }
        try_files $uri $uri/ /index.html;
      }

  <ul>
    <li>Поскольку все страницы в конечном итоге указывают на входной файл, поэтому все фактические $uri являются /index.html для страниц.</li>
    <li>no-store — самое строгое значение для Cache-Control для отключения кеша, чтобы убедиться, что браузер не будет использовать кеш.</li>
    <li>Поскольку add_header с if нельзя разместить непосредственно внутри сервера, нам нужно добавить слой местоположения</li>
  </ul>    

  <h2>Result</h2>
  <p>Таким образом, когда мы запрашиваем страницу во второй раз, страница не будет кэшироваться, но ресурсы будут кэшироваться, если не будет изменений, как показано на следующем изображении:</p>

  <img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ctKcZGrc--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://chanvinxiao.com/cn/blog/cache-control-for-react-app-with-nginx/index.png" />

  <h2>Итого</h2>
  <ul>
    <li>Странная проблема с кешем возникнет, когда вы введете адрес и нажмете Enter в браузере</li>
    <li>Мы можем определить, является ли запрос страницей через $uri Nginx.</li>
    <li>Заголовок Cache Control можно установить через add_header Nginx.</li>
  </ul>

  <h2>Cache-control:</h2>
  <p>С помощью указанных ниже значений заголовка Cache-Control можно точно указать, где и каким образом следует кэшировать URL-адреса без сведений о версиях.</p>
  <ul>
    <li>no-cache. Это значение указывает браузеру, что он должен выполнять проверку на сервере каждый раз перед использованием кэшированного контента для соответствующего URL-адреса.</li>
    <li>no-store. Это значение указывает браузеру и другим промежуточным кэшам (например, CDN) никогда не сохранять никакие версии файла.</li>
    <li>private. Браузерам разрешено кэшировать файл, а промежуточным кэшам — нет.</li>
    <li>public. Ответ можно хранить в любом кэше.</li>
  </ul>
</div>
</details>


<details>
<summary>6. Cookie, localStorage, sessionStorage?</summary>
<div>
  <h2>Появление cookie</h2>
  <p>Так появились cookie. Они представили механизм для хранения легковесных клиентских или серверных данных в браузере в виде пар ключ-значение. У них также была метка времени истечения срока действия, после которой они автоматически удалялись браузером.</p>

  <p>Кроме того, и браузер, и сервер могут устанавливать и получать файлы cookie из браузера пользователя. Более того, эти файлы cookie автоматически отправлялись вместе с каждым HTTP-запросом. Это было удобно для веб-сайтов на стороне сервера в то время, когда одностраничные приложения не были чем-то особенным. Они могли легко распознать информацию о пользователе в каждом сделанном пользователем HTTP-запросе.</p>

  <h2>Появление Browser Storage</h2>
  <p>Там, где файлы cookie решали большую проблему, у них были некоторые ограничения. Во-первых, они могли хранить данные только до нескольких КБ. Поскольку клиентские приложения становились все более сложными, возникла необходимость хранить более сложные данные в браузере.</p>
  
  <p>С появлением HTML5 веб-сайты были представлены API-интерфейсам хранилища браузера для хранения информации на стороне клиента. Эти API были доступны для window объектов браузера по всему миру. Таким образом, любой JavaScript, работающий в браузере, может легко получить к ним доступ. Основным отличием было то, что они имели большую емкость для хранения данных и могли быть доступны только для клиентского JavaScript.</p>

  <h2>Session Storage</h2>

  <h3>Capacity</h3>
  <p>Хранилище сеансов может хранить данные в диапазоне от 5 МБ до 10 МБ. Точный объем хранилища зависит от реализации каждого браузера, но это намного больше чем cookie =  4 КБ!</p>
  
  <h3>Data persistence</h3>
  <p>Как следует из названия, хранилище сеансов сохраняет данные только до тех пор, пока открыта вкладка браузера. Это означает, что каждый раз, когда вы открываете новую вкладку или новое окно браузера, создается новое хранилище сеансов. Таким образом, любые данные, которые вы храните в хранилище сеансов, будут автоматически удалены, когда вы закроете эту вкладку/окно.</p>

  <h3>Usecases</h3>
  <a>Booking applications</a>
  <p>Хранилище сеансов можно использовать в многоэтапных процессах, которые должны выполняться в одном экземпляре. Это включает в себя бронирование авиабилетов, отелей, билетов в кино, бронирование поездов и т. д. Вы можете сохранить детали предыдущих шагов в хранилище сеансов браузера для предварительного заполнения этих форм или входных данных.</p>

  <p>Поскольку это важные действия, которые необходимо выполнить за один раз, данные будут автоматически удалены, когда пользователь перейдет на новую вкладку или в новое окно браузера.</p>

  <h2>Local Storage</h2>

  <h3>Data persistence</h3>
  <p>В отличие от session storage, где данные автоматически удаляются при закрытии вкладки или окна браузера, данные в локальном хранилище не имеют срока действия по умолчанию. Они удаляются только в том случае, если вы вручную удаляете эти данные из локального хранилища напрямую, через настройки браузера или с помощью кода JavaScript.</p>

  <p>Это означает, что данные в локальном хранилище сохраняются даже после   закрытия определенной вкладки или окна браузера.</p>

  <h3>UseCase:</h3>
  <p>Например, идентификатор электронной почты вашего пользователя, имя пользователя, полное имя и т. д. Все эти данные широко используются на разных страницах вашего приложения. Хранение этих данных в локальном хранилище поможет вам предотвратить нежелательные вызовы API на сервер для извлечения этих данных. Кроме того, поскольку эти данные обычно не изменяются часто, вероятность несогласованности данных в браузере и на сервере довольно низка.</p>

  <p>Вы также можете использовать его для хранения конкретных данных приложения, которые неизменяемы на протяжении всего сеанса входа пользователя. Например, если у вас есть сайт электронной коммерции, вы можете сохранить предпочтительный способ оплаты пользователя, адреса доставки по умолчанию и т. д. Вы также можете сохранить пользовательские настройки, такие как тема, которую пользователь предпочитает для вашего сайта (темный или светлый режим).</p>

  <h2>Cookies vs. Browser Storage</h2>
  <h3>Similarities</h3>
  <p>Другими словами, файлы cookie могут быть заблокированы пользователями, как и хранилище браузера. Пользователи могут запретить хранение своих данных с помощью любого из этих механизмов — и, следовательно, ваше приложение никогда не должно полностью полагаться на эти механизмы хранения.</p>

  <p>И файлы cookie, и хранилище браузера хранят пары ключ-значение в виде строк и хорошо поддерживаются во всех современных браузерах. Данные внутри этого также могут быть легко отредактированы пользователем.</p>

  <h3>Differences</h3>
  <p>Вы знаете, что хранилище браузера имеет больший объем, чем файлы cookie. Следовательно, хранилище браузера всегда лучше, чем файлы cookie, для хранения больших данных на стороне клиента.</p>

  <p>Однако, поскольку хранилище сеанса и локальное хранилище имеют разную сохраняемость данных, вам следует тщательно выбирать любое из них в зависимости от того, как долго вы хотите, чтобы данные сохранялись.</p>

  <p>Файлы cookie позволяют автоматически устанавливать TTL или срок действия; передаются с каждым HTTP-запросом на сервер; и также могут быть доступны серверу. Эти функции отсутствуют в хранилище браузера. Это подводит нас к вопросу — где файлы cookie могут быть на самом деле полезнее, чем хранилище браузера?</p>

  <img src="https://www.loginradius.com/blog/static/a6522d000e0137d5fdf82fd370646d12/e5715/comparison-table.png" />

  <h3>Storing Your JWT/Auth Token</h3>
  <p>Такие данные, как JWT или токен аутентификации, не должны храниться в хранилище браузера, поскольку к ним может получить доступ любой клиентский JavaScript, запущенный в браузере. Это означает, что если ваше приложение каким-то образом оставит уязвимость XSS, токен аутентификации вашего пользователя может быть легко передан злоумышленнику.</p>

  <p>Затем злоумышленник может сделать ложные запросы, изменить данные вашего пользователя в базе данных и нанести большой ущерб как вашему приложению, так и пользователям. Следовательно, всегда лучше хранить JWT только в файлах cookie http. Файлы cookie только для HTTP — это специальные файлы cookie, к которым клиентский JavaScript не может получить доступ. Таким образом, они защищены от XSS-атак.</p>

  <p>Кроме того, токен аутентификации часто обновляется по истечении срока действия, и для этого можно легко использовать файлы cookie TTL. Для более простых случаев можно также хранить JWT внутри обычных файлов cookie, установив TTL.</p>

</div>
</details>


<br/>

**Веб - технологии**:

<details>
  <summary>1. Что такое HTTP?</summary>
  <div>
    <p>
      Протокол передачи гипертекста (Hypertext Transfer Protocol - HTTP) - это прикладной протокол для передачи гипертекстовых документов, таких как HTML. Он создан для связи между веб-браузерами и веб-серверами, хотя в принципе HTTP может использоваться и для других целей. Протокол следует классической клиент-серверной модели, когда клиент открывает соединение для создания запроса, а затем ждет ответа. HTTP - это протокол без сохранения состояния, то есть сервер не сохраняет никаких данных (состояние) между двумя парами "запрос-ответ". Несмотря на то, что HTTP основан на TCP/IP, он также может использовать любой другой протокол транспортного уровня с гарантированной доставкой.
    </p>
    <p>
      Ниже перечислены общие функции, управляемые с HTTP:
    </p>
    <ul>
      <li>
        <b>Кэш.</b> Сервер может инструктировать прокси и клиенты: что и как долго кэшировать. Клиент может инструктировать прокси промежуточных кэшей игнорировать хранимые документы.
      </li>
      <li>
        <b>Ослабление ограничений источника.</b> Для предотвращения шпионских и других, нарушающих приватность, вторжений, веб-браузер обчеспечивает строгое разделеление между веб-сайтами. Только страницы из того же источника могут получить доступ к информации на веб-странице. Хотя такие ограничение нагружают сервер, заголовки HTTP могут ослабить строгое разделение на стороне сервера, позволяя документу стать частью информации с различных доменов (по причинам безопасности).
      </li>
      <li>
        <b>Аутентификация.</b> Некоторые страницы доступны только специальным пользователям. Базовая аутентификация может предоставляться через HTTP, либо через использование заголовка WWW-Authenticate и подобных ему, либо с помощью настройки спецсессии, используя куки.
      </li>
      <li>
        <b>Прокси и тунелирование.</b> Серверы и/или клиенты часто располагаются в интранете, и скрывают свои истинные IP-адреса от других. HTTP запросы идут через прокси для пересечения этого сетевого барьера. Не все прокси -- HTTP прокси. SOCKS-протокол, например, оперирует на более низком уровне. Другие, как, например, ftp, могут быть обработаны этими прокси.
      </li>
      <li>
        <b>Сессии.</b> Использование HTTP кук позволяет связать запрос с состоянием на сервере. Это создает сессию,  хотя ядро HTTP -- протокол без состояния.  Это полезно не только для корзин в интернет-магазинах, но также для любых сайтов, позволяющих пользователю настроить выход.
      </li>
    </ul>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/Overview">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>2. Из чего состоит HTTP-запрос?</summary>
  <div>
    <img src='https://mdn.mozillademos.org/files/13687/HTTP_Request.png' />
    <p>
      Запросы содержат следующие элементы:
    </p>
    <ul>
      <li>
        HTTP-метод, обычно глагол подобно GET, POST или существительное, как OPTIONS или HEAD, определяющее операцию, которую клиент хочет выполнить. Обычно, клиент хочет получить ресурс (используя GET) или передать значения HTML-формы (используя POST), хотя другие операция могут быть необходимы в других случаях.
      </li>
      <li>
        Путь к ресурсу: URL ресурсы лишены элементов, которые очевидны из контекста, например без protocol (http://), domain (здесь developer.mozilla.org), или TCP port (здесь 80).
      </li>
      <li>
        Версию HTTP-протокола.
      </li>
      <li>
        Заголовки  (опционально), предоставляюшие дополнительную информацию для сервера.
      </li>
      <li>
        Или тело, для некоторых методов, таких как POST, которое содержит отправленный ресурс.
      </li>
    </ul>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/Overview">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>3. Какие методы может иметь HTTP-запрос?</summary>
  <div>
    <p>
      HTTP определяет множество методов запроса, которые указывают, какое желаемое действие выполнится для данного ресурса. Несмотря на то, что их названия могут быть существительными, эти методы запроса иногда называются HTTP глаголами. Каждый реализует свою семантику, но каждая группа команд разделяет общие свойства: так, методы могут быть безопасными, идемпотентными или кэшируемыми.
    </p>
    <ul>
      <li>
        <b>GET</b> запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.
      </li>
      <li>
        <b>HEAD</b> запрашивает ресурс так же, как и метод GET, но без тела ответа.
      </li>
      <li>
        <b>POST</b> используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.
      </li>
      <li>
        <b>PUT</b> заменяет все текущие представления ресурса данными запроса.
      </li>
      <li>
        <b>DELETE</b> удаляет указанный ресурс.
      </li>
      <li>
        <b>CONNECT</b> устанавливает "туннель" к серверу, определённому по ресурсу.
      </li>
      <li>
        <b>OPTIONS</b> используется для описания параметров соединения с ресурсом.
      </li>
      <li>
        <b>TRACE</b> выполняет вызов возвращаемого тестового сообщения с ресурса.
      </li>
      <li>
        <b>PATCH</b> используется для частичного изменения ресурса.
      </li>
    </ul>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>4. Что такое Cross-Origin Resource Sharing (CORS)?</summary>
  <div>
    <p>
      Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.
    </p>
    <b>Правило одинакового источника (Same-Origin Policy)</b>
    <p>В веб внедрено так называемое правило одинакового источника. По умолчанию мы можем получить доступ к ресурсам только в том случае, если источник этих ресурсов и источник запроса совпадают. К примеру, мы сможем без проблем загрузить изображение, которое находится по адресу https://mywebsite.com/image1.png.</p>
    <p>CORS же появился с целью смягчения политики одинакового источника и для тонкой настройки доступа между различными источниками.</p>
    <h2>CORS на стороне клиента</h2>
    <p>Несмотря на то, что правило одинакового источника применяется исключительно к скриптам, браузеры распространили его и на JavaScript-запросы: по умолчанию можно получить доступ к ресурсам только из одинакового источника.</p>
    <p>Пользовательские агенты (к примеру, браузеры) на основе значений определённых заголовков для CORS в HTTP-запросе могут проводить запросы к другим источникам, которые без CORS были бы заблокированы.
    Когда происходит запрос к другому источнику, клиент автоматически подставляет дополнительный заголовок Origin в HTTP-запрос. Значение этого заголовка отражает источник запроса.</p>
    <img src="https://miro.medium.com/max/1400/1*KNH5jryBsY8h9ksnWBlOiA.gif" />
    <p>Чтобы браузер разрешил доступ к ресурсам из другого источника, он должен получить определённые заголовки в ответе от сервера, которые указывают, разрешает ли сервер запросы из других источников.</p>
    <h2>CORS на стороне сервера</h2>
    <p>Разрабатывая бэкенд, мы, чтобы разрешить запросы из других источников, можем добавить в HTTP-ответ дополнительные заголовки, начинающиеся с Access-Control-*. На основе значений этих CORS-заголовков браузер сможет разрешить определённые запросы из других источников, которые обычно блокируются правилом одинакового источника.</p>
    <p>Существует несколько CORS-заголовков, но браузеру нужен всего один из них, чтобы разрешить доступ к ресурсам из разных источников —Access-Control-Allow-Origin. Его значение определяет, из каких источников можно получить доступ к ресурсам на сервере.</p>
    <p>Если мы создаём сервер, к которому должен иметь доступ сайт https://mywebsite.com, то нужно внести этот домен в значение заголовка Access-Control-Allow-Origin.
    </p>
    <img src="https://miro.medium.com/max/1400/1*2IdKp2ag8-iycExxmydziA.gif" />
    <p>Ещё один довольно распространённый заголовок — Access-Control-Allow-Methods. С ним будут разрешены только те запросы из других источников, которые выполнены с применением перечисленных методо</p>
    <img src="https://miro.medium.com/max/1400/1*7YU9Ds4ljJqUNLM7coZCww.gif" />
    <p>
      В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, XMLHttpRequest и Fetch API следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки.
    </p>
    <p><i>Источник: <a href ="https://developer.mozilla.org/ru/docs/Web/HTTP/CORS">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>5. Что такое HTTP cookie и для чего их используют?</summary>
  <div>
    <p>
      HTTP cookie (web cookie, cookie браузера) - это небольшой фрагмент данных, отправляемый сервером на браузер пользователя, который тот может сохранить и отсылать обратно с новым запросом к данному серверу. Это, в частности, позволяет узнать, с одного ли браузера пришли оба запроса (например, для аутентификации пользователя). Они запоминают информацию о состоянии для протокола HTTP, который сам по себе этого делать не умеет.
    </p>
    <p>
      Cookie используются, главным образом, для:
    </p>
    <ul>
      <li>
        Управления сеансом (логины, корзины для виртуальных покупок)
      </li>
      <li>
        Персонализации (пользовательские предпочтения)
      </li>
      <li>
        Мониторинга (отслеживания поведения пользователя)
      </li>
    </ul>
    <p>
      Получив HTTP-запрос, вместе с откликом сервер может отправить заголовок  Set-Cookie с ответом. Cookie обычно запоминаются браузером и посылаются в значении заголовка HTTP  Cookie с каждым новым запросом к одному и тому же серверу. Можно задать срок действия cookie, а также срок его жизни, после которого cookie не будет отправляться. Также можно указать  ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту  оно отсылается.
    </p>
    <p>
      Куки можно создавать через JavaScript при помощи свойства Document.cookie. Если флаг HttpOnly не установлен, то и доступ к существующим cookies можно получить через JavaScript.
    </p>

      document.cookie = "yummy_cookie=choco"; 
      document.cookie = "tasty_cookie=strawberry";
   <p><i>Источник: <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/%D0%9A%D1%83%D0%BA%D0%B8">developer.mozilla.org</a></i></p>
  </div>
</details>

<details>
  <summary>6. Что такое XSS-уязвимость?</summary>
  <div>
    <p>
      XSS (англ. Cross-Site Scripting — «межсайтовый скриптинг») — довольно распространенная уязвимость. Ее суть довольно проста, злоумышленнику удается внедрить на страницу JavaScript-код, который не был предусмотрен разработчиками. Этот код будет выполняться каждый раз, когда жертвы (обычные пользователи) будут заходить на страницу приложения, куда этот код был добавлен. А дальше существует несколько сценариев развития.
    </p>
    <ul>
      <li>
       1. злоумышленнику удастся заполучить авторизационные данные пользователя и войти в его аккаунт.
      </li>
      <li>
       2. злоумышленник может незаметно для жертвы перенаправить его на другую страницу-клон. Эта страница может выглядеть совершенно идентично той, на которой пользователь рассчитывал оказаться. Но вот принадлежать она будет злоумышленнику. Если пользователь не заметит подмены и на этой странице введет какие-то sensitive data, то есть личные данные, они окажутся у злоумышленника.
      </li>
    </ul>
    <p>Устройство уязвимости:</p>
    <p>
     Например, можно добавить JavaScript-код в поле ввода, текст из которого сохраняется и в дальнейшем отображается на странице для всех пользователей. Это может быть поле для ввода информации о себе на странице профиля социальной сети или комментарии на форуме.
    </p>
    <p>Суть в том, что браузер не может самостоятельно отличить обычный текст от текста, который является CSS, HTML или JavaScript-кодом. Он будет пытаться обрабатывать все, что находится между тегами <'script>, как JavaScript-код. Все, что находится между тегами <'style>, считать CSS. И все, что похоже на тег, считать HTML-кодом.</p>
    <p>Если разработчик хочет, чтобы какой-то текст только выглядел как код, но таковым не являлся (то есть не обрабатывался браузером, а выводился как есть), этот текст надо специально обработать прежде, чем отдать его браузеру. Такая обработка называется “экранированием”.</p>
    <p>Еще причина может быть в том, что уязвимость находится не в коде самого разработчика, а в коде библиотеки, которую он использует. Обычно это какие-то готовые фреймворки для создания веб-сервисов. В таком случае разработчик, конечно, может даже не подозревать то, что подключая к проекту этот фреймворк, он автоматически подключает к нему же уже готовую уязвимость.</p>
    <h3>Предотвращение JS-инъекций</h3>
    <p>В современных фреймворках (вроде Angular/React) изначально действует санитизация, которую в случае необходимости (если вы хотите запустить inline-скрипт из строки и уверены, что там не содержится ничего вредоносного) можно отключить. В React’е это делается посредством атрибута, подчеркивающего опасность вставки inline-скриптов: </p>
    <img src="https://media.tproger.ru/uploads/2021/07/Screenshot-2021-06-04-at-11.07.27-1760x847.png"/>
  </div>
</details>

<details>
  <summary>7. Что такое SOLID (объектно-ориентированное программирование)?</summary>
  <div>
    <br/>
    <p>
      SOLID (сокр. от англ. single responsibility, open-closed, Liskov substitution, interface segregation и dependency inversion) в программировании — мнемонический акроним, введённый Майклом Фэзерсом (Michael Feathers) для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов объектно-ориентированного программирования и проектирования. Принципы SOLID — это руководства, которые также могут применяться во время работы над существующим программным обеспечением для его улучшения - например для удаления «дурно пахнущего кода».
    </p>
    <p>
      Избавиться от "признаков плохого проекта" помогают следующие пять принципов SOLID:
    </p>
    <ul>
      <li>
        <b>S</b> -  <p>Принцип единственной ответственности (The Single Responsibility Principle) каждый копмпонент решает только одну задачу.</p>
        <p>Компонент имеет принцип единственной отвественности в том случае если всего один причина для изменения. </p>
      </li>
      <li>
        <b>O</b> - Принцип открытости/закрытости (The Open Closed Principle) «программные сущности должны быть открыты для расширения, но закрыты для модификации.» 
        <p>Каплинг (coupling) понятие основанное на уровне связанности компонентов. Выделяются два тип: </p>
        <p>Сильная связь (Tight coupling) - когда компоненты знают много деталей друг о друге.</p>
        <p>Слабая связь (Loose coupling) - когда компоненты мало знают о друг друге или не знают совсем (малое количество точек связи между компонентами).</p>
        <p>Слабая связь дает следующие плюсы:</p>
        <ul>
          <li>
            <p>Позволяют изменять одну часть приложения не оказывая влияния на остальные</p>
          </li>
          <li>  
            <p>Любой компонент может быть заменен альтернативным</p>
          </li>
          <li>  
            <p>Позволяют переиспользовать компоненты во всем приложении, таким образом отдавая предпочтение принципу "не повторяться"</p>
          </li>
          <li>  
            <p>Не зависимые компоненты проще тестировать, тем самым увеличивается покрытие кода тестами</p>
          </li>
        </ul>
        <li>
          <b>L</b> - Принцип подстановки Барбары Лисков (The Liskov Substitution Principle) «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.» См. также контрактное программирование. Наследующий класс должен дополнять, а не изменять базовый.
        </li>
        <li>
          <b>I</b> - Принцип разделения интерфейса (The Interface Segregation Principle) «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»
        </li>
      <li>
        <b>D</b> - Принцип инверсии зависимостей (The Dependency Inversion Principle)
        <p>A. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.</p>
        <p>B. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</p>
        <p>Принцип инверсии зависимостей или DIP относится к особой форме разделения программных модулей. При следовании этому принципу обычные отношения зависимости, установленные от высокоуровневых модулей, к низкоуровневым модулям зависимостей меняются местами.</p>
        <p>В общем, это указывает на разъединение элементов путем предоставления их зависимостей извне, вместо того, чтобы создавать их напрямую, что создавало бы сцепление.</p>
        <p>Еще одна реализация внедрения зависимостей в JavaScript — это модули ES6 с возможностью использовать и инкапсулировать один и тот же код, а затем импортировать его туда, где он нам нужен.</p>
        <p>В JavaScript у нас нет интерфейсов, но мы можем добиться аналогичного поведения, используя инкапсуляцию модулей: например, экспортируя класс или метод.</p>
        <a href="https://carstenbehrens.com/dependency-inversion-principle/">Dependency Inversion Principle in JavaScript and TypeScript</a>
      </li>
    </ul>
  </div>
</details>
  
<details>
  <summary>8. Что такое Babel и для чего он используется?</summary>
  <div>
    <br/>
    <p>
      Babel.JS – это транспайлер, переписывающий код на ES-2015 в код на предыдущем стандарте ES5.
    </p>
    <p>
      Обычно Babel.JS работает на сервере в составе системы сборки JS-кода (например webpack или brunch) и автоматически переписывает весь код в ES5.
    </p>
    <p>
      Настройка такой конвертации тривиальна, единственно – нужно поднять саму систему сборки, а добавить к ней Babel легко, плагины есть к любой из них.
    </p>
    <p>
      Конфигурация Babel прописывается в файле babel.config.js, либо в .babelrc для настроек одного пакета, а также в package.json или .babelrc.js
    </p>
    <p>
    Пример конфига в babel.config.js:
      
      module.exports = function (api) {
        api.cache(true);

        const presets = [ ... ];
        const plugins = [ ... ];

        return {
          presets,
          plugins
        };
      }
   </p>
   <p>Полифил — это фрагмент кода (в сети — обычно JavaScript), который позволяет использовать современную функциональность в более старых браузерах, которые не поддерживают ее по умолчанию.</p>
   <p>Это компиляторы исходного кода, которые представляют собой инструменты, которые считывают исходный код, написанный на одном языке программирования, и создают эквивалентный код на другом языке.</p>

   <p>Языки, которые вы пишете и которые транспилируются в JavaScript, часто называют языками компиляции в JS, и говорят, что они ориентированы на JavaScript.</p>
    <p>
     <i>
       Источник: 
        <a href="https://learn.javascript.ru/es-modern-usage#babel-js">learn.javascript.ru</a>, 
        <a href="https://babeljs.io/docs/en/next/configuration">babeljs.io</a>
     </i>
    </p>
  </div>
</details>

<details>
  <summary>9. Для чего используется WebSocket? В чем принцип его работы?</summary>
  <div>
    <br/>
    <p>
      Протокол WebSocket («веб-сокет»), описанный в спецификации RFC 6455, обеспечивает возможность обмена данными между браузером и сервером через постоянное соединение. Данные передаются по нему в обоих направлениях в виде «пакетов», без разрыва соединения и дополнительных HTTP-запросов.
    </p>
    <p>
      Чтобы открыть веб-сокет-соединение, нам нужно создать объект new WebSocket, указав в url-адресе специальный протокол ws:
      <code>
        let socket = new WebSocket("ws://javascript.info");
      </code>
    </p>
    <p>
      Как только объект WebSocket создан, мы должны слушать его события. Их всего 4:
    </p>
    <ul>
      <li>
        <b>open</b> – соединение установлено,
      </li>
      <li>
        <b>message</b> – получены данные,
      </li>
      <li>
        <b>error</b> – ошибка,
      </li>
      <li>
        <b>close</b> – соединение закрыто.
      </li>
    </ul>
    <p>
      Вот пример:
    </p>
    <p>
      
      let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");
      
      socket.onopen = function(e) {
        alert("[open] Соединение установлено");
        alert("Отправляем данные на сервер");
        socket.send("Меня зовут Джон");
      };
      
      socket.onmessage = function(event) {
        alert(`[message] Данные получены с сервера: ${event.data}`);
      };
      
      socket.onclose = function(event) {
        if (event.wasClean) {
          alert(`[close] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`);
        } else {
          // например, сервер убил процесс или сеть недоступна
          // обычно в этом случае event.code 1006
          alert('[close] Соединение прервано');
        }
      };
      
      socket.onerror = function(error) {
        alert(`[error] ${error.message}`);
      };
   </p>
    <p>
      Вызов socket.send(body) принимает body в виде строки или любом бинарном формате включая Blob, ArrayBuffer и другие. Дополнительных настроек не требуется, просто отправляем в любом формате. При получении данных, текст всегда поступает в виде строки. А для бинарных данных мы можем выбрать один из двух форматов: Blob или ArrayBuffer.
    </p>
    <p>
     <i>
       Источник: <a href="https://learn.javascript.ru/websocket">javascript.ru</a>
     </i>
    </p>
  </div>
</details>

<details>
  <summary>10. Что такое DOM (У браузера)?</summary>
  <div>
    <p>Когда браузер читает код HTML, всякий раз, когда он сталкивается с элементом HTML, таким как html, body, div и т. д., он создает объект JavaScript, называемый Node. В конце концов, все элементы HTML будут преобразованы в объекты JavaScript.</p>
    <p>Поскольку каждый элемент HTML имеет разные свойства, объект Node будет создан из разных классов (функций-конструкторов). Например, объект Node для элемента div создается из HTMLDivElement, который наследует класс Node.</p>
    <p>После того, как браузер создал узлы из HTML-документа, он должен создать древовидную структуру этих узловых объектов.</p>
    <img src="https://miro.medium.com/max/520/1*YSA8lCfCVPn3d6GWAVokrA.png" />
    <p>JavaScript не понимает, что такое DOM, это не является частью спецификаций JavaScript. DOM — это высокоуровневый веб-API, предоставляемый браузером для эффективного отображения веб-страницы и публичного предоставления ее разработчику для динамического управления элементами DOM для различных целей.</p>    
  </div>
</details>

<details>
  <summary>11. Что такое CSSOM?</summary>
<div>   
  <p>После построения DOM браузер считывает CSS из всех источников (внешних, встроенных, встроенных, пользовательский агент и т.&nbsp;д.) и создает CSSOM. CSSOM означает объектную модель CSS, которая представляет собой древовидную структуру, аналогичную DOM.</p>
  <p>Как мы знаем, большинство браузеров поставляется со своей собственной таблицей стилей, которая называется user agent stylesheet. Браузер сначала вычисляет окончательные свойства CSS для элемента DOM, переопределяя стили пользовательского агента с помощью CSS, предоставленных свойствами разработчика (используя правила специфичности), а затем построить узел.</p>  
  <p>Даже если свойство CSS (например, display) для определенного элемента HTML не определено ни разработчиком, ни браузером, его значение устанавливается равным значению этого свойства по умолчанию, как указано в стандарте W3C CSS.</p>
  <p>Например, цвет и размер шрифта среди прочего наследуют значение родителя, если эти свойства отсутствуют для элемента HTML. Таким образом, вы можете представить себе наличие этих свойств в элементе HTML и всех его дочерних элементов, наследующих их. Это называется каскадированием стилей, поэтому CSS является аббревиатурой от Cascading Style Sheets. Именно по этой причине браузер создает CSSOM, древовидную структуру для вычисления стилей на основе каскадных правил CSS.</p>

  <img src="https://miro.medium.com/max/357/1*DJg1yRx-AzkZposWbJKcaA.png" />

</div>
</details>


<details>
  <summary>12. Что такое Render tree?</summary>
  <div>
    <p>Render-Tree также представляет собой древовидную структуру, построенную путем объединения деревьев DOM и CSSOM. Браузер должен рассчитать расположение каждого видимого элемента и отрисовать их на экране, для этого браузер использует это Render-Tree. Следовательно, если Render-Tree не построено, ничего не будет напечатано на экране, поэтому нам нужны деревья DOM и CSSOM.</p>
    <p>Поскольку Render-Tree представляет собой низкоуровневое представление того, что в конечном итоге будет напечатано на экране, оно не будет содержать узлов, которые не занимают какую-либо область в пиксельной матрице. Например, display:none; элементы имеют размеры 0px X 0px, поэтому они не будут присутствовать в Render-Tree.</p>
    <img src="https://miro.medium.com/max/700/1*8HnhiojSoPaJAWkruPhDwA.png" />
    <p>Как видно из приведенной выше диаграммы, Render-Tree объединяет DOM и CSSOM для создания древовидной структуры, содержащей только те элементы, которые будут напечатаны на экране.</p>

  </div>
</details>

<details>
  <summary>13. Что такое REST API ?</summary>
  <p>Representational State Transfer (REST) в переводе — это передача состояния представления. Технология позволяет получать и модифицировать данные и состояния удаленных приложений, передавая HTTP-вызовы через интернет или любую другую сеть.
    Application Programming Interface (API), или программный интерфейс приложения — это набор инструментов, который позволяет одним программам работать с другими. API предусматривает, что программы могут работать в том числе и на разных компьютерах. В этом случае требуется организовать интерфейс API так, чтобы ПО могло запрашивать функции друг друга через сеть.</p>


  <div>
   GET /books/ – получает список всех книг. Как правило, это упрощенный список, т.е. содержащий только поля идентификатора и названия объекта, без остальных данных.
   </div>
   <div>
    GET /books/{id} – получает полную информацию о книге.
    </div>
   <div>
    POST /books/ – создает новую книгу. Данные передаются в теле запроса.
    </div>
   <div>
    PUT /books/{id} – изменяет данные о книге с идентификатором {id}, возможно заменяет их. Данные также передаются в теле запроса.
    </div>
   <div>
    OPTIONS /books – получает список поддерживаемых операций для указанного ресурса (практически не используется)
    </div>
   <div>
    DELETE /books/{id}– удаляет данные с идентификатором {id}.
  </div>
  <div>
    Идемпотентный запрос — это запрос, эффект которого от многократного выполнения равен эффекту от однократного выполнения.
  </div>

  <h2>Принципы REST API</h2>
  <ul>
    <li>Отделения клиента от сервера (Client-Server). Клиент — это пользовательский интерфейс сайта или приложения, например, поисковая строка видеохостинга. В REST API код запросов остается на стороне клиента, а код для доступа к данным — на стороне сервера. Это упрощает организацию API, позволяет легко переносить пользовательский интерфейс на другую платформу и дает возможность лучше масштабировать серверное хранение данных.</li>
    <li>Отсутствие записи состояния клиента (Stateless). Сервер не должен хранить информацию о состоянии (проведенных операций) клиента. Каждый запрос от клиента должен содержать только ту информацию, которая нужна для получения данных от сервера.</li>
    <li>Кэшируемость (Casheable). В данных запроса должно быть указано, нужно ли кэшировать данные (сохранять в специальном буфере для частых запросов). Если такое указание есть, клиент получит право обращаться к этому буферу при необходимости.</li>
    <li>Единство интерфейса (Uniform Interface). Все данные должны запрашиваться через один URL-адрес стандартными протоколами, например, HTTP. Это упрощает архитектуру сайта или приложения и делает взаимодействие с сервером понятнее.</li>
    <li>Многоуровневость системы (Layered System). В RESTful сервера могут располагаться на разных уровнях, при этом каждый сервер взаимодействует только с ближайшими уровнями и не связан запросами с другими.</li>
    <li>Предоставление кода по запросу (Code on Demand). Серверы могут отправлять клиенту код (например, скрипт для запуска видео). Так общий код приложения или сайта становится сложнее только при необходимости.</li>
    <li>Начало от нуля (Starting with the Null Style). Клиент знает только одну точку входа на сервер. Дальнейшие возможности по взаимодействию обеспечиваются сервером.</li>
  </ul>

  <h2>Стандарты</h2>
  <p>Сам по себе RESTful не является стандартом или протоколом. Разработчики руководствуются принципами REST API для создания эффективной работы с серверов для своих сайтов и приложений. Принципы позволяют выстраивать серверную архитектуру с помощью других протоколов: HTTP, URL, JSON и XML.</p>


</details>
<details>
  <summary>14. Объясните, что такое всплытие и погружение (event bubbling)</summary>
  <div>
    Всплытие и погружение — это фазы жизненного цикла события. Разница заключается в моменте определения факта наступления события. Изначально, при взаимодействии юзера с элементом интерфейса (клик на кнопку, например) событие погружается от объекта window к целевому элементу (target), после наступает стадия всплытия и событие всплывает от target обратно к window. Так, одно и то же событие может быть перехвачено раньше или позже.

  <h2>Погружение (Capturing)</h2>
  <p>Когда событие только возникло, оно начинает двигаться по DOM-дереву, начиная от корневого узла, до самого глубокого, на котором произошло событие.</p>

                     | |
      ---------------| |---------------
      | div          | |              |
      |   -----------| |-----------   |
      |   | button   \ /          |   |
      |   -------------------------   |
      |        Event CAPTURING        |
      ---------------------------------

  <p>Попутно на стадии погружения будут выполнены обработчики, которые были привязаны к этой стадии. Привязка регулируется третьим параметром функции addEventListener.</p>  

    button.addEventListener('click', () => alert('Boom 1!'), true);
    div.addEventListener('click', () => alert('Boom 2!'), true);

  <p>Значение true привязывает обработчики к стадии погружения.</p>

    Boom 2!
    Boom 1!

  <h2>Всплытие (Bubbling)</h2>
  <p>После остановки погружения на target элементе, начинается всплытие.</p>

                     / \
      ---------------| |---------------
      | div          | |              |
      |   -----------| |-----------   |
      |   | button   | |          |   |
      |   -------------------------   |
      |        Event BUBBLING         |
      ---------------------------------

  <p>Именно эта стадия подразумевается при вызове addEventListener без указания третьего параметра.</p>

    button.addEventListener('click', () => alert('Boom 1!'));
    div.addEventListener('click', () => alert('Boom 2!'));

  <p>На ней выполнение обработчиков происходит изнутри наружу</p>  

  <h2>Зачем?</h2>
  <p>Всплытие событий - важная часть поведения DOM. Без него было бы невозможно реализовать события, которые срабатывают на целых блоках, а не только самых глубоких элементах. Самый простой пример - контекстное меню. Другой пример - таблицы, устроенные по принципу Excel (Microsoft Office). Эти таблицы огромны и добавление событий на каждую ячейку привело бы к созданию большого числа одинаковых обработчиков, которые нужно постоянно добавлять с ростом таблицы. Кроме дополнительного кода, такая схема еще и тормозит на больших объемах. Гораздо проще, повесить один обработчик на всю таблицу.</p>

  <h2>W3C модель</h2>
  <p>Согласно стандарту, большинство событий проходят обе стадии, сначала погружаясь в глубину дерева и затем поднимаясь до самого верха. Стадия погружения используется редко, большая часть обработчиков вешается на стадию всплытия.</p>

  <p>В предыдущем уроке мы познакомились с объектом e.target. Это самый глубокий элемент, до которого идет погружение. Target не меняется в процессе всплытия. Благодаря ему всегда можно узнать, где конкретно произошло событие. Кроме него, доступен объект currentTarget - это элемент, к которому прикреплен данный обработчик. В зависимости от ситуации используется тот или иной.</p>

  <img src="https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjBiOGJlZGIxOWMxNDkxYWU2NmIxMTdkZDVmMWRhZmIxLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=116b1dc416f798873e47e92e94707bb4ad56818f9eb0578313db996137bdbdd1" />

  <p>В обычной ситуации событие должно всплывать до конца, но иногда могут возникать ситуации, когда всплытие нежелательно.</p>

  <p>Сделать это можно двумя способами:</p>

  <ul>
    <li>event.stopPropagation() - останавливает всплытие, но дает возможность доработать всем обработчикам, которые висят на текущем элементе,</li>
    <li>event.stopImmediatePropagation() - не дает выполниться больше ни одному обработчику</li>
  </ul>

  <h3>Что такое делегирование событий в JS</h3>
  <ul>
    <li>простой метод, с помощью которого ты добавляешь один обработчик событий к родительскому элементу, чтобы избежать необходимости добавлять обработчики событий к нескольким дочерним элементам.</li>
    <li>используя делегирование событий, можно добавить обработчик событий к элементу, дождаться, пока событие не всплывет из дочернего элемента, и тогда легко определить, из какого элемента возникло событие.</li>
  </ul>

  <p>Подведем итог. Перехват - это механизм передачи события обработчику. При погружении или всплытии событие переходит от одного элемента другому, и если есть в элементе обработчик этого события, то он вызывается, то есть происходит перехват события обработчиком. А используя описанные выше методы, мы можем остановить процесс передачи события между элементами.</p>
  </div>
</details>  

<details>
  <summary>15. Назовите 5 классов ошибок при HTTP запросе? </summary>
<div>
<ul>
  <li>1xx Информирование о процессе передачи.</li>
  <li>2xx Информирование о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения.</li>
  <li>3xx Сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI). Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся непосредственно к перенаправлениям (редирект). Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location. При этом допускается использование фрагментов в целевом URI.</li>
  <li>4xx Указание ошибок со стороны клиента. При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.</li>
  <li>5xx Информирование о случаях неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.</li>
</ul>
</div>
</details>  

<details>
  <summary>16. Что такое веб-хранилище (Web Storage)?</summary>
<div>   
  Веб-хранилище — это интерфейс, позволяющий хранить данные в виде пар ключ/значение локально, т.е. в браузере пользователя, более удобным способом, чем при использовании куки. Веб-хранилище предоставляет два механизма хранения данных:

  Локальное хранилище (local stotage) — хранит данные текущего пользователя неограниченное количество времени
  Сессионное хранилище (session storage) — хранит данные на протяжении текущей сессии, т.е. при закрытии вкладки браузера данные будут потеряны
</div>
</details> 

<details>
  <summary>17. Что такое куки (cookie)?</summary>
<div>   
  Куки — это небольшой фрагмент данных, который сохраняется на компьютере пользователя для последующего использования браузером. Куки сохраняются в виде пар ключ/значение:

  document.cookie = 'username=John'
  <img src="https://habrastorage.org/webt/uv/0q/jv/uv0qjvrn1vx9ruhuxn6aa0aniqg.png"/>
</div>
</details>

<details>
  <summary>18. Зачем нужны куки?</summary>
<div>   
  Куки используются для сохранения информации о пользователе (не рекомендуется использовать для хранения конфиденциальной информации). Обычно, данный процесс состоит из двух этапов:

  При первом посещении страницы профиль пользователя сохраняется в куки
  При повторном посещении страницы профиль пользователя извлекается из куки
</div>
</details>



<details>
  <summary>19. Какими возможностями обладают куки?</summary>
<div>   
  По умолчанию, куки удаляются при закрытии браузера, однако это можно изменить, установив время жизни (expires) (в формате UTC):

  document.cookie = 'username=John; expires=Sat, 5 Sep 2020 12:00:00 UTC'

  По умолчанию, куки принадлежат текущей странице, однако это также можно изменить, установив путь (path):

  document.cookie = 'username=John; path=/services'
</div>
</details>



<details>
  <summary>20. В кратце о indexedDB?</summary>
<div>   
  IndexedDB можно рассматривать как «localStorage на стероидах». Это простая база данных типа ключ-значение, достаточно мощная для оффлайн приложений, но простая в использовании.

  <ul>
    <li>Хранилище ключей/значений: доступны несколько типов ключей, а значения могут быть (почти) любыми.</li>
    <li>Поддерживает транзакции для надёжности.</li>
    <li>Поддерживает запросы в диапазоне ключей и индексы.</li>
    <li>Позволяет хранить больше данных, чем localStorage.</li>
  </ul>

  Для традиционных клиент-серверных приложений эта мощность обычно чрезмерна. IndexedDB предназначена для оффлайн приложений, можно совмещать с ServiceWorkers и другими технологиями.

  Использование можно описать в нескольких фразах:

  <ul>
    <li>Подключить обёртку над промисами, например idb.</li>
    <li>Открыть базу данных: idb.openDb(name, version, onupgradeneeded)</li>
    <li>Создание хранилищ объектов и индексов происходит в обработчике onupgradeneeded.</li>
    <li>Обновление версии – либо сравнивая номера версий, либо можно проверить что существует, а что нет.</li>
    <li>Для запросов:</li>
    <li>Создать транзакцию db.transaction('books') (можно указать readwrite, если надо).</li>
    <li>Получить хранилище объектов transaction.objectStore('books').</li>
    <li>Затем для поиска по ключу вызываем методы непосредственно у хранилища объектов.</li>
    <li>Для поиска по любому полю объекта создайте индекс.</li>
    <li>Если данные не помещаются в памяти, то используйте курсор.</li>
  </ul>

</div>
</details>



<details>
  <summary>21. Что такое Same-origin policy?</summary>
  <div>
  <br/>
  <p>
    Same-origin policy — это механизм безопасности веб-браузера, направленный на предотвращение атак веб-сайтов друг на друга.
    Same-origin policy ограничивает доступ сценариев из одного источника к данным из другого источника. Источник состоит из схемы URI, домена и номера порта. Например, рассмотрим следующий URL-адрес:
  </p>

    http://normal-website.com/example/example.html

  <p>
    Тут используется схема http, домен normal-website.com и номер порта 80. В следующей таблице показано, как будет применяться политика того же источника, если контент по указанному выше URL-адресу пытается получить доступ к другим источникам:
  </p>

      URL accessed	                          Access permitted?
      http://normal-website.com/example/    	Yes: same scheme, domain, and port
      http://normal-website.com/example2/	    Yes: same scheme, domain, and port
      https://normal-website.com/example/	    No: different scheme and port
      http://en.normal-website.com/example/ 	No: different domain
      http://www.normal-website.com/example/	No: different domain
      http://normal-website.com:8080/example/	No: different port*



  <p>Когда браузер отправляет HTTP-запрос из одного источника в другой, любые файлы cookie, включая файлы cookie сеанса аутентификации, относящиеся к другому домену, также отправляются как часть запроса. Это означает, что ответ будет сгенерирован в рамках сеанса пользователя и будет включать любые релевантные данные, характерные для пользователя. Без Same-origin policy, если вы посетили вредоносный веб-сайт, он сможет читать ваши электронные письма из GMail, личные сообщения из Facebook и т. д.</p>

  <p>Это распространенное заблуждение, что политика одного и того же источника блокирует все ресурсы из разных источников. Если бы это было правдой, сетей доставки контента (CDN) не существовало бы. Существует несколько тегов HTML, которые обычно позволяют встраивать ресурсы из разных источников: iframe, img, script, video, link, object, embed, form. Обратите внимание, что они также не разрешают чтение из разных источников. Разница между внедрением и чтением ресурса заключается в том, что при внедрении ресурс копируется из внешнего источника и отображается локально, а чтение ресурса означает, что его источник сохраняется. Хотя политика одинакового происхождения является важной функцией безопасности браузера, которая обеспечивает надежную защиту от вредоносных скриптов, она далека от совершенства. В некоторых случаях это недостаточно ограничительно, и возникают распространенные веб-уязвимости, такие как подделка межсайтовых запросов (CSRF). В других случаях политика слишком ограничительна и запутывает рабочий процесс веб-приложения. Инженеры представили стандарт под названием Cross-Origin Resource Sharing. как способ ослабить ограничения политики одного и того же происхождения. </p>
  </div>
</details>


 <details>
   <summary>22. Что такое CSP?</summary>
   <div>
   <p>Целью CSP является защита от атак с использованием межсайтовых сценариев (XSS), определяя, каким сценариям следует доверять, а каким нет. Когда браузер пытается запустить скрипт из неизвестного источника, CSP блокирует его, если он не находится в списке надежных источников. Если CSP не указан, сайт по умолчанию будет использовать «Политику того же происхождения» (SOP).</p>


   <p>Основной целью CSP является ограничение источников веб-контента, поэтому существует множество директив для указания разрешенных источников для различных типов ресурсов. Как только заголовок Content-Security-Policy указан, браузер будет отклонять любой контент из источников, которые явно не занесены в белый список, с использованием любой из приведенных ниже директив. Исходные значения разделены пробелами и могут включать как URL-адреса, так и специальные ключевые слова ‘none’, ‘self’, ‘unsafe-inline’ и ‘unsafe-eval’ (подробно обсуждается ниже). Обратите внимание, что каждая директива может быть указана только один раз в том же заголовке, а ключевые слова должны быть введены в одинарные кавычки.
   </p>
   <p>Заголовок ответа Content-Security-Policy содержит правила для этого запроса. CSP может ограничивать такие вещи, как:</p>

  <ul>
    <li>default-src является резервной директивой, используемой для определения политики содержимого по умолчанию для большинства исходных директив. Обычно используются default-src ‘self’, чтобы разрешить контент из текущего источника (но не его поддоменов), и default-src ‘none’, чтобы заблокировать все, что явно не занесено в белый список.</li>
    <li>script-src используется для внесения в белый список источников скриптов. Чтобы разрешить скрипты только из текущего источника, используйте script-src ‘self’.</li>
    <li>style-src используется для внесения в белый список источников стилей CSS. Чтобы разрешить таблицы стилей только из текущего источника, используйте style-src ‘self’.</li>
    <li>media-src: ограничивает загрузку аудио и медиафайлов.</li>
    <li>img-src: ограничивает загружаемые изображения.</li>
  </ul>

  <p>Встроенный код является основным вектором нападения, потому что он всегда выполняется в текущем контексте, поэтому его нельзя ограничивать. Когда CSP включен, он блокирует весь встроенный код по умолчанию. Это означает, что никаких встроенных стилей или встроенных сценариев не должно существовать, включая встроенные обработчики событий или javascript: URL поэтому любой новый код должен следовать передовым методам использования исключительно внешних файлов сценариев и стилей. Ключевое слово unsafe-inline разрешает встроенный код для всех или некоторых источников скриптов, но W3C рекомендует избегать его, где это возможно.</p>
  <p>Например, страница HTML и JavaScript старого стиля может содержать код сценария как в тегах <'script> , так и в обработчиках встроенных событий:</p>

    <script>function performButtonAction() {
      alert('You clicked the button!');}
    </script>
    <button onclick='performButtonAction();'>
      Want to click the button?
    </button>

  <p>Чтобы преобразовать это в современный и совместимый с CSP стиль, поместите сценарий в отдельный файл и используйте HTML чисто декларативно, что-то вроде:</p>

    <!-- buttonexample.html -->
    <script src='buttonexample.js'></script>
    <button id='examplebutton'>Want to click the button?</button>


  <p>Даже после того, как типичные векторы атак были заблокированы, злоумышленники все равно могут выполнить сценарий, если используется динамически запускаемый (evaluated) код. Вот почему CSP также блокирует все функции запуска строк по умолчанию, включая eval (), new Function (), setTimeout ([string]) и аналогичные конструкции. Это приводит к нескольким изменениям в практике кодирования, включая использование JSON.parse () вместо eval() для анализа данных JSON.</p>


  <p>Основные отличия CSP, CORS и SOP</p>

  <ul>
    <li>Вы хотите запросить ресурс с другого сайта ~ Какие политики CORS у них есть?</li>
    <li>Другой сайт хочет запросить ресурс с вашего сайта. Какие политики CORS у вас есть?</li>
    <li>Вы хотите загрузить ресурс (скрипт, изображение, что угодно) с другого сайта ~ позволяет ли ваша политика безопасности контента загружать ресурсы с этого домена?</li>
  </ul>

  <p>Если кратко и утрированно, то SCP — это про SOP и frontend-часть системы. А access-control-allow-otigin — про CORS и backend-часть.</p>

   <a href="https://dev.to/sophiekaelin/what-is-the-difference-between-cors-and-csp-i7n" >Cors vs csp</a>
   </div>
 </details>

 <details>
   <summary>23. Расскажите как браузер рендерит страницу</summary>
   <div>
     <br/>
     <p>Под капотом браузер выглядитпримерно так:</p>
     <img src="https://habrastorage.org/r/w1560/webt/dl/fr/hh/dlfrhh43eqb66arhgeic_h6e_8c.png">
     <ul>
       <li>User Interface — это все что видит пользователь: адресная строка, кнопки вперед/назад, меню, закладки — за исключением области где отображается сайт.</li>
       <li>Browser Engine отвечает за взаимодействие между User Interface и Rendering Engine. Например клик по кнопке назад должен сказать компоненте RE что нужно отрисовать предыдущее состояние.</li>
       <li>Rendering Engine отвечает за отображение веб-страницы. В зависимости от типа файла, эта компонента может парсить и рендерить как HTML/XML и CSS, так и PDF .</li>
       <li>Network выполняет xhr запросы за ресурсами, и в целом, общение браузера с остальным интернетом происходит через эту компоненту, включая проксирование, кэширование и так далее.</li>
       <li>JS Engine место где парсится и исполняется js код.</li>
       <li>UI Backend используется чтобы рисовать стандартные компоненты типа чекбоксов, инпутов, кнопок.</li>
       <li>Data Persistence отвечает за хранение локальных данных, например в куках, SessionStorage, indexDB и так далее.</li>
     </ul>
     <div>
       <p>C помощью компонента Network браузер начал получать html-файл чанками обычно по 8кб, дальше с помощью Rendering Engine идет процесс рендеринга и парсинга</p>
       <p>Процесс парсинга выглядит вот так:</p>
       <div><img src="https://habrastorage.org/r/w1560/webt/64/6h/n1/646hn1rs70cjwv3g64bolqeemq4.png"></div>
       <p>Результатом парсинга является DOM дерево.</p>
       <p>По мере того как браузер парсит html файл, он встречает теги содержащие ссылки на сторонние ресурсы ( link, script, img и так далее) — по мере их обнаружения происходит запрос за этими ресурсами.</p>
       <p>Таким образом, отправив запрос по адресу прописанному в атрибуте href тега <link rel="stylessheet"> и получив файл css стилей, браузер парсит этот файл и строит так называемый CSS Object Model — CSSOM.</p>
       <p>Далее браузер строит Render Tree чтобы точно определить что ему нужно отрисовать и в каком порядке. Построение Render дерева происходит примерно так: начиная с рутового элемента (html), парсер проходит по всем видимым элементам (пропуская link, script, meta, скрытые через css элементы) и для каждого видимого элемента находит соответствующее css правило из CSSOM.</p>
       <p>Затем стадия Layout — это рекурсивный процесс определения положения и размеров элементов из Render Tree. Он начинается от корневого Render Object, которым является , и проходит рекурсивно вниз по части или всей иерархии дерева высчитывая геометрические размеры дочерних render object'ов. Корневой элемент имеет позицию (0,0) и его размеры равны размерам видимой части окна, то есть размеру viewport'a. </p>
       <p>В конце стадия Paint — этап, где пиксель монитора заполняется цветом указанным в свойствах render object'а и белый экран превращается в картину задуманную автором (разработчиком). На всем пути рендеринга  —  это самый дорогой процесс (не то чтобы предыдущее дешевые).</p>
       <div>
         <p>Итого:</p>
         <p>Браузер получает html файл, парсит его и строит DOM. Встречая css стили, браузер их подгружает, парсит, строит CSSOM и объединяет вместе с DOM'ом — получаем Render Tree. Осталось выяснить где расположить элементы из Render Tree — этим занимается задача layout. После расположения элементов, можно начать рисовать их — это задача paint, этап на котором заполняются пиксели экрана.</p>
         <p><img src="https://habrastorage.org/r/w1560/webt/vy/30/eh/vy30eha1riss2agnsvnzbk2bwlq.png"></p>
       </div>
     </div>
     <h2>События загрузки страницы:</h2>
     <p>Каждое из этих событий может быть полезно:</p>
     <ul>
      <li>Событие DOMContentLoaded – DOM готов, так что обработчик может искать DOM-узлы и инициализировать интерфейс. Событие DOMContentLoaded срабатывает на объекте document.
      Мы должны использовать addEventListener, чтобы поймать его: document.addEventListener("DOMContentLoaded", ready);</li>
      <li>Событие load – внешние ресурсы были загружены, стили применены, размеры картинок известны и т.д.</li>
      <li>Событие beforeunload – пользователь покидает страницу. Мы можем проверить, сохранил ли он изменения и спросить, на самом ли деле он хочет уйти.</li>
      <li>unload – пользователь почти ушёл, но мы всё ещё можем запустить некоторые операции, например, отправить статистику.</li>
     </ul> 
     <ul>
      <li>DOMContentLoaded генерируется на document, когда DOM готов. Мы можем применить JavaScript к элементам на данном этапе.</li>
      <li>
        <ul>
          <li>Скрипты, вроде <'script>...</'script> или <'script src="..."></'script> блокируют DOMContentLoaded, браузер ждёт, пока они выполнятся.</li>
          <li>Изображения и другие ресурсы тоже всё ещё могут продолжать загружаться.</li>
        </ul>
      </li>
      <li>Событие load на window генерируется, когда страница и все ресурсы загружены. Мы редко его используем, потому что обычно нет нужды ждать так долго.</li>
      <li>Событие beforeunload на window генерируется, когда пользователь покидает страницу. Если мы отменим событие, браузер спросит, на самом ли деле пользователь хочет уйти (например, у нас есть несохранённые изменения).</li>
      <li>Событие unload на window генерируется, когда пользователь окончательно уходит, в обработчике мы можем делать только простые вещи, которые ни о чём не спрашивают пользователя и не заставляют его ждать. Из-за этих ограничений оно редко используется. Мы можем послать сетевой запрос с помощью navigator.sendBeacon.</li>
      <li>document.readyState – текущее состояние документа, изменения можно отследить с помощью события readystatechange:</li>
      <li>
        <ul>
          <li>loading – документ грузится.</li>
          <li>interactive – документ прочитан, происходит примерно в то же время, что и DOMContentLoaded, но до него.</li>
          <li>complete – документ и ресурсы загружены, происходит примерно в то же время, что и window.onload, но до него.</li>
        </ul>
      </li>
   </div>
 </details>



<details>
  <summary>24. Что такое CSRF (XSRF) атака?</summary>
  <div>
    <img src="https://media.tproger.ru/uploads/2021/07/Screenshot-2021-06-07-at-01.16.23-1760x855.png"/>
    <p>Cross-Site Request Forgery («Межсетевая подделка запроса»). Этот вектор атаки использует склонность браузера неявно добавлять куки к любому запросу. Например, вы авторизовались на сайте, где используются куки, и в какой-то момент некий скрипт делает запрос на origin этого банка — то есть открыли почтовый клиент и перешли по вредоносной ссылке. Браузер автоматически добавит куки к запросу, даже если сам запрос происходит с другой вкладки.</p>
    <p>Из-за SOP этот скрипт не будет иметь доступа к response. Но он сможет выполнять запросы на правах авторизованного пользователя. Например, сделать запрос на перевод денег или просто на удаление любой возможной информации.</p>
    <p>Для предотвращения этой атаки в первую очередь рекомендуется использовать явные системы аутентификации. Например, session token / jwt в header или session token в body param. Также, если на сайте используется какая-то форма, то рекомендуется реализовывать anti-csrf token’ы. Их суть в том, что сервер в response отдаёт два случайных токена. Один предназначен для куков, другой прячется в скрытом поле формы. Когда клиент submit’ит форму, то должен отправить оба токена обратно на сервер. В случае, если они отличаются от того, что сервер выпустил изначально, сервер блокирует запрос.</p>
    <h2>Отличия от XSS.</h2>
    <p>Если XSS — это случай, когда браузер слишком доверяет JavaScript с сервера, то CSRF — это случай, когда сервер слишком доверяет браузеру.</p>
    <h2>Способы защиты:</h2>
    <h3>CSRF Token:</h3>
    <p>Используйте токены анти-CSRF с каждым запросом, который изменяет состояние на веб-сайте. Веб-приложение должно генерировать эти токены на стороне сервера, и их значение должно быть непредсказуемым. Если пользователь-злоумышленник попытается провести CSRF-атаку, он никогда не сможет изменить состояние на веб-сайте, поскольку его запрос должен включать связанный токен, который ему неизвестен.</p>
    <h3>SameSite Cookie</h3>
    <p>Атрибут файла cookie SameSite предотвратит отправку файлов cookie в межсайтовых запросах. Веб-сайт должен указать в своем заголовке ответа «Set-Cookie» значение SameSite для Lax или Strict. Это предотвратит отправку браузером файла cookie сеанса на веб-сайт с запросами, исходящими с других веб-сайтов.</p>
    <a href="https://tproger.ru/articles/xss-i-csrf-ataki-razbiraem-ujazvimosti/">XSS- и CSRF-атаки — разбираем уязвимости</a>
  </div>
</details>
<br/>


